\input cwebmac
% -*- mode: cweb -*-

% Copyright 2012 Sandia Corporation. Under the terms of Contract
% DE-AC04-94AL85000, there is a non-exclusive license for use of this work by
%or
% on behalf of the U.S. Government. Export of this program may require a
%license
% from the United States Government.

\def\todo{TODO COMMAND}
\let\ifpdf=\relax
\def\NULL{{\tt NULL}} %I think the default greek thing is confusing
\input eplain
\beginpackages
  \usepackage{url}
  \usepackage[dvipsnames]{color}
\endpackages
\enablehyperlinks
\hlopts{bwidth=0}
\hlopts[url]{colormodel=named,color=BlueViolet}

\def\numberedmarker{{\fam1\teni \number\itemnumber}}
\def\numberedprintmarker#1{\llap{#1 \listmarkerspace}}
\def\unorderedmarker{---}
\listleftindent=\parindent
\listleftindent=2\parindent
\abovelistskipamount=0pt
\belowlistskipamount=0pt
\interitemskipamount=0pt

\def\osf#1{{\fam1 \teni #1}}
\let\footnote=\numberedfootnote



\input font_palatino

\baselineskip=12pt %10/12
\let\cmntfont=\sl
\let\mainfont=\rm
\mainfont
\def\paragraphit#1{{\it #1\/}\hskip\parindent}


\def\funcsat{{\caps funcsat}}
\def\minisat{{\caps minisat}}
\def\picosat{{\caps picosat}}

\def\acro#1{{\twelvecaps #1}}
\def\textit#1{{\it #1\/}}

\def\SAT{\acro{sat}}
\def\UNSAT{\acro{unsat}}
\def\UIP{\acro{uip}}
\def\LBD{\acro{lbd}}
\def\BCP{\acro{bcp}}

\let\or\vee
\let\and\hat



% Important sections for this WEB:

% External types -- goes into <file>.h
% External declarations -- goes into <file>.h after External ty...
% Internal types -- goes into <file>_internal.h
% Internal declarations -- goes into <file>_internal.h after Internal ty...
% Global definitions -- goes into <file>.c after Internal decl...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  IT BEGINS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\N{1}{1}Introduction.  \funcsat\ is a CDCL SAT solver, written by Denis Bueno
\url{denis.bueno@sandia.gov} at Sandia National Labs. It was developed under
LDRD funding. It is written in ANSI \CEE/99.

Copyright 2012 Sandia Corporation. Under the terms of Contract
DE-AC04-94AL85000, there is a non-exclusive license for use of this work by or
on behalf of the U.S. Government. Export of this program may require a license
from the United States Government.


\funcsat's main goal is {\it flexibility}. It has a bunch of features, blah
blah.

\Y\fi

\N{1}{2}The Client. Information in the {\tt funcsat.h} header file should give
you all you
need to begin using \funcsat. We provide methods for the following:

\numberedlist

\li Creating (\PB{\\{funcsatInit}}) and destroying (\PB{\\{funcsatDestroy}}) a
SAT solver

\li Adding instance clauses (\PB{\\{funcsatAddClause}})

\li Solving (\PB{\\{funcsatSolve}}) SAT instances.

\endnumberedlist

\funcsat\ is an extensible SAT solver. This means SAT instances can be solved
under unit assumptions.

\numberedlist

\li In order to add a unit assumption, use \PB{\\{funcsatPushAssumption}}.

\li {\bf You must check the return value}. If it returns \PB{\.{FS\_UNSAT}},
the
assumption is not actually pushed because your problem is trivially
unsatisfiable.

\li At this point, if you call \PB{\\{funcsatSolve}}, the SAT instance is
restricted to
solutions where every push assumption is true.

\li In order to relieve assumptions, call \PB{\\{funcsatPopAssumptions}}.
Assumptions
are kept on a LIFO stack and {\it push} and {\it pop} have LIFO semantics.

\endnumberedlist

\fi

\N{1}{3}The Developer.

The second category of user is going to want to modify funcsat. What follows is
an overview of all data structures in \funcsat.


\fi

\M{4}Vocab and data types.

\numberedlist

\li The order of inferences (implied literals) is kept in the \PB{\&{funcsat} $%
\MG$ \\{trail}},
a chronological list of the current (partial) assignment.

\li The \PB{\&{funcsat} $\MG$ \\{model}} tells whether a variable is assigned
given the
variable's index in the trail. A variables assignment (either True or False) is
called its {\it phase}.

\li The \PB{\&{funcsat} $\MG$ \\{level}} of each variable is the decision level
at which the
variable was set: if the variable was set at decision level 0, that means it's
True for all time.

\li The \PB{\&{funcsat} $\MG$ \\{decisions}} tells whether a particular
variable is a
{\it decision variable} (a choice point, a branch) or not. A variable that is
not a decision is an {\it inference}, or currently unassigned. Each inference
has a {\it reason} (a clause sometimes called an antecedent) stored in
\PB{\&{funcsat} $\MG$ \\{reason}}.

\li Each clause can either be original or learned; a learned clause is implied
by the SAT instance.

\endnumberedlist

\fi

\M{5}Generic data types. There are some datatypes used everywhere in funcsat:

\unorderedlist

\li \PB{\&{variable}}, \PB{\&{literal}}: just typedefs for \PB{\&{uintmax\_t}}
and \PB{\&{intmax\_t}}, resp.

\li \PB{\&{vec\_ptr}}: a growable, sized array of pointers. It can act as an
efficient
\acro{lifo} stack. In fact, there is a whole family of vectors with essentially
the same semantics, differing only in the underlying element type.

\li \PB{\&{clause}}: a clause; or just a growable, sized array of \PB{\&{intmax%
\_t}}

\li \PB{\&{mbool}}: a three-value Boolean, or ``multi-Bool''. Possible values
are
\PB{\\{true}}, \PB{\\{false}}, and \PB{\\{unknown}}.

\li \PB{\&{clause\_head}} and \PB{\&{clause\_block}}. You can read about these
in the Clauses
section (page~\refn{pg-clauses}).


\endunorderedlist

Other available data types:
\unorderedlist

\li \PB{\&{struct} \&{hashtable}}: just a direct chained hash table
\li \PB{\&{fibheap}}: fibonacci heap (prio queue impl)

\endunorderedlist

\fi

\M{6}If you want to add some new solver state...

The core solver state is in this file; the data type is \PB{\&{funcsat}}. For
example,
when I added phase saving I needed a new vector to store the last phase. So,

\unorderedlist
\li I added a \PB{\&{funcsat} $\MG$ \\{phase}} into \PB{\&{funcsat}}.
\li Next, I allocated the state in \PB{\\{funcsatInit}}
\li and free'd the state in \PB{\\{funcsatDestroy}}
\li Finally, I added the incremental resizing of the state
in \PB{\\{funcsatResize}}.

\endunorderedlist

{\bf Do not allocate during solving.} Allocate only during \PB{\\{funcsatInit}}
and
\PB{\\{funcsatResize}}. Allocating during solving is bad. Of course we have to
allocate
when learning a new learned clause. But we often do not have to call \PB{%
\\{malloc}(\T{1})}
when this happens -- because there is a pool of clauses that get recycled.

\fi

\M{7}If you want to add a new user-settable parameter...

All such parameters are part of the \PB{\&{funcsat\_config}}, which is stored
per-solver in \PB{\&{funcsat} $\MG$ \\{conf}}.

\fi

\M{8}If you want to change the clause learning...

See the learning on page \refn{pg-clause-learn}. It's a really nasty loop that
calculates all the UIPs of the current conflict graph, or at least all the UIPs
the user wants. It does resolution to figure out which clause to learn. It does
conflict clause minimisation using Van Gelder's DFS-based minimisation
algorithm. It does only-the-fly self-subsuming resolution with each resolvent
produced during learning.

\fi

\M{9}If you want to add a new stat...

Put it in \PB{\&{funcsat}}. Then you'll probably want to change \PB{%
\\{funcsatPrintStats}},
too (and possibly even \PB{\\{funcsatPrintColumnStats}}).

\fi

\M{10}If you want to add a new argument...

Probably you should be exposing some option in \PB{\&{funcsat} $\MG$ \\{conf}}.
In any case, you
need to look in {\tt main.c} to see how getopt is used to handle the existing
options. Then hack yours in.


Create a new \funcsat\ instance.  \funcsat\ is designed to be thread-safe so
one
process may create as many solvers as it likes. Get your default config from
\PB{\\{funcsatConfigInit}}.

\fi

\N{1}{11}Implementation. This file was originally not literate. I'm converting
it to
literate style bit by bit. Be patient. First, the public header file is pretty
simple.

\Y\B\4\D$\\{swap}(\\{ty},\|x,\|y)$ \5
$\\{ty}\\{\_swap\_tmp}\#{\#}\\{ty}\K(\|x);{}$\6
${}(\|x)\K(\|y),\39(\|y)\K\\{\_swap\_tmp}\#{\#}\\{ty}{}$;\par
\Y\B\4\X11:\.{funcsat.h }\X${}\E{}$\6
\8\#\&{ifndef} \\{funcsat\_h\_included}\6
\8\#\&{define} \\{funcsat\_h\_included}\6
\8\#\&{include} \.{<stdio.h>}\6
\8\#\&{include} \.{<stdlib.h>}\6
\8\#\&{include} \.{<inttypes.h>}\6
\8\#\&{include} \.{<stdbool.h>}\6
\8\#\&{include} \.{"funcsat/vec\_bool.h"}\6
\8\#\&{include} \.{"funcsat/vec\_uint64.}\)\.{h"}\6
\X13:External types\X\6
\X15:External declarations\X\6
\8\#\&{endif}\par
\fi

\M{12}The internal header file is where our internal types and declarations go

\Y\B\4\X12:\.{funcsat\_internal.h }\X${}\E{}$\6
\8\#\&{ifndef} \\{funcsat\_internal\_h\_included}\6
\8\#\&{define} \\{funcsat\_internal\_h\_included}\6
\8\#\&{include} \.{"funcsat/vec\_ptr.h"}\6
\8\#\&{include} \.{"funcsat/vec\_intmax.}\)\.{h"}\6
\8\#\&{include} \.{<funcsat/fibheap.h>}\6
\X235:Conditional macros\X\6
\X38:Internal types\X\6
\X21:Main \funcsat\ type\X\6
\X25:Internal declarations\X\6
\8\#\&{endif}\par
\fi

\M{13} All the external types need the basic \funcsat\ types.

\Y\B\4\X13:External types\X${}\E{}$\6
\8\#\&{include} \.{"funcsat/system.h"}\6
\8\#\&{include} \.{"funcsat/vec\_uintmax}\)\.{.h"}\6
\8\#\&{include} \.{"funcsat/hashtable.h}\)\.{"}\par
\As17, 32, 94\ETs234.
\U11.\fi

\M{14}Next comes \funcsat! I've put all the includes here, for simplicity. Note
that
this file has no {\tt main} function---we only define \funcsat's internals and
API here. See {\tt main.c} for the grungy details of exposing all of \funcsat's
options on the command-line.

It's pretty gross.

\Y\B\8\#\&{include} \.{"funcsat/config.h"}\6
\8\#\&{include} \.{<stdio.h>}\6
\8\#\&{include} \.{<stdlib.h>}\6
\8\#\&{include} \.{<stdarg.h>}\6
\8\#\&{include} \.{<assert.h>}\6
\8\#\&{include} \.{<string.h>}\6
\8\#\&{include} \.{<float.h>}\6
\8\#\&{include} \.{<math.h>}\6
\8\#\&{include} \.{<sys/resource.h>}\6
\8\#\&{include} \.{<sys/stat.h>}\6
\8\#\&{include} \.{<inttypes.h>}\6
\8\#\&{include} \.{<errno.h>}\6
\8\#\&{include} \.{<funcsat/hashtable.h}\)\.{>}\6
\8\#\&{include} \.{<funcsat/system.h>}\6
\8\#\&{include} \.{<zlib.h>}\6
\8\#\&{include} \.{<ctype.h>}\6
\8\#\&{include} \.{"funcsat.h"}\6
\8\#\&{include} \.{"funcsat\_internal.h"}\6
\8\#\&{include} \.{"funcsat/vec\_uintptr}\)\.{.h"}\6
\X16:Global definitions\X\par
\fi

\M{15}I use the following macros for memory management, just because.

\Y\B\4\X15:External declarations\X${}\E{}$\6
\8\#\&{define} $\.{FS\_CALLOC}(\\{ptr},\39\|n,\39\\{size})$ \&{do}\5
${}\{{}$\1\6
${}\\{ptr}\K\\{calloc}((\|n),\39(\\{size}));{}$\6
\&{if} ${}(\R\\{ptr}){}$\1\5
${}\\{perror}(\.{"FS\_CALLOC"}),\39\\{abort}(\,);{}$\2\6
\4${}\}{}$\2\5
\&{while} (\T{0}); \6
\8\#\&{define} $\.{FS\_MALLOC}(\\{ptr},\39\|n,\39\\{size})$ \&{do}\5
${}\{{}$\1\6
${}\\{ptr}\K\\{malloc}((\|n)*(\\{size}));{}$\6
\&{if} ${}(\R\\{ptr}){}$\1\5
${}\\{perror}(\.{"FS\_MALLOC"}),\39\\{abort}(\,);{}$\2\6
\4${}\}{}$\2\5
\&{while} (\T{0}); \6
\8\#\&{define} $\.{FS\_MALLOC\_TY}(\\{ty},\39\\{ptr},\39\|n,\39\\{size})$ %
\&{do}\5
${}\{{}$\1\6
${}\\{ptr}\K(\\{ty})\\{malloc}((\|n)*(\\{size}));{}$\6
\&{if} ${}(\R\\{ptr}){}$\1\5
${}\\{perror}(\.{"FS\_MALLOC\_TY"}),\39\\{abort}(\,);{}$\2\6
\4${}\}{}$\2\5
\&{while} (\T{0}); \6
\8\#\&{define} $\.{FS\_REALLOC}(\\{ptr},\39\|n,\39\\{size})$ \&{do}\5
${}\{{}$\1\6
\&{void} ${}{*}\\{tmp\_funcsat\_ptr\_\_};{}$\7
${}\\{tmp\_funcsat\_ptr\_\_}\K\\{realloc}(\\{ptr},\39(\|n)*(\\{size}));{}$\6
\&{if} ${}(\R\\{tmp\_funcsat\_ptr\_\_}){}$\1\5
${}\\{free}(\\{ptr}),\39\\{perror}(\.{"FS\_REALLOC"}),\39\\{abort}(\,);{}$\2\6
${}\\{ptr}\K\\{tmp\_funcsat\_ptr\_\_};{}$\6
\4${}\}{}$\2\5
\&{while} (\T{0}); \6
\8\#\&{define} $\.{FS\_REFS\_CALLOC}(\|p,\39\|o,\39\|n,\39\\{sz})$ \&{do}\5
${}\{{}$\1\6
${}\\{assert}((\|n)\G(\|o));{}$\7
\&{void} ${}{*}\\{tmp\_funcsat\_ptr\_\_};{}$\7
${}\\{tmp\_funcsat\_ptr\_\_}\K\\{realloc}(\|p,\39(\|n)*(\\{sz}));{}$\6
\&{if} ${}(\R\\{tmp\_funcsat\_ptr\_\_}){}$\1\5
${}\\{perror}(\.{"FS\_REFS\_CALLOC"}),\39\\{abort}(\,);{}$\2\6
${}\\{memset}(\\{tmp\_funcsat\_ptr\_\_}+((\|o)*(\\{sz})),\39\T{0},\39((\|n)-(%
\|o))*(\\{sz}));{}$\6
${}(\|p)\K\\{tmp\_funcsat\_ptr\_\_};{}$\6
\4${}\}{}$\2\5
\&{while} (\T{0}); \par
\As18, 26, 33, 100, 206, 228, 230, 231, 232\ETs243.
\U11.\fi

\N{2}{16}Top-level solver. This is the top-level solving loop. You should read
this. It's really short! it should stay that way. It should fit on a page. It
serves as a pretty easy-to-grasp example that can be referred to for writing a
custom search strategy using \funcsat\ components.

The main parameters of the solver allow configuring a wide range of search
behavior. Note how the loop runs until the solver ``runs out of resources.''
This allows one to use \funcsat\ to do cheap probing for properties, allowing
the solver to return ``unknown'' if it needs to. As another example,
\PB{\\{isTimeToRestart}} allows one to insert a custom restart strategy.

\Y\B\4\X16:Global definitions\X${}\E{}$\6
\&{funcsat\_result} \\{funcsatSolve}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\.{FS\_UNSAT}\E(\|f\MG\\{lastResult}\K\\{startSolving}(\|f))){}$\1\5
\&{goto} \\{Done};\2\6
\&{if} ${}(\R\\{bcpAndJail}(\|f)){}$\1\5
\&{goto} \\{Unsat};\2\6
\&{while} ${}(\R\|f\MG\\{conf}\MG\\{isResourceLimitHit}(\|f,\39\|f\MG\\{conf}%
\MG\\{user})){}$\5
${}\{{}$\1\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"solve"},\39\T{3}){}$\1\5
${}\\{fs\_print\_state}(\|f,\39\\{fs\_dbgout}(\|f));{}$\2\6
\&{if} ${}(\R\\{bcp}(\|f)){}$\5
${}\{{}$\1\6
\&{if} ${}(\T{0}\E\|f\MG\\{decisionLevel}){}$\1\5
\&{goto} \\{Unsat};\2\6
\&{if} ${}(\R\\{analyze\_conflict}(\|f)){}$\1\5
\&{goto} \\{Unsat};\2\6
\&{if} ${}(\|f\MG\\{conf}\MG\\{gc}){}$\1\5
${}\|f\MG\\{conf}\MG\\{sweepClauses}(\|f,\39\|f\MG\\{conf}\MG\\{user});{}$\2\6
\&{continue};\6
\4${}\}{}$\2\6
\&{if} ${}(\|f\MG\\{trail}.\\{size}\I\|f\MG\\{numVars}\W\|f\MG\\{conf}\MG%
\\{isTimeToRestart}(\|f,\39\|f\MG\\{conf}\MG\\{user})){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"solve"},\39\T{1},\39\.{"restarting\\n"});{}$\6
${}\PP\|f\MG\\{numRestarts};{}$\6
${}\\{backtrack}(\|f,\39\T{0},\39\NULL,\39\\{true});{}$\6
\&{continue};\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{funcsatMakeDecision}(\|f,\39\|f\MG\\{conf}\MG\\{user})){}$\5
${}\{{}$\1\6
${}\|f\MG\\{lastResult}\K\.{FS\_SAT};{}$\6
\&{goto} \\{Done};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4\\{Unsat}:\5
${}\|f\MG\\{lastResult}\K\.{FS\_UNSAT};{}$\6
\4\\{Done}:\5
${}\\{fslog}(\|f,\39\.{"solve"},\39\T{1},\39\.{"instance\ is\ \%s\\n"},\39%
\\{funcsatResultAsString}(\|f\MG\\{lastResult}));{}$\6
${}\\{assert}(\|f\MG\\{lastResult}\I\.{FS\_SAT}\V\|f\MG\\{trail}.\\{size}\E\|f%
\MG\\{numVars});{}$\6
\\{finishSolving}(\|f);\6
\&{return} \|f${}\MG\\{lastResult};{}$\6
\4${}\}{}$\2\par
\As19, 22, 23, 24, 27, 29, 30, 31, 34, 35, 36, 44, 45, 46, 48, 49, 54, 55, 56,
59, 62, 68, 69, 75, 77, 78, 86, 89, 90, 91, 93, 96, 99, 101, 102, 107, 108,
109, 111, 112, 114, 115, 118, 119, 120, 121, 123, 124, 125, 127, 133, 135, 138,
139, 142, 156, 157, 160, 164, 166, 173, 174, 175, 176, 177, 178, 182, 185, 189,
190, 191, 192, 203, 205, 207, 208, 209, 210, 212, 213, 229, 233, 237, 238, 239,
240, 242\ETs244.
\U14.\fi

\M{17}Some notes about the external API.

Funcsat returns results using the following datatype. The codes are the typical
codes used for \SAT\ solvers in the \SAT\ competition.

\Y\B\4\X13:External types\X${}\mathrel+\E{}$\6
\&{typedef} \&{enum} ${}\{{}$\1\6
${}\.{FS\_UNKNOWN}\K\T{0},\39\.{FS\_SAT}\K\T{10},\39\.{FS\_UNSAT}\K\T{20}{}$\2\6
${}\}{}$ \&{funcsat\_result};\par
\fi

\M{18}

\Y\B\4\X15:External declarations\X${}\mathrel+\E{}$\6
\&{void} \\{funcsatCheck}(\&{funcsat} ${}{*}\|f,\39{}$\&{funcsat\_result} \|r);%
\par
\fi

\M{19}

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{funcsatCheck}(\&{funcsat} ${}{*}\|f,\39{}$\&{funcsat\_result} \|r)%
\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\|r\E\|f\MG\\{lastResult});{}$\6
\&{if} ${}(\|r\E\.{FS\_SAT}){}$\5
${}\{{}$\1\6
\&{for\_vec\_uintptr} ${}(\\{ix\_cl},\39\|f\MG\\{orig\_clauses}){}$\5
${}\{{}$\1\6
\X20:Check that \PB{\\{ix\_cl}} is satisfied\X\6
\4${}\}{}$\2\6
\&{for\_vec\_uintptr} ${}(\\{ix\_cl},\39\|f\MG\\{learned\_clauses}){}$\5
${}\{{}$\1\6
\X20:Check that \PB{\\{ix\_cl}} is satisfied\X\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{20}
\Y\B\4\X20:Check that \PB{\\{ix\_cl}} is satisfied\X${}\E{}$\6
\&{struct} \\{clause\_iter} \\{it};\6
\&{bool} \\{sat}${}\K\\{false};{}$\7
${}\\{clause\_iter\_init}(\|f,\39{*}\\{ix\_cl},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
${}\\{assert}(\\{funcsatValue}(\|f,\39{*}\|p)\I\\{unknown});{}$\6
\&{if} ${}(\\{funcsatValue}(\|f,\39{*}\|p)\E\\{true}){}$\5
${}\{{}$\1\6
${}\\{sat}\K\\{true};{}$\6
\&{break};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\\{assert}(\\{sat});\par
\U19.\fi

\N{3}{21}Solver type. \funcsat\ has a bunch of members.

\Y\B\4\D$\\{Unassigned}$ \5
$({-}\T{1}{}$)\par
\Y\B\4\X21:Main \funcsat\ type\X${}\E{}$\6
\&{struct} \&{funcsat\_config};\6
\&{struct} \&{clause\_head};\6
\&{struct} \&{clause\_block};\6
\&{struct} \&{funcsat} ${}\{{}$\1\6
\&{struct} \&{funcsat\_config} ${}{*}\\{conf}{}$;\C{Added by SEAN!!!}\7
${}\&{uint8\_t}({*}\\{Backtrack\_hook}){}$(\&{uintptr\_t} ${}{*}\.{\_SM},\39{}$%
\&{uintmax\_t} \\{level});\6
${}\&{uint8\_t}({*}\\{BCP\_hook}){}$(\&{uintptr\_t} ${}{*}\.{\_SM},\39{}$%
\&{uintmax\_t} \\{nVariable}${},\39{}$\&{uint8\_t} \\{bPolarity});\6
${}\&{void}({*}\\{MakeDecision\_hook}){}$(\&{uintptr\_t} ${}{*}\.{\_SM});{}$\6
${}\&{intmax\_t}({*}\\{ExternalHeuristic\_hook}){}$(\&{uintptr\_t} ${}{*}\.{%
\_SM});{}$\7
\&{clause} \\{assumptions};\C{ assumptions as given by the user }\6
\&{funcsat\_result} \\{lastResult};\C{ result of the last incremental call  }\6
\&{uintmax\_t} \\{decisionLevel};\C{ current decision level }\6
\&{uintmax\_t} \\{propq};\C{ Unit propagation queue, which is an index into
                  \PB{\&{funcsat} $\MG$ \\{trail}}. The element pointed at by %
\PB{\\{propq}} is the                       first literal to propagate.  {\it
Invariant:} If \PB{\\{propq}}                       is \PB{\&{funcsat} $\MG$ $%
\\{trail}.\\{size}$}, then the queue is empty. }\6
\&{clause} \\{trail};\C{ Current (partial) assignment stack. }\6
\&{struct} \&{vec\_uintmax} \\{model};\C{ If a variable is assigned (see \PB{%
\&{funcsat} $\MG$ \\{level}}), contains                         the index of
the literal in the trail. \todo\ bitpack }\6
\&{clause} \\{phase};\C{ Stores the current, or last, phase of each variable
(for                    phase saving). }\6
\&{clause} \\{level};\C{ Records the decision level of each variable.  If a
variable                    is unset, its \PB{\\{level}} is \PB{%
\\{Unassigned}}. }\6
\&{struct} \&{vec\_uintmax} \\{decisions};\C{ For each decision variable, this
maps to its                             decision level. A non-decision variable
maps to                             0. }\6
\&{struct} \&{vec\_uintptr} ${}{*}\\{reason}{}$;\C{ Maps a variable to the
(index for the) \PB{\&{struct} \\{reason}}                          that became
unit to cause a variable assignment (see                          \PB{%
\&{funcsat} $\MG$ \\{reason\_infos}}). The reason is \PB{\.{NO\_CLS}} if
                  the variable is a decision variable. }\6
\&{struct} \&{vec\_ptr} \\{reason\_hooks};\C{ Indexed by types, returns a
function pointer that                         calculates a clause given a \PB{%
\&{funcsat}} and a                         \PB{\&{literal}}. }\6
\&{struct} \\{vec\_reason\_info} ${}{*}\\{reason\_infos}{}$;\C{ It is not safe
to take pointers of                                          these values
because this vector can be                                          realloc'd.
}\6
\&{uintptr\_t} \\{reason\_infos\_freelist};\C{ index of first free \PB{%
\\{reason\_info}} }\6
\&{head\_tail} ${}{*}\\{unit\_facts}{}$;\C{ Indexed by variable, each each \PB{%
\&{head\_tail}} list                              points to a linked list of
clauses. }\6
\&{uintmax\_t} \\{unit\_facts\_size};\6
\&{uintmax\_t} \\{unit\_facts\_capacity};\6
\&{head\_tail} ${}{*}\\{jail}{}$;\C{ Indexed by variable, each mapped to a \PB{%
\&{head\_tail}}                       list. Each list contains only clauses
currently satisfied                       by the associated variable. }\6
\&{all\_watches} \\{watches};\C{ Indexed from literals (using \PB{\\{fs%
\_lit2idx}}) into a                           \PB{\\{watcherlist}}. }\6
\&{struct} \&{vec\_uintptr} ${}{*}\\{orig\_clauses}{}$;\C{ A list of all the
original clauses. }\6
\&{struct} \&{vec\_uintptr} ${}{*}\\{learned\_clauses}{}$;\C{ A list of all the
learned clauses. }\6
\&{uintmax\_t} \\{numVars};\6
\&{struct} \\{clause\_head\_pool} \\{clheads};\6
\&{struct} \\{clause\_block\_pool} \\{clblocks};\6
\&{uintptr\_t} \\{conflict\_clause};\C{  When unit propagation discovers a
conflicting                                  clause, its index is stashed here.
}\6
\&{struct} \\{litpos} \\{litpos\_uip};\C{ used during conflict analysis }\6
\&{clause} \\{uipClause};\C{ Working area for the clause we will eventually
learn                      during conflict analysis. }\6
\&{struct} \&{vec\_ptr} \\{subsumed};\C{ list of subsumed clauses. used by
clause learning. }\6
\&{uintmax\_t} \\{LBD\_count};\C{ \LBD\ heuristic stuff -- see \PB{\\{LBD%
\_compute\_score}} }\6
\&{struct} \\{vec\_uint64} \\{LBD\_levels};\C{ \LBD\ heuristic stuff -- see %
\PB{\\{LBD\_compute\_score}} }\6
\&{struct} \\{vec\_uint64} \\{LBD\_histogram};\6
\&{uint64\_t} \\{LBD\_last\_num\_conflicts};\6
\&{uint64\_t} \\{LBD\_base};\6
\&{uint64\_t} \\{LBD\_increment};\6
\&{double} \\{claDecay};\C{ clause activities }\6
\&{double} \\{claInc};\6
\&{double} \\{learnedSizeFactor};\C{ when doing clause-activity based gc, this
is                                    the initial limit for learned clauses, a
                                  fraction of the original clauses (as in
                             minisat 2.2.0) }\6
\&{double} \\{maxLearned};\6
\&{double} \\{learnedSizeAdjustConfl};\6
\&{uint64\_t} \\{learnedSizeAdjustCnt};\6
\&{uint64\_t} \\{learnedSizeAdjustInc};\6
\&{double} \\{learnedSizeInc};\6
\&{struct} \&{vec\_uintmax} \\{seen};\C{ conflict clause minimisation stuff }\6
\&{struct} \&{vec\_intmax} \\{analyseToClear};\6
\&{struct} \&{vec\_uintmax} \\{analyseStack};\C{ dfs stack }\6
\&{struct} \&{vec\_uintmax} \\{allLevels};\C{ set of the levels-of-vars that
occur in the                                    clause }\6
\&{double} \\{varInc};\C{ dynamic variable order stuff }\6
\&{double} \\{varDecay};\6
\&{struct} \&{bh\_node} ${}{*}\\{binvar\_heap}{}$;\C{ binary heap of variables
}\6
\&{uintmax\_t} \\{binvar\_heap\_size};\C{ number of elements in \PB{\\{binvar%
\_heap}} }\6
\&{uintmax\_t} ${}{*}\\{binvar\_pos}{}$;\C{ locations of each var in the heap }%
\6
\&{int64\_t} \\{lrestart};\C{ luby restart stuff -- cribbed from \picosat }\6
\&{uint64\_t} \\{lubycnt};\6
\&{uint64\_t} \\{lubymaxdelta};\6
\&{bool} \\{waslubymaxdelta};\6
\&{struct} \\{drand48\_data} ${}{*}\\{rand};{}$\6
\&{uint64\_t} \\{numSolves};\C{ Number of calls to ::funcsatSolve }\6
\&{uint64\_t} \\{numLearnedClauses};\C{ How many learned clauses }\6
\&{uint64\_t} \\{numSweeps};\C{ How many times we deleted learned clauses }\6
\&{uint64\_t} \\{numLearnedDeleted};\C{ How many learned clauses we deleted }\6
\&{uint64\_t} \\{numLiteralsDeleted};\C{   How many literals deleted from
learned clauses as we simplify them }\6
\&{uint64\_t} \\{numProps};\C{ How many unit propagations }\6
\&{uint64\_t} \\{numUnitFactProps};\6
\&{uint64\_t} \\{numJails};\6
\&{uint64\_t} \\{numConflicts};\C{ How many conflicts }\6
\&{uint64\_t} \\{numResolutions};\6
\&{uint64\_t} \\{numRestarts};\C{ How many restarts }\6
\&{uint64\_t} \\{numDecisions};\C{ How many decisions }\6
\&{uint64\_t} \\{numSubsumptions};\C{   How many times a clause was simplified
due to self-subsuming resolution }\6
\&{uint64\_t} \\{numSubsumedOrigClauses};\C{   How many subsumption
simplifications were done for original clauses }\6
\&{uint64\_t} \\{numSubsumptionUips};\2\6
${}\}{}$;\par
\U12.\fi

\N{3}{22}Adding clauses. The main solver interface is just a few functions.


\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{funcsat\_result} \\{funcsatAddClause}(\&{funcsat} ${}{*}\|f,\39{}$\&{clause}
${}{*}\|c){}$\1\1\2\2\6
${}\{{}$\1\6
\&{variable} \\{maxVar}${}\K\T{0};{}$\6
\&{uintptr\_t} \\{ix\_cl};\6
\&{struct} \&{clause\_head} ${}{*}\\{cl};{}$\7
\\{funcsatReset}(\|f);\6
\&{if} ${}(\|c\MG\\{size}>\T{1}){}$\5
${}\{{}$\C{ a few trivial clause simplifications }\1\6
\&{uintmax\_t} \\{size}${}\K\|c\MG\\{size};{}$\6
\&{literal} ${}{*}\|i,{}$ ${}{*}\|j,{}$ ${}{*}\\{end};{}$\7
\\{sortClause}(\|c);\C{ i is current, j is target }\6
\&{for} ${}(\|i\K\|j\K{}$(\&{literal} ${}{*}){}$ \|c${}\MG\\{data},\39\\{end}\K%
\|i+\|c\MG\\{size};{}$ ${}\|i\I\\{end};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{literal} \|p${}\K{*}\|i,{}$ \|q${}\K{*}\|j;{}$\7
\&{if} ${}(\|i\I\|j){}$\5
${}\{{}$\1\6
\&{if} ${}(\|p\E\|q){}$\5
${}\{{}$\C{ duplicate literal }\1\6
${}\\{size}\MM;{}$\6
\&{continue};\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\|p\E{-}\|q){}$\5
${}\{{}$\C{ trivial clause }\1\6
\\{clauseDestroy}(\|c);\6
\&{goto} \\{Done};\6
\4${}\}{}$\2\6
\&{else}\1\5
${}{*}(\PP\|j)\K\|p;{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\|c\MG\\{size}\K\\{size};{}$\6
\4${}\}{}$\2\6
\&{for} (\&{variable} \|k${}\K\T{0};{}$ ${}\|k<\|c\MG\\{size};{}$ ${}\|k\PP){}$%
\5
${}\{{}$\1\6
\&{variable} \|v${}\K\\{fs\_lit2var}(\|c\MG\\{data}[\|k]);{}$\7
${}\\{maxVar}\K\|v>\\{maxVar}\?\|v:\\{maxVar};{}$\6
\4${}\}{}$\2\6
${}\\{funcsatResize}(\|f,\39\\{maxVar});{}$\6
${}\\{ix\_cl}\K\\{clause\_head\_alloc\_from\_clause}(\|f,\39\|c);{}$\6
${}\\{cl}\K\\{clause\_head\_ptr}(\|f,\39\\{ix\_cl});{}$\6
${}\\{cl}\MG\\{is\_learned}\K\\{false};{}$\6
${}\\{cl}\MG\\{is\_reason}\K\\{false};{}$\6
${}\\{cl}\MG\\{lbd\_score}\K\.{LBD\_SCORE\_MAX};{}$\6
${}\\{cl}\MG\\{activity}\K\T{0.\$F};{}$\6
${}\|f\MG\\{conf}\MG\\{bumpOriginal}(\|f,\39\\{ix\_cl});{}$\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"solve"},\39\T{2}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"solve"},\39\T{2},\39\.{"adding\ \%ju\ "},\39%
\\{funcsatNumClauses}(\|f)+\T{1});{}$\6
${}\\{fs\_clause\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39\|c);{}$\6
${}\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\\n"});{}$\6
\4${}\}{}$\2\7
\&{funcsat\_result} \\{clauseResult}${}\K\\{addClause}(\|f,\39\\{ix\_cl});{}$\7
\&{if} ${}(\|f\MG\\{lastResult}\I\.{FS\_UNSAT}){}$\5
${}\{{}$\1\6
${}\|f\MG\\{lastResult}\K\\{clauseResult};{}$\6
\4${}\}{}$\2\6
${}\\{vec\_uintptr\_push}(\|f\MG\\{orig\_clauses},\39\\{ix\_cl});{}$\6
\4\\{Done}:\5
\&{return} \|f${}\MG\\{lastResult};{}$\6
\4${}\}{}$\2\par
\fi

\M{23}When adding a clause we need to allocate an internal \PB{\&{clause%
\_head}} for
it. This function creates a new clause with exactly the same literals (in the
same order) as \PB{\|c}. It returns the new \PB{\&{clause\_head}}'s index.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{inline} \&{uintptr\_t} \\{clause\_head\_alloc\_from\_clause}(\&{funcsat}
${}{*}\|f,\39{}$\&{clause} ${}{*}\|c){}$\1\1\2\2\6
${}\{{}$\1\6
\&{uintmax\_t} \\{sz\_orig}${}\K\|c\MG\\{size};{}$\6
\&{uintptr\_t} \\{ix\_cl}${}\K\\{clause\_head\_mk}(\|f,\39\|c\MG\\{size});{}$\6
\&{struct} \&{clause\_head} ${}{*}\\{cl}\K\\{clause\_head\_ptr}(\|f,\39\\{ix%
\_cl});{}$\6
\&{intmax\_t} \\{sz\_copied}${}\K\T{0}{}$;\C{ use this index to keep the order
of \PB{\|c} }\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\.{CLAUSE\_HEAD\_SIZE}\W\\{sz%
\_copied}<\|c\MG\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\C{ copy head literals }\1\6
${}\\{cl}\MG\\{lits}[\|i]\K\|c\MG\\{data}[\\{sz\_copied}\PP];{}$\6
${}\\{cl}\MG\\{sz}\PP;{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{sz\_copied}<\|c\MG\\{size}){}$\5
${}\{{}$\C{ create first block }\1\6
\&{uintptr\_t} \\{ix\_bl}${}\K\\{clause\_block\_from\_clause}(\|f,\39\|c,\39%
\\{cl},\39{\AND}\\{sz\_copied});{}$\7
${}\\{cl}\MG\\{nx}\K\\{ix\_bl};{}$\6
\&{while} ${}(\\{sz\_copied}<\|c\MG\\{size}){}$\5
${}\{{}$\C{ create additional blocks }\1\6
\&{struct} \&{clause\_block} ${}{*}\\{bl};{}$\6
\&{uintptr\_t} \\{ix\_bl\_nx}${}\K\\{clause\_block\_from\_clause}(\|f,\39\|c,%
\39\\{cl},\39{\AND}\\{sz\_copied});{}$\7
${}\\{bl}\K\\{clause\_block\_ptr}(\|f,\39\\{ix\_bl});{}$\6
${}\\{bl}\MG\\{nx}\K\\{ix\_bl}\K\\{ix\_bl\_nx};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{assert}(\\{cl}\MG\\{sz}\E\\{sz\_orig});{}$\6
\&{return} \\{ix\_cl};\6
\4${}\}{}$\2\par
\fi

\M{24}Copies literals (up to \PB{\.{CLAUSE\_BLOCK\_SIZE}} of them) from \PB{%
\|c} beginning at
\PB{\\{sz\_copied}} into a fresh block, whose index is returned.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{uintptr\_t} \\{clause\_block\_from\_clause}(%
\&{funcsat} ${}{*}\|f,\39{}$\&{clause} ${}{*}\|c,\39{}$\&{struct} \&{clause%
\_head} ${}{*}\\{cl},\39{}$\&{intmax\_t} ${}{*}\\{sz\_copied}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{uintptr\_t} \\{ix\_bl}${}\K\\{clause\_block\_mk}(\|f);{}$\6
\&{struct} \&{clause\_block} ${}{*}\\{bl}\K\\{clause\_block\_ptr}(\|f,\39\\{ix%
\_bl});{}$\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\.{CLAUSE\_BLOCK\_SIZE}\W{*}\\{sz%
\_copied}<\|c\MG\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{bl}\MG\\{lits}[\|i]\K\|c\MG\\{data}[({*}\\{sz\_copied})\PP];{}$\6
${}\\{cl}\MG\\{sz}\PP;{}$\6
\4${}\}{}$\2\6
\&{return} \\{ix\_bl};\6
\4${}\}{}$\2\par
\fi

\M{25}
\Y\B\4\X25:Internal declarations\X${}\E{}$\6
\&{static} \&{inline} \&{uintptr\_t} \\{clause\_block\_from\_clause}(%
\&{funcsat} ${}{*}\|f,\39{}$\&{clause} ${}{*}\|c,\39{}$\&{struct} \&{clause%
\_head} ${}{*}\\{cl},\39{}$\&{intmax\_t} ${}{*}\\{ix\_clause}){}$;\par
\As28, 37, 43, 50, 57, 60, 61, 70, 71, 76, 79, 88, 92, 97, 110, 113, 116, 122,
126, 128, 134, 136, 145, 150, 159, 161, 162, 167, 171, 183, 204, 211, 214, 215,
227\ETs241.
\U12.\fi

\M{26}Prototype.
\Y\B\4\X15:External declarations\X${}\mathrel+\E{}$\6
\&{funcsat\_result}  \\{funcsatAddClause} (\&{funcsat} ${}{*}\\{func},\39$ %
\&{clause} ${}{*}{}$\1\1 \&{clause} )  ;\7
\&{extern} \&{uintptr\_t} \\{clause\_head\_alloc\_from\_clause}(\&{funcsat}
${}{*}\|f,\39{}$\&{clause} ${}{*}\|c){}$;\par
\fi

\M{27}Add the initialized internal clause to the watcher or unit fact lists.
This
may cause the solver to be in conflict.

Precondition: the decision level is 0.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{funcsat\_result} \\{addClause}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{uintptr\_t} \\{ix\_cl})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\\{ix%
\_cl});{}$\6
\&{funcsat\_result} \\{result}${}\K\.{FS\_UNKNOWN};{}$\7
${}\\{assert}(\|f\MG\\{decisionLevel}\E\T{0});{}$\6
${}\|h\MG\\{is\_learned}\K\\{false};{}$\6
\&{if} ${}(\|h\MG\\{sz}\E\T{0}){}$\5
${}\{{}$\1\6
${}\|f\MG\\{conflict\_clause}\K\\{ix\_cl};{}$\6
${}\\{result}\K\.{FS\_UNSAT};{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\|h\MG\\{sz}\E\T{1}){}$\5
${}\{{}$\1\6
\&{mbool} \\{val}${}\K\\{funcsatValue}(\|f,\39\|h\MG\\{lits}[\T{0}]);{}$\7
\&{if} ${}(\\{val}\E\\{false}){}$\5
${}\{{}$\1\6
${}\|f\MG\\{conflict\_clause}\K\\{ix\_cl};{}$\6
${}\\{result}\K\.{FS\_UNSAT};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\\{val}\E\\{unknown}){}$\5
${}\{{}$\1\6
${}\\{trailPush}(\|f,\39\|h\MG\\{lits}[\T{0}],\39\\{reason\_info\_mk}(\|f,\39%
\\{ix\_cl}));{}$\6
${}\\{head\_tail\_add}(\|f,\39{\AND}\|f\MG\\{unit\_facts}[\\{fs\_lit2var}(\|h%
\MG\\{lits}[\T{0}])],\39\\{ix\_cl});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{else}\1\5
${}\\{addWatch}(\|f,\39\\{ix\_cl});{}$\2\6
\&{return} \\{result};\6
\4${}\}{}$\2\par
\fi

\M{28}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{funcsat\_result} \\{addClause}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{uintptr\_t} \\{ix\_cl});\par
\fi

\N{3}{29}Unit assumptions. \funcsat\ supports solving under any number of unit
assumptions, like similar solvers such as \minisat\ and \picosat. But our
interface behaves a bit differently.

\numberedlist

\li \PB{$\\{funcsatPushAssumption}(\|f,\|x)$} adds a unit assumption \PB{\|x}.
This means that
every time \PB{\\{funcsatSolve}} is called from now on (unless you manipulate
the
assumptions again), all satisfying assignments must have \PB{\|x} set to true.
If the
solver returns \PB{\.{FS\_UNSAT}}, that means there exists no satisfying
assignment
where \PB{\|x} holds. It says {\it nothing} about satisfying assignments where %
\PB{${-}\|x$}
holds.

{\bf You must check the return value of \PB{\\{funcsatPushAssumption}}!} If it
ever
returns \PB{\.{FS\_UNSAT}}, it means the assumption was false and you should
take
appropriate action before solving.

\li \PB{\\{funcsatPopAssumption}} will remove the last unit assumption pushed
(call it
\PB{\|x}). All subsequent calls (unless you manipulate the assumptions again)
will
not be sensitive to any particular assignment to \PB{\|x}.

\li Therefore, assumptions are ordered in a LIFO stack.

\li Unlike \picosat, the solver \textit{never} implicitly removes assumptions
after a call to \PB{\\{funcsatSolve}}.

\endnumberedlist

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{funcsat\_result} \\{funcsatPushAssumption}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{literal} \|p)\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\|p\E\T{0}){}$\5
${}\{{}$\C{This is a hack to get the assumption stacks of bitfunc and funcsat
to be the same size}\1\6
${}\\{clausePush}({\AND}\|f\MG\\{assumptions},\39\T{0});{}$\6
\&{return} \.{FS\_UNKNOWN};\6
\4${}\}{}$\2\6
${}\|f\MG\\{conf}\MG\\{minimizeLearnedClauses}\K\\{false};{}$\6
${}\\{backtrack}(\|f,\39\T{0\$U\$L},\39\NULL,\39\\{true}){}$;\C{ in a weird
case, there are no clauses but some assumptions, so resize }\6
${}\\{funcsatResize}(\|f,\39\\{fs\_lit2var}(\|p));{}$\6
\&{if} ${}(\\{funcsatValue}(\|f,\39\|p)\E\\{false}){}$\5
${}\{{}$\1\6
\&{return} \.{FS\_UNSAT};\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{funcsatValue}(\|f,\39\|p)\E\\{unknown}){}$\5
${}\{{}$\C{ copy over assumptions that matter }\1\6
${}\\{clausePush}({\AND}\|f\MG\\{assumptions},\39\|p);{}$\6
${}\\{trailPush}(\|f,\39\|p,\39\.{NO\_CLS});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{clausePush}({\AND}\|f\MG\\{assumptions},\39\T{0});{}$\6
\4${}\}{}$\2\6
\&{return} \.{FS\_UNKNOWN};\6
\4${}\}{}$\2\7
\&{funcsat\_result} \\{funcsatPushAssumptions}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{clause} ${}{*}\|c){}$\1\1\2\2\6
${}\{{}$\1\6
\&{for} (\&{uintmax\_t} \|i${}\K\T{0};{}$ ${}\|i<\|c\MG\\{size};{}$ ${}\|i%
\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{funcsatPushAssumption}(\|f,\39\|c\MG\\{data}[\|i])\E\.{FS%
\_UNSAT}){}$\5
${}\{{}$\1\6
${}\\{funcsatPopAssumptions}(\|f,\39\|i);{}$\6
\&{return} \.{FS\_UNSAT};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{return} \.{FS\_UNKNOWN};\6
\4${}\}{}$\2\par
\fi

\M{30}

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{funcsatPopAssumptions}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintmax\_t} %
\\{num})\1\1\2\2\6
${}\{{}$\1\6
\&{head\_tail} \\{facts};\7
${}\\{head\_tail\_clear}({\AND}\\{facts});{}$\6
${}\\{assert}(\\{num}\Z\|f\MG\\{assumptions}.\\{size});{}$\6
${}\\{backtrack}(\|f,\39\T{0},\39\NULL,\39\\{true});{}$\6
\&{for} (\&{uintmax\_t} \|i${}\K\T{0};{}$ ${}\|i<\\{num};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{literal} \|p${}\K\\{clausePop}({\AND}\|f\MG\\{assumptions});{}$\7
\&{if} ${}(\|p\E\T{0}){}$\1\5
\&{return};\2\7
\&{literal} \|t${}\K\\{trailPop}(\|f,\39{\AND}\\{facts});{}$\7
\&{while} ${}(\|p\I\|t){}$\5
${}\{{}$\1\6
${}\|t\K\\{trailPop}(\|f,\39{\AND}\\{facts});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{restore\_facts}(\|f,\39{\AND}\\{facts});{}$\6
\4${}\}{}$\2\par
\fi

\M{31}At any point during solving, we can forcibly reset the solver state using
this
function. It does {\it not} remove any assumptions.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{funcsatReset}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
${}\|f\MG\\{conflict\_clause}\K\.{NO\_CLS};{}$\6
${}\\{backtrack}(\|f,\39\T{0\$U\$L},\39\NULL,\39\\{true});{}$\6
${}\|f\MG\\{propq}\K\T{0};{}$\6
${}\|f\MG\\{lastResult}\K\.{FS\_UNKNOWN};{}$\6
\4${}\}{}$\2\par
\fi

\N{2}{32}Clauses. \definexref{pg-clauses}{\folio}{page}Clauses, as the client
sees them, are represented thusly.

\Y\B\4\X13:External types\X${}\mathrel+\E{}$\6
\&{typedef} \&{struct} \&{clause} ${}\{{}$\1\6
\&{literal} ${}{*}\\{data};{}$\6
\&{uint32\_t} \\{size};\6
\&{uint32\_t} \\{capacity};\6
\&{uint32\_t} \\{isLearnt}:\T{1};\6
\&{uint32\_t} \\{isReason}:\T{1};\6
\&{uint32\_t} \\{is\_watched}:\T{1};\C{ in the watched literals for the first 2
literals of the clause }\6
\&{double} \\{activity};\6
\&{struct} \&{clause} ${}{*}\\{nx};{}$\2\6
${}\}{}$ \&{clause};\par
\fi

\M{33}Function prototypes for allocation, mutation, and deletion of clauses.

\Y\B\4\X15:External declarations\X${}\mathrel+\E{}$\6
\&{clause} ${}{*}{}$\\{clauseAlloc}(\&{uint32\_t} \\{capacity});\C{ creates
empty clause }\6
\&{void} \\{clauseInit}(\&{clause} ${}{*}\|v,\39{}$\&{uint32\_t} \\{capacity});%
\C{ initializes manually malloc'd clause }\6
\&{void} \\{clauseDestroy}(\&{clause} ${}{*}){}$;\C{   Frees the underlying
literal buffer and resets clause metadata. Does not free   the given pointer. }%
\6
\&{void} \\{clauseFree}(\&{clause} ${}{*}){}$;\C{ Calls \PB{\\{clauseDestroy}}
then frees the clause. }\6
\&{void} \\{clauseClear}(\&{clause} ${}{*}\|v){}$;\C{  Clear the contents of
the clause. Does not touch reference count or list  links. }\6
\&{void} \\{clausePush}(\&{clause} ${}{*}\|v,\39{}$\&{literal} \\{data});\C{
Allocates space (if necessary) for another literal; then appends the given
literal. }\6
\&{void} \\{clausePushAt}(\&{clause} ${}{*}\|v,\39{}$\&{literal} \\{data}${},%
\39{}$\&{uint32\_t} \|i);\6
\&{void} \\{clauseGrowTo}(\&{clause} ${}{*}\|v,\39{}$\&{uint32\_t} %
\\{newCapacity});\6
\&{literal} \\{clausePop}(\&{clause} ${}{*}\|v);{}$\6
\&{literal} \\{clausePopAt}(\&{clause} ${}{*}\|v,\39{}$\&{uint32\_t} \|i);\6
\&{literal} \\{clausePeek}(\&{clause} ${}{*}\|v);{}$\6
\&{void} \\{clauseCopy}(\&{clause} ${}{*}\\{dst},\39{}$\&{clause} ${}{*}%
\\{src}){}$;\C{  Copies all the literals and associated metadata, but the \PB{%
\\{dst}} reference count  is 1.  }\6
\8\#\&{define} $\\{forClause}(\\{elt},\39\\{vec})$ \&{for} ${}(\\{elt}\K(%
\\{vec})\MG\\{data};{}$ ${}\\{elt}\I(\\{vec})\MG\\{data}+(\\{vec})\MG%
\\{size};{}$ ${}\\{elt}\PP)$ \6
\8\#\&{define}\&{for\_clause} ${}(\\{elt},\39\\{cl}){}$\&{for} ${}(\\{elt}\K(%
\\{cl})\MG\\{data};{}$ ${}\\{elt}\I(\\{cl})\MG\\{data}+(\\{cl})\MG\\{size};{}$
${}\\{elt}\PP){}$\6
\8\#\&{define} $\\{for\_clause99}(\\{elt},\39\\{cl})$ \&{for} (\&{literal}
${}{*}\\{elt}\K(\\{cl})\MG\\{data};{}$ ${}\\{elt}\I(\\{cl})\MG\\{data}+(\\{cl})%
\MG\\{size};{}$ ${}\\{elt}\PP)$ \par
\fi

\M{34}
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{clauseInit}(\&{clause} ${}{*}\|v,\39{}$\&{uint32\_t} \\{capacity})%
\1\1\2\2\6
${}\{{}$\1\6
\&{uint32\_t} \|c${}\K\\{capacity}>\T{0}\?\\{capacity}:\T{4};{}$\7
${}\.{FS\_CALLOC}(\|v\MG\\{data},\39\|c,\39{}$\&{sizeof} ${}({*}\|v\MG%
\\{data}));{}$\6
${}\|v\MG\\{size}\K\T{0};{}$\6
${}\|v\MG\\{capacity}\K\|c;{}$\6
${}\|v\MG\\{isLearnt}\K\\{false};{}$\6
${}\|v\MG\\{nx}\K\NULL;{}$\6
${}\|v\MG\\{is\_watched}\K\\{false};{}$\6
${}\|v\MG\\{isReason}\K\\{false};{}$\6
${}\|v\MG\\{activity}\K\T{0.\$F};{}$\6
\4${}\}{}$\2\7
\&{void} \\{clauseFree}(\&{clause} ${}{*}\|v){}$\1\1\2\2\6
${}\{{}$\1\6
\\{clauseDestroy}(\|v);\6
\\{free}(\|v);\6
\4${}\}{}$\2\7
\&{void} \\{clauseDestroy}(\&{clause} ${}{*}\|v){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{free}(\|v\MG\\{data});{}$\6
${}\|v\MG\\{data}\K\NULL;{}$\6
${}\|v\MG\\{size}\K\T{0};{}$\6
${}\|v\MG\\{capacity}\K\T{0};{}$\6
${}\|v\MG\\{isLearnt}\K\\{false};{}$\6
\4${}\}{}$\2\7
\&{void} \\{clauseClear}(\&{clause} ${}{*}\|v){}$\1\1\2\2\6
${}\{{}$\1\6
${}\|v\MG\\{size}\K\T{0};{}$\6
${}\|v\MG\\{isLearnt}\K\\{false};{}$\6
\4${}\}{}$\2\7
\&{void} \\{clausePush}(\&{clause} ${}{*}\|v,\39{}$\&{literal} \\{data})\1\1\2%
\2\6
${}\{{}$\1\6
\&{if} ${}(\|v\MG\\{capacity}\Z\|v\MG\\{size}){}$\5
${}\{{}$\1\6
\&{while} ${}(\|v\MG\\{capacity}\Z\|v\MG\\{size}){}$\5
${}\{{}$\1\6
${}\|v\MG\\{capacity}\K\|v\MG\\{capacity}*\T{2}+\T{1};{}$\6
\4${}\}{}$\2\6
${}\.{FS\_REALLOC}(\|v\MG\\{data},\39\|v\MG\\{capacity},\39{}$\&{sizeof}
${}({*}\|v\MG\\{data}));{}$\6
\4${}\}{}$\2\6
${}\|v\MG\\{data}[\|v\MG\\{size}\PP]\K\\{data};{}$\6
\4${}\}{}$\2\7
\&{void} \\{clausePushAt}(\&{clause} ${}{*}\|v,\39{}$\&{literal} \\{data}${},%
\39{}$\&{uint32\_t} \|i)\1\1\2\2\6
${}\{{}$\1\6
\&{uint32\_t} \|j;\7
${}\\{assert}(\|i\Z\|v\MG\\{size});{}$\6
\&{if} ${}(\|v\MG\\{capacity}\Z\|v\MG\\{size}){}$\5
${}\{{}$\1\6
\&{while} ${}(\|v\MG\\{capacity}\Z\|v\MG\\{size}){}$\5
${}\{{}$\1\6
${}\|v\MG\\{capacity}\K\|v\MG\\{capacity}*\T{2}+\T{1};{}$\6
\4${}\}{}$\2\6
${}\.{FS\_REALLOC}(\|v\MG\\{data},\39\|v\MG\\{capacity},\39{}$\&{sizeof}
${}({*}\|v\MG\\{data}));{}$\6
\4${}\}{}$\2\6
${}\|v\MG\\{size}\PP;{}$\6
\&{for} ${}(\|j\K\|v\MG\\{size}-{}$(\&{uint32\_t}) \T{1}; ${}\|j>\|i;{}$ ${}\|j%
\MM){}$\5
${}\{{}$\1\6
${}\|v\MG\\{data}[\|j]\K\|v\MG\\{data}[\|j-\T{1}];{}$\6
\4${}\}{}$\2\6
${}\|v\MG\\{data}[\|i]\K\\{data};{}$\6
\4${}\}{}$\2\7
\&{void} \\{clauseGrowTo}(\&{clause} ${}{*}\|v,\39{}$\&{uint32\_t} %
\\{newCapacity})\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\|v\MG\\{capacity}<\\{newCapacity}){}$\5
${}\{{}$\1\6
${}\|v\MG\\{capacity}\K\\{newCapacity};{}$\6
${}\.{FS\_REALLOC}(\|v\MG\\{data},\39\|v\MG\\{capacity},\39{}$\&{sizeof}
${}({*}\|v\MG\\{data}));{}$\6
\4${}\}{}$\2\6
${}\\{assert}(\|v\MG\\{capacity}\G\\{newCapacity});{}$\6
\4${}\}{}$\2\7
\&{literal} \\{clausePop}(\&{clause} ${}{*}\|v){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\|v\MG\\{size}\I\T{0});{}$\6
\&{return} \|v${}\MG\\{data}[\|v\MG\\{size}\MM-\T{1}];{}$\6
\4${}\}{}$\2\7
\&{literal} \\{clausePopAt}(\&{clause} ${}{*}\|v,\39{}$\&{uint32\_t} \|i)\1\1\2%
\2\6
${}\{{}$\1\6
\&{uint32\_t} \|j;\7
${}\\{assert}(\|v\MG\\{size}\I\T{0});{}$\7
\&{literal} \\{res}${}\K\|v\MG\\{data}[\|i];{}$\7
\&{for} ${}(\|j\K\|i;{}$ ${}\|j<\|v\MG\\{size}-{}$(\&{uint32\_t}) \T{1}; ${}\|j%
\PP){}$\5
${}\{{}$\1\6
${}\|v\MG\\{data}[\|j]\K\|v\MG\\{data}[\|j+\T{1}];{}$\6
\4${}\}{}$\2\6
${}\|v\MG\\{size}\MM;{}$\6
\&{return} \\{res};\6
\4${}\}{}$\2\7
\&{literal} \\{clausePeek}(\&{clause} ${}{*}\|v){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\|v\MG\\{size}\I\T{0});{}$\6
\&{if} ${}(\|v\MG\\{size}\E\T{0}){}$\5
${}\{{}$\1\6
${}\|v\MG\\{size}\K\T{1};{}$\6
\&{return} \T{0};\6
\4${}\}{}$\2\6
\&{return} \|v${}\MG\\{data}[\|v\MG\\{size}-\T{1}];{}$\6
\4${}\}{}$\2\7
\&{void} \\{clauseSet}(\&{clause} ${}{*}\|v,\39{}$\&{uint32\_t} \|i${},\39{}$%
\&{literal} \|p)\1\1\2\2\6
${}\{{}$\1\6
${}\|v\MG\\{data}[\|i]\K\|p;{}$\6
\4${}\}{}$\2\7
\&{void} \\{clauseCopy}(\&{clause} ${}{*}\\{dst},\39{}$\&{clause} ${}{*}%
\\{src}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} \|i;\7
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\\{src}\MG\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{clausePush}(\\{dst},\39\\{src}\MG\\{data}[\|i]);{}$\6
\4${}\}{}$\2\6
${}\\{dst}\MG\\{isLearnt}\K\\{src}\MG\\{isLearnt};{}$\6
\4${}\}{}$\2\par
\fi

\M{35}
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{fs\_clause\_print}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE} ${}{*}%
\\{out},\39{}$\&{clause} ${}{*}\|c){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\R\\{out}){}$\1\5
${}\\{out}\K\\{stderr};{}$\2\7
\&{literal} ${}{*}\|p;{}$\7
\&{for\_clause} ${}(\|p,\39\|c){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"\%ji\_\%ji\%s\ "},\39{*}\|p,\39\\{levelOf}(\|f,%
\39\\{fs\_lit2var}({*}\|p)),\39(\\{funcsatValue}(\|f,\39{*}\|p)\E\\{true}\?%
\.{"T"}:(\\{funcsatValue}(\|f,\39{*}\|p)\E\\{false}\?\.{"F"}:\.{"U"})));{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{36}Print \PB{\&{clause}}.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{dimacsPrintClause}(\&{FILE} ${}{*}\\{out},\39{}$\&{clause} ${}{*}%
\|c){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} ${}{*}\|p;{}$\7
\&{if} ${}(\R\\{out}){}$\1\5
${}\\{out}\K\\{stderr};{}$\2\6
\&{for\_clause} ${}(\|p,\39\|c){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"\%ji\ "},\39{*}\|p);{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{out},\39\.{"0"});{}$\6
\4${}\}{}$\2\par
\fi

\M{37}

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{void} \\{fs\_clause\_print}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE} ${}{*}%
\\{out},\39{}$\&{clause} ${}{*}\|c);{}$\6
\&{void} \\{dimacsPrintClause}(\&{FILE} ${}{*}\\{out},\39{}$\&{clause} ${}{*}%
\|c){}$;\par
\fi

\N{3}{38}Internal clauses.

\numberedlist

\li Clause heads will be separate from the ``rest'' of the clause. In fact, all
clauses will be chunked into head and body parts. There is one head and various
body parts. Each clause is referred to by a single index, a \PB{\&{uintptr%
\_t}}. See the
macros \PB{\\{clause\_head\_ptr}} and \PB{\\{clause\_block\_ptr}}.

\li The activity and the score need to be unified. First of all, the \LBD\
score
has way too many bits. After about \osf{5} bits of information all the \LBD s
blend together. The activity is slightly murkier because it's a float. Either I
need to (\osf{1}) create custom float operations packed into 28 bits or
(\osf{2}) using the int and make the activity recording work anyway. Not sure
at
the moment how to do either but I know \picosat\ does (\osf{1}). (Can I get
away
with fixed-point floats?)

\endnumberedlist

So here's the new \PB{\&{clause\_head}} data structure. The \PB{\\{lits}} is %
\PB{\.{CLAUSE\_HEAD\_SIZE}}
literals. \PB{\\{nx}} is an index it's an index into \PB{$\|f\MG\\{clblocks}$}.

The \PB{\&{clause\_block}} is similar. If the clause terminates in this block,
then
\PB{\\{nx}} is \PB{\.{NO\_CLS}}. If there is a spot for it, the literal after
the last
literal in the clause is a 0. If there isn't a spot for it, then \PB{\\{lits}}
just has
all the literals.

Each clause block will be allocated from the huge array, \PB{$\|f\MG%
\\{clblocks}$}. When due
to simplification or garbage collection a clause block is released, it is put
back onto the freelist of clause blocks. \PB{$\|f\MG\\{block\_freelist}$} is
the index of the
first free \PB{\&{clause\_block}} in the freelist.

\Y\B\4\X38:Internal types\X${}\E{}$\6
\8\#\&{ifndef} \.{CLAUSE\_HEAD\_SIZE}\6
\8\#\&{define} \.{CLAUSE\_HEAD\_SIZE} \5\T{7}\C{ odd because of \PB{\&{clause%
\_head} $\MG$ \\{nx}} }\6
\8\#\&{endif}\6
\8\#\&{ifndef} \.{CLAUSE\_BLOCK\_SIZE}\6
\8\#\&{define} \.{CLAUSE\_BLOCK\_SIZE} \5\T{7}\C{ odd because of \PB{\&{clause%
\_block} $\MG$ \\{nx}} }\6
\8\#\&{endif}\6
\&{enum} \&{clause\_state} ${}\{{}$\1\6
${}\.{CLAUSE\_WATCHED}\K\T{1},{}$\C{ in watchlist }\6
\.{CLAUSE\_JAILED}${},{}$\C{ in jail }\6
\.{CLAUSE\_UNIT}\C{ in unit facts, don't GC }\2\6
${}\};{}$\6
\8\#\&{define} \.{NO\_CLS} \5\.{UINTPTR\_MAX}\6
\8\#\&{define} \.{LBD\_SCORE\_MAX} \5\T{\^3f}\6
\&{struct} \&{clause\_head} ${}\{{}$\1\6
\&{literal} \\{lits}[\.{CLAUSE\_HEAD\_SIZE}];\C{ first few literals }\6
\&{uintptr\_t} \\{nx};\C{ index of first block, or \PB{\.{NO\_CLS}} if none }\6
\&{uintptr\_t} \\{link};\C{ used by \PB{\&{head\_tail}} lists. \PB{\.{NO\_CLS}}
initially }\6
\&{uint32\_t} \\{is\_learned}:\T{1};\6
\&{uint32\_t} \\{is\_reason}:\T{1};\C{ pinned, don't GC }\6
\&{uint32\_t} \\{where}:\T{2};\C{ see \PB{\&{clause\_state}} }\6
\&{uint32\_t} \\{lbd\_score}:\T{6};\C{ also \PB{\.{LBD\_SCORE\_MAX}} }\6
\&{uint32\_t} \\{sz}:\T{22};\C{ max num lits is 2**22 }\6
\&{float} \\{activity};\2\6
${}\};{}$\6
\8\#\&{include} \.{"funcsat/vec\_clause\_}\)\.{head.h"}\6
\&{struct} \&{clause\_block} ${}\{{}$\1\6
\&{literal} \\{lits}[\.{CLAUSE\_BLOCK\_SIZE}];\6
\&{uintptr\_t} \\{nx};\C{ index of next block, or \PB{\.{NO\_CLS}} if none }\2\6
${}\};{}$\6
\8\#\&{include} \.{"funcsat/vec\_clause\_}\)\.{block.h"}\par
\As39, 47, 53, 64, 65, 67, 95, 117\ETs172.
\U12.\fi

\M{39}In the \PB{\&{funcsat}} type we need to store a vector of clause
heads/blocks along
with a freelist pointer.

\Y\B\4\X38:Internal types\X${}\mathrel+\E{}$\6
\&{struct} \&{clause\_head\_pool} ${}\{{}$\1\6
\&{uintptr\_t} \\{freelist};\6
\&{struct} \\{vec\_clause\_head} ${}{*}\\{heads};{}$\2\6
${}\};{}$\6
\&{struct} \&{clause\_block\_pool} ${}\{{}$\1\6
\&{uintptr\_t} \\{freelist};\6
\&{struct} \\{vec\_clause\_block} ${}{*}\\{blocks};{}$\2\6
${}\}{}$;\par
\fi

\M{40}What is the lifecycle of a clause? And why should you care? If the
lifecycle
is in one place, it's easy to figure out whether later clause modifications
will
efficiently support the needed operations.

\unorderedlist

\li While the client is constructing the CNF instance (or it's being read from
disk), the clause is being built and eventually is given to \PB{%
\\{funcsatAddClause}}.

\orderedlist

\li If the clause is empty, the solver becomes immediately conflicted.

\li If the clause is singleton, we put it on the trail and attach it as a {\it
unit fact} to the newly-added trail literal.

\li If it's binary, it's put in the binary watcher list and it will never be
garbage collected.

\li Otherwise, it's put in the normal watchlist for the clause.

\endorderedlist

\li Once all the clauses are added the search begins. At this point a clause
can
become the {\it reason} for an inference. This means the clause was unit at the
time it implied a literal.

\li During backtracking a clause (especially learned) may transition to a unit
fact list which is eventually associated with a particular literal on the
trail. It may stay on a unit fact list across other decisions, inferences, and
backtracks. (But not across restarts unless it's a singleton.)

\li During \BCP\ a clause can be {\it jailed}, meaning it's removed from its
watchlists and put into a shadow watchlist while it's satisfied. It is restored
to the watchlists once it becomes unsatisfied. (It does {\it not} go through
any
unit fact list.)

\li A literal could be completely deleted from a clause if a literal in the
clause becomes true at decision level 0.


\endunorderedlist

When a garbage collection is triggered, the clause could be in any of these
states. Assuming the clause is not pinned, it is returned to the clause pool. A
clause is {\it pinned} when any of the following hold:

\unorderedlist

\li The clause is in a unit fact list.
\li The clause is currently the {\it reason} for an inference.
\li The clause is binary (we keep them all around).

\endunorderedlist

\fi

\M{41}Initialize the pools for heads and blocks.

\Y\B\4\D$\.{INITIAL\_CLAUSE\_POOL}$ \5
\T{1024}\par
\Y\B\4\X41:Initialize funcsat type\X${}\E{}$\6
$\|f\MG\\{clheads}.\\{freelist}\K\.{NO\_CLS};{}$\6
${}\|f\MG\\{clheads}.\\{heads}\K\\{vec\_clause\_head\_init}(\.{INITIAL\_CLAUSE%
\_POOL});{}$\6
${}\|f\MG\\{clblocks}.\\{freelist}\K\.{NO\_CLS};{}$\6
${}\|f\MG\\{clblocks}.\\{blocks}\K\\{vec\_clause\_block\_init}(\.{INITIAL%
\_CLAUSE\_POOL});{}$\6
\&{for} (\&{uintptr\_t} \|i${}\K\T{0};{}$ ${}\|i<\.{INITIAL\_CLAUSE\_POOL};{}$
${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{clause\_head\_release}(\|f,\39\|i);{}$\6
${}\\{clause\_block\_release}(\|f,\39\|i);{}$\6
\4${}\}{}$\2\par
\As51, 98, 103, 129, 137, 152, 168, 179, 186, 193\ETs201.
\U217.\fi

\M{42}Free the pools.

\Y\B\4\X42:Destroy funcsat type\X${}\E{}$\6
$\\{vec\_clause\_head\_destroy}(\|f\MG\\{clheads}.\\{heads});{}$\6
${}\\{vec\_clause\_block\_destroy}(\|f\MG\\{clblocks}.\\{blocks});{}$\6
${}\|f\MG\\{clheads}.\\{freelist}\K\.{NO\_CLS};{}$\6
${}\|f\MG\\{clheads}.\\{freelist}\K\.{NO\_CLS}{}$;\par
\As52, 74, 106, 130, 155, 170, 181, 188\ETs202.
\U220.\fi

\M{43}Retrieving new clauses. The \PB{\\{capacity}} of the vec is how many
blocks are
initially available; if we need to allocate more, we simply allocate more
memory. The \PB{\\{size}} field is ignored.

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{struct} \&{clause\_head} ${}{*}{}$\\{clause\_head%
\_ptr}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} \|i)\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}(\\{assert}((\|i)<(\|f)\MG\\{clheads}.\\{heads}\MG\\{capacity}),%
\39(\|f)\MG\\{clheads}.\\{heads}\MG\\{data}+(\|i));{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{struct} \&{clause\_block} ${}{*}{}$\\{clause\_block%
\_ptr}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} \|i)\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}(\\{assert}((\|i)<(\|f)\MG\\{clblocks}.\\{blocks}\MG%
\\{capacity}),\39(\|f)\MG\\{clblocks}.\\{blocks}\MG\\{data}+(\|i));{}$\6
\4${}\}{}$\2\par
\fi

\M{44}To allocate a clause head we find the first head in the freelist,
allocating
new space if necessary. In the fast case, when there is a free head available,
this operation takes constant time. In the slow case we allocate a bunch of new
heads and put them into the freelist.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{uintptr\_t} \\{clause\_head\_mk}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{uint32\_t} \\{sz\_hint})\1\1\2\2\6
${}\{{}$\1\6
\&{const} \&{uintptr\_t} \\{cap}${}\K\|f\MG\\{clheads}.\\{heads}\MG%
\\{capacity};{}$\6
\&{uintptr\_t} \\{freelist}${}\K\|f\MG\\{clheads}.\\{freelist};{}$\7
\&{if} ${}(\\{freelist}\G\\{cap}){}$\5
${}\{{}$\C{ resize if necessary }\1\6
${}\\{vec\_clause\_head\_grow\_to}(\|f\MG\\{clheads}.\\{heads},\39\\{cap}*%
\T{2});{}$\6
\&{for} (\&{uintptr\_t} \|i${}\K\\{cap};{}$ ${}\|i<\|f\MG\\{clheads}.\\{heads}%
\MG\\{capacity};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{clause\_head\_release}(\|f,\39\|i);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39%
\\{freelist}\K\|f\MG\\{clheads}.\\{freelist});{}$\7
${}\|f\MG\\{clheads}.\\{freelist}\K\|h\MG\\{nx}{}$;\C{ use \PB{$\|h\MG\\{nx}$}
before we clobber it }\6
${}\\{memset}(\|h,\39\T{0},\39{}$\&{sizeof} ${}({*}\|h));{}$\6
${}\|h\MG\\{nx}\K\|h\MG\\{link}\K\.{NO\_CLS};{}$\6
\&{return} \\{freelist};\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{uintptr\_t} \\{clause\_block\_mk}(\&{funcsat} ${}{*}%
\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{const} \&{uintptr\_t} \\{cap}${}\K\|f\MG\\{clblocks}.\\{blocks}\MG%
\\{capacity};{}$\6
\&{uintptr\_t} \\{freelist}${}\K\|f\MG\\{clblocks}.\\{freelist};{}$\7
\&{if} ${}(\\{freelist}\G\\{cap}){}$\5
${}\{{}$\C{ resize if necessary }\1\6
${}\\{vec\_clause\_block\_grow\_to}(\|f\MG\\{clblocks}.\\{blocks},\39\\{cap}*%
\T{2});{}$\6
\&{for} (\&{uintptr\_t} \|i${}\K\\{cap};{}$ ${}\|i<\|f\MG\\{clblocks}.%
\\{blocks}\MG\\{capacity};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{clause\_block\_release}(\|f,\39\|i);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{struct} \&{clause\_block} ${}{*}\|h\K\\{clause\_block\_ptr}(\|f,\39%
\\{freelist}\K\|f\MG\\{clblocks}.\\{freelist});{}$\7
${}\|f\MG\\{clblocks}.\\{freelist}\K\|h\MG\\{nx}{}$;\C{ use \PB{$\|h\MG\\{nx}$}
before we clobber it }\6
${}\\{memset}(\|h,\39\T{0},\39{}$\&{sizeof} ${}({*}\|h));{}$\6
${}\|h\MG\\{nx}\K\.{NO\_CLS};{}$\6
\&{return} \\{freelist};\6
\4${}\}{}$\2\par
\fi

\M{45}Return the clause to the pool.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{clause\_head\_release}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\\{ix}<\|f\MG\\{clheads}.\\{heads}\MG\\{capacity});{}$\7
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\\{ix});{}$%
\7
${}\\{assert}(\\{memset}(\|h,\39\T{0},\39{}$\&{sizeof}(\&{struct} \&{clause%
\_head})));\6
${}\|h\MG\\{nx}\K\|f\MG\\{clheads}.\\{freelist},\39\|f\MG\\{clheads}.%
\\{freelist}\K\\{ix};{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{void} \\{clause\_block\_release}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\\{ix}<\|f\MG\\{clblocks}.\\{blocks}\MG\\{capacity});{}$\7
\&{struct} \&{clause\_block} ${}{*}\|h\K\\{clause\_block\_ptr}(\|f,\39%
\\{ix});{}$\7
${}\\{assert}(\\{memset}(\|h,\39\T{0},\39{}$\&{sizeof}(\&{struct} \&{clause%
\_block})));\6
${}\|h\MG\\{nx}\K\|f\MG\\{clblocks}.\\{freelist},\39\|f\MG\\{clblocks}.%
\\{freelist}\K\\{ix};{}$\6
\4${}\}{}$\2\par
\fi

\M{46}To return a complete clause, blocks and everything, to the pool.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{clause\_release}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\\{ix});{}$%
\6
\&{struct} \&{clause\_block} ${}{*}\|b;{}$\6
\&{uintptr\_t} \\{nx}${}\K\|h\MG\\{nx};{}$\7
${}\\{clause\_head\_release}(\|f,\39\\{ix});{}$\6
\&{while} ${}(\\{nx}\I\.{NO\_CLS}){}$\5
${}\{{}$\1\6
\&{uintptr\_t} \\{nx\_nx}${}\K\\{clause\_block\_ptr}(\|f,\39\\{nx})\MG%
\\{nx};{}$\7
${}\\{clause\_block\_release}(\|f,\39\\{nx});{}$\6
${}\\{nx}\K\\{nx\_nx};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{47}Iterating over clauses. The iterator type is somewhat complex,
unfortunately.

\Y\B\4\X38:Internal types\X${}\mathrel+\E{}$\6
\&{struct} \&{clause\_iter} ${}\{{}$\1\6
\&{int16\_t} \\{l\_ix};\C{ can be tiny because it only indexes into a block at
a time }\6
\&{bool} \\{is\_head};\6
\&{uint32\_t} \\{sz};\6
\&{union} ${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|h;{}$\6
\&{struct} \&{clause\_block} ${}{*}\|b;{}$\2\6
${}\};{}$\2\6
${}\}{}$;\par
\fi

\M{48}Steps for iterating:

\unorderedlist

\li \PB{$\\{clause\_iter\_init}(\|f,\|i,\\{it})$}: initialize an iterator \PB{%
\\{it}}. You must call
\PB{\\{clause\_iter\_next}} to get the next element.

\li \PB{\\{clause\_iter\_next}}: if it returns a non-\PB{$\NULL$} pointer, then
it points to a
\PB{\&{literal}}.
\endunorderedlist

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{clause\_iter\_init}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} %
\\{ix\_clause\_head}${},\39{}$\&{struct} \&{clause\_iter} ${}{*}\\{it}){}$\1\1%
\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\\{ix%
\_clause\_head});{}$\7
${}\\{it}\MG\\{l\_ix}\K{-}\T{1};{}$\6
${}\\{it}\MG\\{is\_head}\K\\{true};{}$\6
${}\\{it}\MG\|h\K\|h;{}$\6
${}\\{it}\MG\\{sz}\K\|h\MG\\{sz};{}$\6
\4${}\}{}$\2\6
\8\#\&{define} ${}\\{clause\_iter\_lit\_ptr}(\|f,\39\\{it}) \5((\\{it})\MG\\{is%
\_head}\?(\\{it})\MG\|h\MG\\{lits}+(\\{it})\MG\\{l\_ix}:(\\{it})\MG\|b\MG%
\\{lits}+(\\{it})\MG\\{l\_ix}){}$\7
\&{literal} ${}{*}{}$\\{clause\_iter\_next}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{struct} \&{clause\_iter} ${}{*}\\{it}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} ${}{*}\\{lit}\K\NULL;{}$\7
\&{if} ${}(\\{it}\MG\\{sz}\E\T{0}){}$\1\5
\&{return} ${}\NULL;{}$\2\6
${}\PP\\{it}\MG\\{l\_ix};{}$\6
\&{if} ${}(\\{it}\MG\\{is\_head}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{it}\MG\\{l\_ix}\G\.{CLAUSE\_HEAD\_SIZE}){}$\5
${}\{{}$\C{ go to first block }\1\6
${}\\{assert}(\\{it}\MG\|h\MG\\{nx}\I\.{NO\_CLS});{}$\6
${}\\{it}\MG\\{is\_head}\K\\{false};{}$\6
${}\\{it}\MG\|b\K\\{clause\_block\_ptr}(\|f,\39\\{it}\MG\|h\MG\\{nx});{}$\6
${}\\{it}\MG\\{l\_ix}\K\T{0};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\\{it}\MG\\{l\_ix}\G\.{CLAUSE\_BLOCK\_SIZE}){}$\5
${}\{{}$\C{ go to next block }\1\6
${}\\{assert}(\\{it}\MG\|b\MG\\{nx}\I\.{NO\_CLS});{}$\6
${}\\{it}\MG\|b\K\\{clause\_block\_ptr}(\|f,\39\\{it}\MG\|b\MG\\{nx});{}$\6
${}\\{it}\MG\\{l\_ix}\K\T{0};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{lit}\K\\{clause\_iter\_lit\_ptr}(\|f,\39\\{it});{}$\6
${}\\{it}\MG\\{sz}\MM;{}$\6
\&{return} \\{lit};\6
\4${}\}{}$\2\par
\fi

\M{49}Make printing convenient.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{fs\_clause\_head\_print}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE}
${}{*}\\{out},\39{}$\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\R\\{out}){}$\1\5
${}\\{out}\K\\{stderr};{}$\2\7
\&{struct} \&{clause\_iter} \\{it};\7
${}\\{clause\_iter\_init}(\|f,\39\\{ix},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"\%ji\_\%ji\%s\ "},\39{*}\|p,\39\\{levelOf}(\|f,%
\39\\{fs\_lit2var}({*}\|p)),\39(\\{funcsatValue}(\|f,\39{*}\|p)\E\\{true}\?%
\.{"T"}:(\\{funcsatValue}(\|f,\39{*}\|p)\E\\{false}\?\.{"F"}:\.{"U"})));{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{void} \\{clause\_head\_print\_dimacs}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE}
${}{*}\\{out},\39{}$\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_iter} \\{it};\7
\&{if} ${}(\R\\{out}){}$\1\5
${}\\{out}\K\\{stderr};{}$\2\6
\&{if} ${}(\\{ix}\E\.{NO\_CLS}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"(NULL\ CLAUSE)"});{}$\6
\&{return};\6
\4${}\}{}$\2\6
${}\\{clause\_iter\_init}(\|f,\39\\{ix},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"\%ji\ "},\39{*}\|p);{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{out},\39\.{"0"});{}$\6
\4${}\}{}$\2\7
\&{void} \\{vec\_clause\_head\_print\_dimacs}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{FILE} ${}{*}\\{stream},\39{}$\&{struct} \&{vec\_uintptr} ${}{*}%
\\{clauses}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{for\_vec\_uintptr} ${}(\\{ix},\39\\{clauses}){}$\5
${}\{{}$\1\6
${}\\{clause\_head\_print\_dimacs}(\|f,\39\\{stream},\39{*}\\{ix});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{50}Prototypes.

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{uintptr\_t} \\{clause\_head\_mk}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{uint32\_t} \\{sz\_hint});\6
\&{static} \&{inline} \&{uintptr\_t} \\{clause\_block\_mk}(\&{funcsat} ${}{*}%
\|f);{}$\6
\&{static} \&{inline} \&{void} \\{clause\_head\_release}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{uintptr\_t} \\{ix});\6
\&{static} \&{inline} \&{void} \\{clause\_block\_release}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{uintptr\_t} \\{ix});\6
\&{static} \&{inline} \&{void} \\{clause\_releas}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{uintptr\_t} \\{ix});\6
\&{void} \\{clause\_iter\_init}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} %
\\{ix\_clause\_head}${},\39{}$\&{struct} \&{clause\_iter} ${}{*}\\{it});{}$\6
\&{literal} ${}{*}{}$\\{clause\_iter\_next}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{struct} \&{clause\_iter} ${}{*}\\{it});{}$\6
\&{void} \\{fs\_clause\_head\_print}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE}
${}{*}\\{out},\39{}$\&{uintptr\_t} \\{ix});\6
\&{void} \\{clause\_head\_print\_dimacs}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE}
${}{*}\\{out},\39\&{uintptr\_t});{}$\6
\&{void} \\{vec\_clause\_head\_print\_dimacs}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{FILE} ${}{*}\\{out},\39{}$\&{struct} \&{vec\_uintptr} ${}{*}){}$;\par
\fi

\M{51}
\Y\B\4\X41:Initialize funcsat type\X${}\mathrel+\E{}$\6
$\|f\MG\\{orig\_clauses}\K\\{vec\_uintptr\_init}(\T{2});{}$\6
${}\|f\MG\\{learned\_clauses}\K\\{vec\_uintptr\_init}(\T{2}){}$;\par
\fi

\M{52}Destroy
\Y\B\4\X42:Destroy funcsat type\X${}\mathrel+\E{}$\6
$\\{vec\_uintptr\_destroy}(\|f\MG\\{orig\_clauses});{}$\6
${}\\{vec\_uintptr\_destroy}(\|f\MG\\{learned\_clauses}){}$;\par
\fi

\N{3}{53}Head-tail lists. Sometimes we use a head-tail representation for lists
of
clauses. The \PB{\&{head\_tail}} structure points at the initial clause and the
last
clause. The clauses in between the head and the tail are found by walking each
\PB{\&{clause} $\MG$ \\{nx}} pointer. Using these scheme we can append two such
lists in
constant time.

\Y\B\4\X38:Internal types\X${}\mathrel+\E{}$\6
\&{typedef} \&{struct} \&{head\_tail} ${}\{{}$\1\6
\&{uintptr\_t} \\{hd};\C{ \PB{\.{NO\_CLS}} used if empty }\6
\&{uintptr\_t} \\{tl};\2\6
${}\}{}$ \&{head\_tail};\par
\fi

\M{54}Clearing and testing for emptiness should be clear (ha!) enough.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{head\_tail\_clear}(\&{head\_tail} ${}{*}%
\\{ht}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{ht}\MG\\{hd}\K\\{ht}\MG\\{tl}\K\.{NO\_CLS};{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{bool} \\{head\_tail\_is\_empty}(\&{head\_tail} ${}{*}%
\\{ht}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{ht}${}\MG\\{hd}\E\.{NO\_CLS}\W\\{ht}\MG\\{tl}\E\.{NO\_CLS};{}$\6
\4${}\}{}$\2\par
\fi

\M{55}The result will be stored in \PB{\\{ht1}}. If we think of \PB{\\{ht1}} as
a list
$x_1\rightarrow\cdots\rightarrow x_m$ and \PB{\\{ht2}} as a list
$y_1\rightarrow\cdots\rightarrow y_n$ then we want to make \PB{\\{ht1}} the
list
$x_1\rightarrow\cdots\rightarrow x_m\rightarrow y_1\rightarrow\cdots\rightarrow
y_n$ in that order.

The complication is that either or both lists may be empty. But we need to:
\unorderedlist

\li If $m>0$, adjust $x_m$'s \PB{\\{link}} to be $y_1$. (If $n=0$, this will
simply
reinforce that $x_m$\PB{$\MG$ \\{link}} is \PB{\.{NO\_CLS}}.)

\li If $n>0$, adjust \PB{\\{ht1}}'s \PB{\\{tl}} to be $y_n$. (And if \PB{%
\\{ht1}} is empty we make
sure to make it start at $y_1$.

\endunorderedlist
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{head\_tail\_append}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{head\_tail} ${}{*}\\{ht1},\39{}$\&{head\_tail} ${}{*}\\{ht2}){}$\1\1\2%
\2\6
${}\{{}$\1\6
\&{if} ${}(\\{ht1}\MG\\{tl}\I\.{NO\_CLS}){}$\1\5
${}\\{clause\_head\_ptr}(\|f,\39\\{ht1}\MG\\{tl})\MG\\{link}\K\\{ht2}\MG%
\\{hd};{}$\2\6
\&{if} ${}(\\{ht2}\MG\\{tl}\I\.{NO\_CLS}){}$\5
${}\{{}$\1\6
${}\\{ht1}\MG\\{tl}\K\\{ht2}\MG\\{tl};{}$\6
\&{if} ${}(\\{ht1}\MG\\{hd}\E\.{NO\_CLS}){}$\1\5
${}\\{ht1}\MG\\{hd}\K\\{ht2}\MG\\{hd};{}$\2\6
\4${}\}{}$\2\6
\\{head\_tail\_clear}(\\{ht2});\6
\8\#\&{if} \T{0}\6
\&{if} ${}(\R\\{head\_tail\_is\_empty}(\\{ht2})){}$\5
${}\{{}$\1\6
\&{if} (\\{head\_tail\_is\_empty}(\\{ht1}))\5
${}\{{}$\1\6
${}\\{ht1}\MG\\{hd}\K\\{ht2}\MG\\{hd};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\\{cl\_tl}\K\\{clause\_head\_ptr}(\|f,\39%
\\{ht1}\MG\\{tl});{}$\7
${}\\{assert}(\\{ht1}\MG\\{hd}\I\.{NO\_CLS});{}$\6
${}\\{assert}(\\{cl\_tl}\MG\\{link}\E\.{NO\_CLS});{}$\6
${}\\{cl\_tl}\MG\\{link}\K\\{ht2}\MG\\{hd};{}$\6
\4${}\}{}$\2\6
${}\\{ht1}\MG\\{tl}\K\\{ht2}\MG\\{tl};{}$\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
\4${}\}{}$\2\par
\fi

\M{56}Adding a single clause to the list is a special case of \PB{\\{head\_tail%
\_append}}.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{head\_tail\_add}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{head\_tail} ${}{*}\\{ht1},\39{}$\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{head\_tail} \\{ht2};\7
${}\\{ht2}.\\{hd}\K\\{ht2}.\\{tl}\K\\{ix};{}$\6
${}\\{head\_tail\_append}(\|f,\39\\{ht1},\39{\AND}\\{ht2});{}$\6
\8\#\&{if} \T{0}\7
\&{struct} \&{clause\_head} ${}{*}\|c\K\\{clause\_head\_ptr}(\|f,\39\\{ix});{}$%
\7
${}\|c\MG\\{link}\K\\{ht1}\MG\\{hd};{}$\6
${}\\{ht1}\MG\\{hd}\K\\{ix};{}$\6
\&{if} ${}(\\{ht1}\MG\\{tl}\E\.{NO\_CLS}){}$\5
${}\{{}$\1\6
${}\\{ht1}\MG\\{tl}\K\\{ix};{}$\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
\4${}\}{}$\2\par
\fi

\M{57}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{head\_tail\_clear}(\&{head\_tail} ${}{*}%
\\{ht});{}$\6
\&{static} \&{inline} \&{bool} \\{head\_tail\_is\_empty}(\&{head\_tail} ${}{*}%
\\{ht});{}$\6
\&{static} \&{inline} \&{void} \\{head\_tail\_append}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{head\_tail} ${}{*}\\{ht1},\39{}$\&{head\_tail} ${}{*}\\{ht2});{}$\6
\&{static} \&{inline} \&{void} \\{head\_tail\_add}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{head\_tail} ${}{*}\\{ht1},\39\&{uintptr\_t}){}$;\par
\fi

\M{58}Iterating over a \PB{\&{head\_tail}} list is slightly tricky. The common
case is
iterating and doing something to each element, without removing it. That's
pretty easy.

But often we want to preserve some elements in the list and delete others,
while
we iterate. That's what \PB{\\{head\_tail\_iter\_rm}} is for. It deletes the %
\PB{\\{curr}}
element from the list and sets \PB{$\\{curr}\MG\\{nx}$} to \PB{$\NULL$}. The
iterator can therefore
detect that \PB{\\{curr}} has been deleted (by testing its link field) and not
update
the \PB{\\{prev}} pointer when that happens.

\Y\B\4\D$\&{for\_head\_tail}(\|f,\\{ht},\\{prev},\\{curr},\\{next})$ \C{
iterate over all the clauses in the list }\6
\&{for} ${}(\\{prev}\K\\{next}\K\.{NO\_CLS},\39\\{curr}\K(\\{ht})\MG\\{hd},%
\39((\\{curr}\I\.{NO\_CLS})\?\\{next}\K\\{clause\_head\_ptr}(\|f,\39(\\{curr}))%
\MG\\{link}:\T{0}){}$;\6
${}(\\{curr}\I\.{NO\_CLS}){}$;\6
${}(\\{clause\_head\_ptr}(\|f,\39(\\{curr}))\MG\\{link}\I\.{NO\_CLS}\?\\{prev}%
\K(\\{curr}):\T{0}),\39\\{curr}\K(\\{next}),\39((\\{curr}\I\.{NO\_CLS})\?%
\\{next}\K\\{clause\_head\_ptr}(\|f,\39(\\{curr}))\MG\\{link}:\T{0}){}$)\par
\B\4\D$\\{head\_tail\_iter\_rm}(\|f,\\{ht},\\{prev},\\{curr},\\{next})$ \C{
delete \PB{\\{curr}} from iteration }\6
\&{if} ${}((\\{ht})\MG\\{hd}\E(\\{curr})){}$\5
${}\{{}$\C{ fix up \PB{\\{hd}} and \PB{\\{tl}} fields }\1\6
${}(\\{ht})\MG\\{hd}\K(\\{next});{}$\6
\4${}\}{}$\2\6
\&{if} ${}((\\{ht})\MG\\{tl}\E(\\{curr})){}$\5
${}\{{}$\1\6
${}(\\{ht})\MG\\{tl}\K(\\{prev});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{prev}\I\.{NO\_CLS}){}$\5
${}\{{}$\1\6
${}\\{clause\_head\_ptr}(\|f,\39(\\{prev}))\MG\\{link}\K(\\{next});{}$\6
\4${}\}{}$\2\6
${}\\{clause\_head\_ptr}(\|f,\39(\\{curr}))\MG\\{link}\K\.{NO\_CLS}{}$;\par
\Y\B\par
\fi

\M{59}

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{inline} \&{void} \\{head\_tail\_print}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE}
${}{*}\\{out},\39{}$\&{head\_tail} ${}{*}\|l){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\R\\{out}){}$\1\5
${}\\{out}\K\\{stderr};{}$\2\6
\&{if} ${}(\|l\MG\\{hd}){}$\5
${}\{{}$\1\6
\&{uintptr\_t} \|p${},{}$ \|c${},{}$ \\{nx};\7
\&{for\_head\_tail} ${}(\|f,\39\|l,\39\|p,\39\|c,\39\\{nx}){}$\5
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\|c);{}$\7
\&{if} ${}(\|h\MG\\{link}\E\.{NO\_CLS}\W\|l\MG\\{tl}\I\|c){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"warning:\ tl\ is\ not\ }\)\.{last\ clause%
\\n"});{}$\6
\4${}\}{}$\2\6
${}\\{fs\_clause\_head\_print}(\|f,\39\\{out},\39\|c);{}$\6
${}\\{fprintf}(\\{out},\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\|l\MG\\{tl}\I\.{NO\_CLS}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"warning:\ hd\ unset\ b}\)\.{ut\ tl\ set!%
\\n"});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{60}

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{extern} \&{void} \\{head\_tail\_print}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE}
${}{*}\\{out},\39{}$\&{head\_tail} ${}{*}\|l){}$;\par
\fi

\N{2}{61}BCP. How does \funcsat's \BCP\ work? Here's the signature.

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{bool} \\{bcp}(\&{funcsat} ${}{*}\|f){}$;\par
\fi

\M{62}First, there's this notion of a {\it propagation queue} (\PB{\&{funcsat}
$\MG$ \\{propq}}). It
is an index into the trail. It is the index of the earliest literal on the
trail
that should be examined by \BCP. \BCP\ examines each literal, beginning with
the
first in the propagation queue, until there are no more inferences or it finds
a
conflict.

If we discover a conflict, \PB{\\{bcp}} returns \PB{\\{false}} and sets
\PB{\&{funcsat} $\MG$ \\{conflictClause}} to the clause that is false.
Otherwise it returns
\PB{\\{true}}.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{bool} \\{bcp}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{bool} \\{isConsistent}${}\K\\{true};{}$\7
\&{while} ${}(\|f\MG\\{propq}<\|f\MG\\{trail}.\\{size}){}$\5
${}\{{}$\1\6
\X80:\BCP\ clauses\X\6
\&{if} ${}(\|f\MG\\{BCP\_hook}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|f\MG\\{BCP\_hook}{}$((\&{uintptr\_t} ${}{*}){}$ \|f${}\MG\\{conf}%
\MG\\{user},\39\\{imaxabs}(\|p),\39\|p>\T{0})\E\.{FS\_UNSAT}){}$\5
${}\{{}$\1\6
${}\\{isConsistent}\K\\{false};{}$\6
\&{goto} \\{bcp\_conflict};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4\\{bcp\_conflict}:\5
\&{return} \\{isConsistent};\6
\4${}\}{}$\2\par
\fi

\M{63}We put learned clauses in our normal watchlists. Each clause knows
whether
it's learned or not.

\numberedlist

\li Con: when garbage collection is done, the learned watchlists are entirely
recreated. This is easiest because the GC can sort all the clauses by score,
delete the worst half, and recreate the watchlists. How could this be resolved?

\numberedlist

\li Can I add some information to the clauses themselves and GC them during
\BCP? (This might be bad because it might make \BCP\ slow. But let's have some
faith in branch prediction on processors, shall we?)

\li At first, I'll ignore cleaning learned clauses. Next, I'll do a special
walk over the whole watcher list and clean out certain of the learned
clauses. Next, I'll think of some queue-of-craptastry in order to drop clauses
more dynamically and in a fine-grained way.

\endnumberedlist

\li Pro: every single watched literal operation does not have to be duplicated
for the original and learned lists, in the other representation. This is
annoying.

\endnumberedlist

\fi

\M{64}Here we are using a representation inspired by the ``Cache-conscious
SAT''
paper.

The watched literal structure is indexed by literals. At each index is stored a
\PB{\&{watchlist}}, which points to a number of \PB{\&{watchlist\_elt}}s. The
meaning of a
\PB{\&{watchlist\_elt}} differs depending on the clause:

\numberedlist

\li For large clauses: a literal from the clause (\PB{\\{lit}}), clause index
(\PB{\\{cls}}). (This is different from the paper. I can't figure out how they
managed to keep the {\it first} literal in the \PB{\&{watchlist\_elt}} at all
times!)

\li For binary clauses: the other literal (\PB{\\{lit}}), clause index
(\PB{\\{cls}}). (This situation is different from the paper; there the clause
index was unused. We need it because we always store a clause index to each
clauses that is a {\it reason} for an inference.)

\endnumberedlist

\Y\B\4\X38:Internal types\X${}\mathrel+\E{}$\6
\&{struct} \&{watchlist\_elt} ${}\{{}$\1\6
\&{literal} \\{lit};\6
\&{uintptr\_t} \\{cls};\2\6
${}\}{}$;\par
\fi

\M{65}Here's the \PB{\&{watchlist}}, which represents the list of clauses
associated with a
single watched literal. Each \PB{\&{watchlist}} stores a small number of
clauses in its
head, because often the watch lists are small. If the watch list is small, we
don't need to fetch anything else from memory in order to propagate this watch
list.

I chose a size of 12 for \PB{\.{WATCHLIST\_HEAD\_SIZE\_MAX}} because I felt
like it. And
because it was in the paper.

\Y\B\4\X38:Internal types\X${}\mathrel+\E{}$\6
\8\#\&{ifndef} \.{WATCHLIST\_HEAD\_SIZE\_MAX}\6
\8\#\&{define} \.{WATCHLIST\_HEAD\_SIZE\_MAX} \5\T{4}\6
\8\#\&{endif}\6
\&{struct} \&{watchlist} ${}\{{}$\1\6
\&{uint32\_t} \\{size};\C{ of \PB{\&{watchlist} $\MG$ \\{elts} ${+}%
\&{watchlist}$ $\MG$ \\{rest}} }\6
\&{uint32\_t} \\{capacity};\C{ of \PB{\&{watchlist} $\MG$ \\{rest}} }\6
\&{struct} \&{watchlist\_elt} \\{elts}[\.{WATCHLIST\_HEAD\_SIZE\_MAX}];\6
\&{struct} \&{watchlist\_elt} ${}{*}\\{rest};{}$\2\6
${}\}{}$;\par
\fi

\M{66}Traversing the watchlists. Using these macros makes the \PB{\\{bcp}} code
a bit
cleaner.

\Y\B\4\D$\\{watchlist\_next\_elt}(\\{elt},\\{wl})$ \5
$((\\{elt})+\T{1}\E(\\{wl})\MG\\{elts}+\.{WATCHLIST\_HEAD\_SIZE\_MAX}\?\\{elt}%
\K(\\{wl})\MG\\{rest}:(\\{elt})\PP{}$)\par
\B\4\D$\&{for\_watchlist}(\\{elt},\\{dump},\\{wl})$ \C{ \PB{\\{elt}} ptr has to
transition from head list to rest }\6
\&{for} ${}(\\{elt}\K\\{dump}\K(\\{wl})\MG\\{elts};{}$ ${}(\\{watchlist\_is%
\_elt\_in\_head}(\\{elt},\39(\\{wl}))\?\\{elt}<\\{watchlist\_head\_size\_ptr}(%
\\{wl}):\\{elt}<\\{watchlist\_rest\_size\_ptr}(\\{wl}));{}$ ${}\\{watchlist%
\_next\_elt}(\\{elt},\39(\\{wl})){}$)\par
\fi

\M{67}The \PB{\&{all\_watches}} is the vector of all the watcher lists for
every literal.

\Y\B\4\X38:Internal types\X${}\mathrel+\E{}$\6
\&{typedef} \&{struct} \&{all\_watches} ${}\{{}$\1\6
\&{struct} \&{watchlist} ${}{*}\\{wlist}{}$;\C{ indexed by \PB{\\{fs\_lit2idx}(%
\|i)} }\6
\&{uintmax\_t} \\{size};\6
\&{uintmax\_t} \\{capacity};\2\6
${}\}{}$ \&{all\_watches};\par
\fi

\M{68}Initializing.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{all\_watches\_init}(\&{funcsat} ${}{*}\|f){}$%
\1\1\2\2\6
${}\{{}$\1\6
${}\.{FS\_CALLOC}(\|f\MG\\{watches}.\\{wlist},\39\T{1}\LL\T{7},\39{}$\&{sizeof}
${}({*}\|f\MG\\{watches}.\\{wlist}));{}$\6
${}\|f\MG\\{watches}.\\{size}\K\T{2};{}$\6
${}\|f\MG\\{watches}.\\{capacity}\K\T{1}\LL\T{7};{}$\6
\4${}\}{}$\2\par
\fi

\M{69}

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{all\_watches\_destroy}(\&{funcsat} ${}{*}%
\|f){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{free}(\|f\MG\\{watches}.\\{wlist});{}$\6
\4${}\}{}$\2\par
\fi

\M{70}These used to be macros, but then GDB on OS X wouldn't let me call them
no
matter how many funny {\tt -g} options I passed to gcc. So I made them
functions.

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{bool} \\{watchlist\_is\_elt\_in\_head}(\&{struct} %
\&{watchlist\_elt} ${}{*}\\{elt},\39{}$\&{struct} \&{watchlist} ${}{*}%
\\{wl}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}(\\{elt}\G\\{wl}\MG\\{elts}\W\\{elt}<(\\{wl})\MG\\{elts}+%
\.{WATCHLIST\_HEAD\_SIZE\_MAX});{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{uint32\_t} \\{watchlist\_head\_size}(\&{struct} %
\&{watchlist} ${}{*}\\{wl}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}((\\{wl})\MG\\{size}>\.{WATCHLIST\_HEAD\_SIZE\_MAX}\?\.{WATCHLIST%
\_HEAD\_SIZE\_MAX}:(\\{wl})\MG\\{size});{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{struct} \&{watchlist\_elt} ${}{*}{}$\\{watchlist\_head%
\_size\_ptr}(\&{struct} \&{watchlist} ${}{*}\\{wl}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}((\\{wl})\MG\\{elts}+\\{watchlist\_head\_size}(\\{wl}));{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{uint32\_t} \\{watchlist\_rest\_size}(\&{struct} %
\&{watchlist} ${}{*}\\{wl}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}((\\{wl})\MG\\{size}>\.{WATCHLIST\_HEAD\_SIZE\_MAX}\?(\\{wl})\MG%
\\{size}-\.{WATCHLIST\_HEAD\_SIZE\_MAX}:\T{0});{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{struct} \&{watchlist\_elt} ${}{*}{}$\\{watchlist\_rest%
\_size\_ptr}(\&{struct} \&{watchlist} ${}{*}\\{wl}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}((\\{wl})\MG\\{rest}+\\{watchlist\_rest\_size}(\\{wl}));{}$\6
\4${}\}{}$\2\par
\fi

\M{71}

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{all\_watches\_init}(\&{funcsat} ${}{*}%
\|f);{}$\6
\&{static} \&{inline} \&{void} \\{all\_watches\_destroy}(\&{funcsat} ${}{*}%
\|f){}$;\par
\fi

\M{72}

\Y\B\4\X72:Incrementally resize internal data structures up to new \PB{%
\\{numVars}}\X${}\E{}$\6
\&{if} ${}(\|f\MG\\{watches}.\\{capacity}\Z\|f\MG\\{watches}.\\{size}+\T{2}){}$%
\5
${}\{{}$\1\6
\&{while} ${}(\|f\MG\\{watches}.\\{capacity}\Z\|f\MG\\{watches}.\\{size}){}$\5
${}\{{}$\1\6
${}\|f\MG\\{watches}.\\{capacity}\K\|f\MG\\{watches}.\\{capacity}*\T{2}+%
\T{2};{}$\6
\4${}\}{}$\2\6
${}\.{FS\_REALLOC}(\|f\MG\\{watches}.\\{wlist},\39\|f\MG\\{watches}.%
\\{capacity},\39{}$\&{sizeof} ${}({*}\|f\MG\\{watches}.\\{wlist}));{}$\6
\4${}\}{}$\2\6
\X73:Initialize wlist bucket at \PB{$\|f\MG\\{watches}.\\{size}$}\X\6
${}\|f\MG\\{watches}.\\{size}\PP;{}$\6
\X73:Initialize wlist bucket at \PB{$\|f\MG\\{watches}.\\{size}$}\X\6
${}\|f\MG\\{watches}.\\{size}\PP;{}$\6
${}\\{assert}(\|f\MG\\{watches}.\\{size}\Z\|f\MG\\{watches}.\\{capacity}){}$;%
\par
\As105, 132, 153, 169, 180\ETs187.
\U219.\fi

\M{73}

\Y\B\4\X73:Initialize wlist bucket at \PB{$\|f\MG\\{watches}.\\{size}$}\X${}%
\E{}$\6
$\|f\MG\\{watches}.\\{wlist}[\|f\MG\\{watches}.\\{size}].\\{size}\K\T{0};{}$\6
${}\|f\MG\\{watches}.\\{wlist}[\|f\MG\\{watches}.\\{size}].\\{capacity}\K%
\T{0};{}$\6
\&{for} (\&{uint32\_t} \|i${}\K\T{0};{}$ ${}\|i<\.{WATCHLIST\_HEAD\_SIZE%
\_MAX};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\|f\MG\\{watches}.\\{wlist}[\|f\MG\\{watches}.\\{size}].\\{elts}[\|i].%
\\{lit}\K\T{0};{}$\6
${}\|f\MG\\{watches}.\\{wlist}[\|f\MG\\{watches}.\\{size}].\\{elts}[\|i].%
\\{cls}\K\.{NO\_CLS};{}$\6
\4${}\}{}$\2\6
${}\|f\MG\\{watches}.\\{wlist}[\|f\MG\\{watches}.\\{size}].\\{rest}\K\NULL;{}$\6
${}\\{assert}(\T{0}\E\\{watchlist\_head\_size}({\AND}\|f\MG\\{watches}.%
\\{wlist}[\|f\MG\\{watches}.\\{size}]));{}$\6
${}\\{assert}(\T{0}\E\\{watchlist\_rest\_size}({\AND}\|f\MG\\{watches}.%
\\{wlist}[\|f\MG\\{watches}.\\{size}])){}$;\par
\U72.\fi

\M{74}Destroy the watcher lists.

\Y\B\4\X42:Destroy funcsat type\X${}\mathrel+\E{}$\6
\&{for} (\&{variable} \|i${}\K\T{1};{}$ ${}\|i\Z\|f\MG\\{numVars};{}$ ${}\|i%
\PP){}$\5
${}\{{}$\1\6
${}\\{free}(\|f\MG\\{watches}.\\{wlist}{}$[\\{fs\_lit2idx}((\&{literal}) %
\|i)]${}.\\{rest});{}$\6
${}\\{free}(\|f\MG\\{watches}.\\{wlist}[\\{fs\_lit2idx}({-}{}$(\&{literal}) %
\|i)]${}.\\{rest});{}$\6
\4${}\}{}$\2\6
${}\\{free}(\|f\MG\\{watches}.\\{wlist}){}$;\par
\fi

\M{75}
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{int} \\{compare\_pointer}(\&{const} \&{void} ${}{*}\|x,\39{}$%
\&{const} \&{void} ${}{*}\|y){}$\1\1\2\2\6
${}\{{}$\1\6
\&{uintptr\_t} \\{xp}${}\K{}$(\&{uintptr\_t}) ${}{*}{}$(\&{clause}
${}{*}{*}){}$ \|x;\6
\&{uintptr\_t} \\{yp}${}\K{}$(\&{uintptr\_t}) ${}{*}{}$(\&{clause}
${}{*}{*}){}$ \|y;\7
\&{if} ${}(\\{xp}<\\{yp}){}$\1\5
\&{return} ${}{-}\T{1};{}$\2\6
\&{else} \&{if} ${}(\\{xp}>\\{yp}){}$\1\5
\&{return} \T{1};\2\6
\&{else}\1\5
\&{return} \T{0};\2\6
\4${}\}{}$\2\par
\fi

\M{76}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{int} \\{compare\_pointer}(\&{const} \&{void} ${}{*}\|x,\39{}$%
\&{const} \&{void} ${}{*}\|y){}$;\par
\fi

\M{77}The watchlist invariants can be checked with this function.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{watchlist\_check}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{literal} \|l)\1\1\2\2\6
${}\{{}$\1\6
\&{literal} \\{false\_lit}${}\K{-}\|l;{}$\6
\&{struct} \&{watchlist} ${}{*}\\{wl}\K{\AND}\|f\MG\\{watches}.\\{wlist}[\\{fs%
\_lit2idx}(\|l)];{}$\6
\&{struct} \&{watchlist\_elt} ${}{*}\\{elt},{}$ ${}{*}\\{dump};{}$\6
\&{struct} \&{vec\_ptr} ${}{*}\\{clauses}\K\\{vec\_ptr\_init}(\\{wl}\MG%
\\{size});{}$\7
\&{for\_watchlist} ${}(\\{elt},\39\\{dump},\39\\{wl}){}$\5
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|c\K\\{clause\_head\_ptr}(\|f,\39\\{elt}\MG%
\\{cls});{}$\6
\&{literal} ${}{*}\\{chkl};{}$\6
\&{bool} \\{chk\_in\_cls}${}\K\\{false};{}$\6
\&{struct} \&{clause\_iter} \\{it};\7
${}\\{vec\_ptr\_push}(\\{clauses},\39\|c);{}$\6
${}\\{clause\_iter\_init}(\|f,\39\\{elt}\MG\\{cls},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\C{ ensure \PB{$\\{elt}\MG\\{lit}$} is in \PB{\|c} }\1\6
\&{if} ${}({*}\|p\E\\{elt}\MG\\{lit}){}$\5
${}\{{}$\1\6
${}\\{chk\_in\_cls}\K\\{true};{}$\6
\&{break};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{assert}(\\{chk\_in\_cls}\W\.{"watched\ lit\ not\ in\ }\)\.{clause"});{}$\6
${}\\{assert}((\|c\MG\\{lits}[\T{0}]\E\\{false\_lit}\V\|c\MG\\{lits}[\T{1}]\E%
\\{false\_lit})\W\.{"watched\ lit\ not\ in\ }\)\.{first\ 2"});{}$\7
\&{uint32\_t} \\{num\_not\_false}${}\K\T{0}{}$;\C{ not-false literals are
``safe'' to watch }\7
${}\\{clause\_iter\_init}(\|f,\39\\{elt}\MG\\{cls},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{tentativeValue}(\|f,\39{*}\|p)\I\\{false}){}$\5
${}\{{}$\1\6
${}\\{num\_not\_false}\PP;{}$\6
\&{if} ${}(\\{funcsatValue}(\|f,\39{*}\|p)\E\\{true}){}$\5
${}\{{}$\1\6
${}\\{num\_not\_false}\K\T{0};{}$\6
\&{break};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{num\_not\_false}\G\T{1}){}$\5
${}\{{}$\C{ ensure we're watching ``safe'' literals }\1\6
${}\\{assert}((\\{tentativeValue}(\|f,\39\|c\MG\\{lits}[\T{0}])\I\\{false}\V%
\\{tentativeValue}(\|f,\39\|c\MG\\{lits}[\T{1}])\I\\{false})\W\.{"watching\ bad%
\ litera}\)\.{ls"});{}$\6
\&{if} ${}(\\{num\_not\_false}\G\T{2}){}$\5
${}\{{}$\1\6
${}\\{assert}(\\{tentativeValue}(\|f,\39\|c\MG\\{lits}[\T{0}])\I\\{false}\W%
\\{tentativeValue}(\|f,\39\|c\MG\\{lits}[\T{1}])\I\\{false}\W\.{"watching\ bad\
litera}\)\.{ls"});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{qsort}(\\{clauses}\MG\\{data},\39\\{clauses}\MG\\{size},\39{}$\&{sizeof}(%
\&{struct} \&{clause\_head} ${}{*}),\39\\{compare\_pointer});{}$\6
\&{for} (\&{uintmax\_t} \|i${}\K\T{0},\39\|j\K\T{1};{}$ ${}\|j<\\{clauses}\MG%
\\{size};{}$ ${}\|i\PP,\39\|j\PP){}$\5
${}\{{}$\C{ find duplicate clauses }\1\6
${}\\{assert}(\\{clauses}\MG\\{data}[\|i]\I\\{clauses}\MG\\{data}[\|j]\W%
\.{"duplicate\ clause"});{}$\6
\4${}\}{}$\2\6
\\{vec\_ptr\_destroy}(\\{clauses});\6
\4${}\}{}$\2\par
\fi

\M{78}We can check all the watchlists at once.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{watches\_check}(\&{funcsat} ${}{*}\|f){}$\1\1%
\2\2\6
${}\{{}$\1\6
\&{for} (\&{variable} \|v${}\K\T{1};{}$ ${}\|v\Z\|f\MG\\{numVars};{}$ ${}\|v%
\PP){}$\5
${}\{{}$\1\6
\&{literal} \\{pos}${}\K{}$(\&{literal}) \|v;\6
\&{literal} \\{neg}${}\K{-}{}$(\&{literal}) \|v;\7
${}\\{watchlist\_check}(\|f,\39\\{pos});{}$\6
${}\\{watchlist\_check}(\|f,\39\\{neg});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{79}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{watchlist\_check}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{literal} \|l);\6
\&{static} \&{inline} \&{void} \\{watches\_check}(\&{funcsat} ${}{*}\|f){}$;\par
\fi

\M{80}With all this machinery we can now handle discovering unit inferences and
propagating them.

\Y\B\4\X80:\BCP\ clauses\X${}\E{}$\6
\&{literal} \|p${}\K\|f\MG\\{trail}.\\{data}[\|f\MG\\{propq}];{}$\6
\8\#\&{ifndef} \.{NDEBUG}\7
${}\\{watchlist\_check}(\|f,\39\|p);{}$\6
\8\#\&{endif}\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"bcp"},\39\T{3}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{3},\39\.{"bcp\ on\ \%ji\\n"},\39\|p);{}$\6
\4${}\}{}$\2\7
\&{const} \&{literal} \\{false\_lit}${}\K{-}\|p;{}$\6
\&{struct} \&{watchlist} ${}{*}\\{wl}\K{\AND}\|f\MG\\{watches}.\\{wlist}[\\{fs%
\_lit2idx}(\|p)];{}$\6
\&{struct} \&{watchlist\_elt} ${}{*}\\{elt},{}$ ${}{*}\\{dump};{}$\6
\&{uint32\_t} \\{new\_size}${}\K\T{0};{}$\7
${}\PP\|f\MG\\{numProps};{}$\6
${}\\{dopen}(\|f,\39\.{"bcp"});{}$\6
\&{for\_watchlist} ${}(\\{elt},\39\\{dump},\39\\{wl}){}$\5
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|c\K\\{clause\_head\_ptr}(\|f,\39\\{elt}\MG%
\\{cls});{}$\6
\&{literal} \\{otherlit};\C{ the other watched lit in \PB{\|c} }\6
\&{mbool} \\{litval};\7
\&{fs\_ifdbg} ${}(\|f,\39\.{"bcp"},\39\T{9}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{9},\39\.{"visit\ "});{}$\6
${}\\{fs\_clause\_head\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39\\{elt}\MG%
\\{cls});{}$\6
${}\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\ \%"}\\{PRIuPTR}\.{"\\n"},\39\\{elt}%
\MG\\{cls});{}$\6
\4${}\}{}$\2\6
${}\\{assert}((\\{false\_lit}\E\|c\MG\\{lits}[\T{0}]\V\\{false\_lit}\E\|c\MG%
\\{lits}[\T{1}]));{}$\6
${}\\{assert}((\|c\MG\\{link}\E\.{NO\_CLS}));{}$\6
\X81:Check \PB{$\\{elt}\MG\\{lit}$} for quick SAT clause\X\6
\X82:Ensure false literal is in \PB{$\|c\MG\\{lits}[\T{1}]$}\X\6
${}\\{otherlit}\K\|c\MG\\{lits}[\T{0}];{}$\6
\X83:Look for new, unfalsified literal to watch, removing \PB{\\{elt}} if found%
\X\6
${}\\{litval}\K\\{funcsatValue}(\|f,\39\\{otherlit});{}$\6
\&{if} ${}(\\{litval}\E\\{true}){}$\1\5
\&{goto} \\{watch\_continue};\2\6
\&{if} ${}(\\{litval}\E\\{false}){}$\5
${}\{{}$\1\6
\X84:Record conflict and return\X\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\X85:Record new unit inference\X\6
\4${}\}{}$\2\6
\4\\{watch\_continue}:\5
${}{*}\\{dump}\K{*}\\{elt},\39\\{watchlist\_next\_elt}(\\{dump},\39\\{wl}){}$;%
\C{ keep \PB{\\{elt}} in this \PB{\\{wl}} }\6
${}\\{new\_size}\PP;{}$\6
\4\\{skip\_watchelt\_copy}:\5
;\6
\4${}\}{}$\2\6
${}\|f\MG\\{propq}\PP;{}$\6
${}\\{wl}\MG\\{size}\K\\{new\_size};{}$\6
${}\\{dclose}(\|f,\39\.{"bcp"}){}$;\par
\Q83.
\U62.\fi

\M{81}The \PB{\&{watchlist\_elt}} is in the cache line. We have stored a
literal from the
clause in there so that we can quickly test whether it's true; if it is, we can
ignore the current clause and go on to the next one.

\Y\B\4\X81:Check \PB{$\\{elt}\MG\\{lit}$} for quick SAT clause\X${}\E{}$\6
\&{if} ${}(\\{funcsatValue}(\|f,\39\\{elt}\MG\\{lit})\E\\{true}){}$\1\5
\&{goto} \\{watch\_continue};\C{     If \PB{$\\{elt}\MG\\{lit}$} is \PB{%
\\{true}}, clause already satisfied }\2\par
\U80.\fi

\M{82}Just for organization's sake, we put the watched literal (which is false)
into
\PB{$\|c\MG\\{lits}[\T{1}]$}.

\Y\B\4\X82:Ensure false literal is in \PB{$\|c\MG\\{lits}[\T{1}]$}\X${}\E{}$\6
\&{if} ${}(\|c\MG\\{lits}[\T{0}]\E\\{false\_lit}){}$\5
${}\{{}$\1\6
\&{literal} \\{tmp}${}\K\|c\MG\\{lits}[\T{0}];{}$\7
${}\\{elt}\MG\\{lit}\K\|c\MG\\{lits}[\T{0}]\K\|c\MG\\{lits}[\T{1}],\39\|c\MG%
\\{lits}[\T{1}]\K\\{tmp};{}$\6
${}\\{assert}(\|c\MG\\{lits}[\T{1}]\E\\{false\_lit});{}$\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"bcp"},\39\T{10}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{9},\39\.{"swapped\ "});{}$\6
${}\\{fs\_clause\_head\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39\\{elt}\MG%
\\{cls}),\39\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{assert}(\|c\MG\\{lits}[\T{1}]\E\\{false\_lit}){}$;\par
\U80.\fi

\M{83}Our goal is to discover whether the clause \PB{\|c} is \textit{unit} or
not. To do
that we check the clause (excepting the two first literals) for any literal
that
is not false. If we fail to find one, since we have ensured that the first
literal is in \PB{$\|c\MG\\{lits}[\T{1}]$} (see \PB{$\X80:\BCP\ clauses\X$}),
the clause is unit or false.

\Y\B\4\X83:Look for new, unfalsified literal to watch, removing \PB{\\{elt}} if
found\X${}\E{}$\6
\&{struct} \&{clause\_iter} \\{it};\7
${}\\{clause\_iter\_init}(\|f,\39\\{elt}\MG\\{cls},\39{\AND}\\{it});{}$\6
${}\\{clause\_iter\_next}(\|f,\39{\AND}\\{it}),\39\\{clause\_iter\_next}(\|f,%
\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
\&{mbool} \|v${}\K\\{funcsatValue}(\|f,\39{*}\|p);{}$\7
\&{if} ${}(\|v\I\\{false}){}$\5
${}\{{}$\1\6
${}\|c\MG\\{lits}[\T{1}]\K{*}\|p,\39{*}\|p\K\\{false\_lit};{}$\6
${}\\{watch\_l1}(\|f,\39\\{elt}\MG\\{cls});{}$\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"bcp"},\39\T{9}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{9},\39\.{"moved\ "});{}$\6
${}\\{fs\_clause\_head\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39\\{elt}\MG%
\\{cls}),\39\.{NEWLINE}(\\{fs\_dbgout}(\|f));{}$\6
\4${}\}{}$\2\6
${}\\{elt}\MG\\{cls}\K\.{NO\_CLS};{}$\6
${}\\{elt}\MG\\{lit}\K\T{0};{}$\6
\&{goto} \\{skip\_watchelt\_copy};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U80.\fi

\M{84}Recording the conflict should be straightforward, but we have to be
careful
about the clauses after the conflict clause in this \PB{\&{watchlist}}.  The
loop below
ensures they're copied back into the current \PB{\&{watchlist}} before we stop %
\BCP.

\PB{\&{for\_watchlist\_continue}} simply omits the initialization part of \PB{%
\&{for\_watchlist}},
but is otherwise identical. At this point we have found a false clause (a
conflict) and need to make sure not to drop the other watched clauses down the
disposal.

\Y\B\4\D$\&{for\_watchlist\_continue}(\\{elt},\\{dump},\\{wl})$ \5
\&{for} ( ; ${}(\\{watchlist\_is\_elt\_in\_head}(\\{elt},\39\\{wl})\?\\{elt}<%
\\{watchlist\_head\_size\_ptr}(\\{wl}):\\{elt}<\\{watchlist\_rest\_size\_ptr}(%
\\{wl}));{}$ ${}\\{watchlist\_next\_elt}(\\{elt},\39\\{wl}){}$)\par
\Y\B\4\X84:Record conflict and return\X${}\E{}$\6
$\\{isConsistent}\K\\{false};{}$\6
${}\|f\MG\\{conflict\_clause}\K\\{elt}\MG\\{cls};{}$\6
\&{for\_watchlist\_continue} ${}(\\{elt},\39\\{dump},\39\\{wl}){}$\5
${}\{{}$\C{ save rest of watched clauses }\1\6
${}{*}\\{dump}\K{*}\\{elt},\39\\{watchlist\_next\_elt}(\\{dump},\39\\{wl});{}$\6
${}\\{new\_size}\PP;{}$\6
\4${}\}{}$\2\6
${}\\{wl}\MG\\{size}\K\\{new\_size};{}$\6
${}\\{dclose}(\|f,\39\.{"bcp"});{}$\6
\&{goto} \\{bcp\_conflict};\par
\U80.\fi

\M{85}It's simple, really.

\Y\B\4\X85:Record new unit inference\X${}\E{}$\6
$\\{fslog}(\|f,\39\.{"bcp"},\39\T{2},\39\.{"\ =>\ \%ji\ (\%s:\%d)\\n"},\39%
\\{otherlit},\39\.{\_\_FILE\_\_},\39\.{\_\_LINE\_\_});{}$\6
${}\\{trailPush}(\|f,\39\\{otherlit},\39\\{reason\_info\_mk}(\|f,\39\\{elt}\MG%
\\{cls}));{}$\6
${}\|f\MG\\{conf}\MG\\{bumpUnitClause}(\|f,\39\\{elt}\MG\\{cls}){}$;\par
\U80.\fi

\M{86}We have a few helpers for watching literals 0 and 1 of a clause.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{struct} \&{watchlist\_elt} ${}{*}{}$\\{watch\_lit}(%
\&{funcsat} ${}{*}\|f,\39{}$\&{struct} \&{watchlist} ${}{*}\\{wl},\39{}$%
\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{watchlist\_elt} ${}{*}\\{ret};{}$\7
\&{if} ${}(\\{watchlist\_head\_size}(\\{wl})<\.{WATCHLIST\_HEAD\_SIZE\_MAX}){}$%
\5
${}\{{}$\1\6
${}\\{assert}(\\{watchlist\_rest\_size}(\\{wl})\E\T{0});{}$\6
${}\\{ret}\K{\AND}\\{wl}\MG\\{elts}[\\{watchlist\_head\_size}(\\{wl})];{}$\6
${}\\{wl}\MG\\{elts}[\\{watchlist\_head\_size}(\\{wl})].\\{cls}\K\\{ix};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{assert}(\\{watchlist\_head\_size}(\\{wl})\G\.{WATCHLIST\_HEAD\_SIZE%
\_MAX});{}$\6
\X87:Allocate and/or grow \PB{\\{wl}}'s watchlist element capacity\X\6
${}\\{ret}\K{\AND}\\{wl}\MG\\{rest}[\\{watchlist\_rest\_size}(\\{wl})];{}$\6
${}\\{wl}\MG\\{rest}[\\{watchlist\_rest\_size}(\\{wl})].\\{cls}\K\\{ix};{}$\6
\4${}\}{}$\2\6
${}\\{wl}\MG\\{size}\PP;{}$\6
\&{return} \\{ret};\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{void} \\{watch\_l0}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|c\K\\{clause\_head\_ptr}(\|f,\39\\{ix});{}$%
\6
\&{struct} \&{watchlist} ${}{*}\\{wl}\K{\AND}\|f\MG\\{watches}.\\{wlist}[\\{fs%
\_lit2idx}({-}\|c\MG\\{lits}[\T{0}])];{}$\6
\&{struct} \&{watchlist\_elt} ${}{*}\\{elt}\K\\{watch\_lit}(\|f,\39\\{wl},\39%
\\{ix});{}$\7
${}\\{elt}\MG\\{lit}\K(\|c\MG\\{sz}\E\T{2}\?\|c\MG\\{lits}[\T{1}]:\|c\MG%
\\{lits}[\T{0}]);{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{void} \\{watch\_l1}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|c\K\\{clause\_head\_ptr}(\|f,\39\\{ix});{}$%
\6
\&{struct} \&{watchlist} ${}{*}\\{wl}\K{\AND}\|f\MG\\{watches}.\\{wlist}[\\{fs%
\_lit2idx}({-}\|c\MG\\{lits}[\T{1}])];{}$\6
\&{struct} \&{watchlist\_elt} ${}{*}\\{elt}\K\\{watch\_lit}(\|f,\39\\{wl},\39%
\\{ix});{}$\7
${}\\{elt}\MG\\{lit}\K(\|c\MG\\{sz}\E\T{2}\?\|c\MG\\{lits}[\T{1}]:\|c\MG%
\\{lits}[\T{0}]);{}$\6
\4${}\}{}$\2\par
\fi

\M{87}

\Y\B\4\X87:Allocate and/or grow \PB{\\{wl}}'s watchlist element capacity\X${}%
\E{}$\6
\&{if} ${}(\\{wl}\MG\\{capacity}>\T{0}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{watchlist\_rest\_size}(\\{wl})\G\\{wl}\MG\\{capacity}){}$\5
${}\{{}$\1\6
${}\.{FS\_REALLOC}(\\{wl}\MG\\{rest},\39\\{wl}\MG\\{capacity}*\T{2},\39{}$%
\&{sizeof} ${}({*}\\{wl}\MG\\{rest}));{}$\6
${}\\{wl}\MG\\{capacity}\MRL{*{\K}}\T{2};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\.{FS\_CALLOC}(\\{wl}\MG\\{rest},\39\T{8},\39{}$\&{sizeof} ${}({*}\\{wl}\MG%
\\{rest}));{}$\6
${}\\{wl}\MG\\{capacity}\K\T{8};{}$\6
\4${}\}{}$\2\par
\U86.\fi

\M{88}

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{watch\_l0}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{uintptr\_t} \\{ix});\6
\&{static} \&{inline} \&{void} \\{watch\_l1}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{uintptr\_t} \\{ix});\par
\fi

\M{89}When a clause is initially added, we watch it with \PB{\\{addWatch}}.
This ensures an
invariant holds (see \PB{\\{makeWatchable}}) and then adds the clause into the
watcher
lists.

\Y\B\4\D$\.{NEWLINE}(\|s)$ \5
$\\{fprintf}((\R(\|s)\?\\{stderr}:(\|s)),\39\.{"\\n"}{}$)\par
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{addWatch}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} \\{ix})\1\1\2%
\2\6
${}\{{}$\1\6
${}\\{makeWatchable}(\|f,\39\\{ix});{}$\6
${}\\{addWatchUnchecked}(\|f,\39\\{ix});{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{void} \\{addWatchUnchecked}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|c\K\\{clause\_head\_ptr}(\|f,\39\\{ix});{}$%
\7
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{1},\39\.{"watching\ \%li\ and\ \%l}\)\.{i\
in\ "},\39\|c\MG\\{lits}[\T{0}],\39\|c\MG\\{lits}[\T{1}]);{}$\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"bcp"},\39\T{1}){}$\5
${}\{{}$\1\6
${}\\{fs\_clause\_head\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39\\{ix}),\39%
\.{NEWLINE}(\\{fs\_dbgout}(\|f));{}$\6
\4${}\}{}$\2\6
${}\\{assert}(\|c\MG\\{sz}>\T{1});{}$\6
${}\\{watch\_l0}(\|f,\39\\{ix});{}$\6
${}\\{watch\_l1}(\|f,\39\\{ix});{}$\6
${}\|c\MG\\{where}\K\.{CLAUSE\_WATCHED};{}$\6
\4${}\}{}$\2\par
\fi

\M{90}A clause which is about we be watched must obey an invariant: that the
first
(up to) two literals in the clause must be not false, if there are any such
literals.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{makeWatchable}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} \\{ix})\1%
\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|c\K\\{clause\_head\_ptr}(\|f,\39\\{ix});{}$%
\6
\&{struct} \&{clause\_iter} \\{pit}${},{}$ \\{qit};\7
${}\\{clause\_iter\_init}(\|f,\39\\{ix},\39{\AND}\\{pit}),\39\\{clause\_iter%
\_init}(\|f,\39\\{ix},\39{\AND}\\{qit});{}$\7
\&{variable} \\{swap\_cnt}${}\K\T{0};{}$\7
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{pit}),%
\39{*}\|q\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{qit});{}$ ${}\|p\W\|q\W%
\\{swap\_cnt}<\T{2};{}$ ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}%
\\{pit})){}$\5
${}\{{}$\1\6
\&{mbool} \|v${}\K\\{funcsatValue}(\|f,\39{*}\|p);{}$\7
\&{if} ${}(\|v\I\\{false}\W\|p\I\|q){}$\5
${}\{{}$\1\6
\&{literal} \\{tmp}${}\K{*}\|q;{}$\7
${}{*}\|q\K{*}\|p,\39{*}\|p\K\\{tmp};{}$\6
${}\\{swap\_cnt}\PP;{}$\6
${}\|q\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{qit});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\8\#\&{if} \T{0}\6
${}\\{assert}(\\{is\_watchable}(\|f,\39\|c));{}$\6
\8\#\&{endif}\6
\4${}\}{}$\2\par
\fi

\M{91}A clause is watchable if it has at least two literals and the first two
literals are not \PB{\\{false}}.

The \BCP\ code when propagating $-l$ (and the other literal is $p$) will break
if: \numberedlist

\li $p$ is false and there is another literal in the clause (aside from $-l$)
that is not false

\endnumberedlist
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{bool} \\{is\_watchable}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{struct} \&{clause\_head} ${}{*}\|c){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\|c\MG\\{sz}<\T{2}){}$\1\5
\&{return} \\{false};\2\6
\&{return} \\{funcsatValue}${}(\|f,\39\|c\MG\\{lits}[\T{0}])\I\\{false}\W%
\\{funcsatValue}(\|f,\39\|c\MG\\{lits}[\T{1}])\I\\{false};{}$\6
\4${}\}{}$\2\par
\fi

\M{92}

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{void} \\{addWatch}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} \\{ix});\6
\&{static} \&{inline} \&{void} \\{addWatchUnchecked}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{uintptr\_t} \\{ix});\6
\&{void} \\{makeWatchable}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} \\{ix});\6
\&{static} \&{inline} \&{bool} \\{is\_watchable}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{struct} \&{clause\_head} ${}{*}\|c){}$;\par
\fi

\M{93}

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{void} \\{fs\_watches\_print}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE}
${}{*}\\{out},\39{}$\&{literal} \|p)\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\R\\{out}){}$\1\5
${}\\{out}\K\\{stderr};{}$\2\6
${}\\{fprintf}(\\{out},\39\.{"watcher\ list\ for\ \%j}\)\.{i:\\n"},\39\|p);{}$\7
\&{struct} \&{watchlist} ${}{*}\\{wl}\K{\AND}\|f\MG\\{watches}.\\{wlist}[\\{fs%
\_lit2idx}(\|p)];{}$\6
\&{struct} \&{watchlist\_elt} ${}{*}\\{elt},{}$ ${}{*}\\{dump};{}$\7
\&{for\_watchlist} ${}(\\{elt},\39\\{dump},\39\\{wl}){}$\5
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|c\K\\{clause\_head\_ptr}(\|f,\39\\{elt}\MG%
\\{cls});{}$\7
\&{if} (\|c)\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"[\%ji"},\39\\{elt}\MG\\{lit});{}$\7
\&{bool} \\{in\_clause}${}\K\\{false};{}$\6
\&{struct} \&{clause\_iter} \\{it};\7
${}\\{clause\_iter\_init}(\|f,\39\\{elt}\MG\\{cls},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|q\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|q; ${}\|q\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
\&{if} ${}({*}\|q\E\\{elt}\MG\\{lit}){}$\5
${}\{{}$\1\6
${}\\{in\_clause}\K\\{true};{}$\6
\&{break};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{in\_clause}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"\ oh\ noes!"});{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{out},\39\.{"]\ "});{}$\6
${}\\{fs\_clause\_head\_print}(\|f,\39\\{out},\39\\{elt}\MG\\{cls}),\39%
\.{NEWLINE}(\\{out});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"[EMPTY\ SLOT]\\n"});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\N{3}{94}Reasons. We allow dynamic calculation of reason clauses.

\Y\B\4\X13:External types\X${}\mathrel+\E{}$\6
\&{enum} \&{reason\_ty} ${}\{{}$\1\6
\.{REASON\_CLS\_TY}\2\6
${}\}{}$;\par
\fi

\M{95}Reasons are represented internally with this \PB{\&{struct}}. \PB{%
\\{reason\_info}}s are
store in a pool, like other data structures in \funcsat. When the \PB{\\{reason%
\_info}}
is free, the \PB{\\{ty}} is the index of the next \PB{\\{reason\_info}} in the
freelist. Otherwise it indicates the type of the \PB{\\{reason\_info}} (see %
\PB{\&{enum} \&{reason\_ty}}).

\Y\B\4\X38:Internal types\X${}\mathrel+\E{}$\6
\&{struct} \&{reason\_info} ${}\{{}$\1\6
\&{uintptr\_t} \\{ty};\C{ \PB{\&{enum} \&{reason\_ty}}, but can be others too }%
\6
\&{uintptr\_t} \\{cls};\C{ index of \PB{\&{clause\_head}} }\2\6
${}\};{}$\6
\8\#\&{include} \.{"funcsat/vec\_reason\_}\)\.{info.h"}\par
\fi

\M{96}Getting a reason can now invoke whatever frontend is driving \funcsat, if
that
frontend will dynamically calculate a reason clause. Note that this is invoked
\textit{at learning time}, not at inference time. This way other inference
procedures (not based on clauses and \BCP) can infer literals and only if that
inference causes a conflict will a reason clause be required.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{uintptr\_t} \\{getReason}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{literal} \|l)\1\1\2\2\6
${}\{{}$\1\6
\&{uintptr\_t} \\{reason\_idx}${}\K\|f\MG\\{reason}\MG\\{data}[\\{fs\_lit2var}(%
\|l)];{}$\7
\&{if} ${}(\\{reason\_idx}\I\.{NO\_CLS}){}$\5
${}\{{}$\1\6
\&{struct} \&{reason\_info} ${}{*}\|r\K\\{reason\_info\_ptr}(\|f,\39\\{reason%
\_idx});{}$\7
\&{if} ${}(\|r\MG\\{ty}\E\.{REASON\_CLS\_TY}){}$\1\5
\&{return} \|r${}\MG\\{cls};{}$\2\6
${}\&{uintptr\_t}({*}\\{get\_reason\_clause}){}$(\&{funcsat} ${}{*},\39%
\&{literal})\K\|f\MG\\{reason\_hooks}.\\{data}[\|r\MG\\{ty}];{}$\6
${}\|r\MG\\{ty}\K\.{REASON\_CLS\_TY}{}$;\C{ cache reason clause }\6
\&{return} \|r${}\MG\\{cls}\K\\{get\_reason\_clause}(\|f,\39\|l);{}$\6
\4${}\}{}$\2\6
\&{else}\1\5
\&{return} \.{NO\_CLS};\2\6
\4${}\}{}$\2\par
\fi

\M{97}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{uintptr\_t} \\{getReason}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{literal} \|l);\par
\fi

\M{98}The \PB{\\{reason}} and \PB{\\{reason\_hooks}} need to be initialized.

\Y\B\4\X41:Initialize funcsat type\X${}\mathrel+\E{}$\6
$\|f\MG\\{reason}\K\\{vec\_uintptr\_init}(\T{2});{}$\6
${}\\{vec\_uintptr\_push}(\|f\MG\\{reason},\39\.{NO\_CLS});{}$\6
${}\\{vec\_ptr\_mk}({\AND}\|f\MG\\{reason\_hooks},\39\T{2}){}$;\par
\fi

\M{99}Clients should use this to add a hook for generating reasons.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{funcsatAddReasonHook}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} %
\\{ty}${},\39\&{uintptr\_t}({*}\\{hook}){}$(\&{funcsat} ${}{*}\|f,\39{}$%
\&{literal} \|l))\1\1\2\2\6
${}\{{}$\1\6
${}\\{vec\_ptr\_push}({\AND}\|f\MG\\{reason\_hooks},\39\\{hook});{}$\6
\4${}\}{}$\2\par
\fi

\M{100}Declaration.
\Y\B\4\X15:External declarations\X${}\mathrel+\E{}$\6
\&{void} \\{funcsatAddReasonHook}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} %
\\{ty}${},\39\&{uintptr\_t}({*}\\{hook}){}$(\&{funcsat} ${}{*}\|f,\39{}$%
\&{literal} \|l));\par
\fi

\M{101}When an inference is discovered, we need to set its reason using a fresh
\PB{\&{reason\_info}}. But of course we shouldn't allocate it. That would slow
down
solving. We have a freelist of \PB{\&{reason\_info}}s and we pick the next free
one.

\Y\B\4\D$\\{reason\_info\_ptr}(\|f,\|i)$ \5
$({\AND}((\|f)\MG\\{reason\_infos}\MG\\{data}[\|i]){}$)\par
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{uintptr\_t} \\{reason\_info\_mk}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\|f\MG\\{reason\_infos\_freelist}<\|f\MG\\{reason\_infos}\MG%
\\{size});{}$\7
\&{uintptr\_t} \\{ret}${}\K\|f\MG\\{reason\_infos\_freelist};{}$\6
\&{struct} \&{reason\_info} ${}{*}\|r\K\\{reason\_info\_ptr}(\|f,\39%
\\{ret});{}$\7
${}\|f\MG\\{reason\_infos\_freelist}\K\|r\MG\\{ty};{}$\6
${}\|r\MG\\{ty}\K\.{REASON\_CLS\_TY};{}$\6
${}\|r\MG\\{cls}\K\\{ix};{}$\6
\&{return} \\{ret};\6
\4${}\}{}$\2\par
\fi

\M{102}To reclaim the \PB{\&{reason\_info}}, we assign it to the head of the
freelist and its
next to the current freelist head.

\Y\B\4\D$\\{reason\_info\_idx}(\|f,\|r)$ \5
$((\|r)-(\|f)\MG\\{reason\_infos}\MG\\{data}{}$)\par
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{reason\_info\_release}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{uintptr\_t} \\{ri})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{reason\_info} ${}{*}\|r\K\\{reason\_info\_ptr}(\|f,\39\\{ri});{}$%
\7
${}\|r\MG\\{ty}\K\|f\MG\\{reason\_infos\_freelist}{}$;\C{ \PB{\\{ty}} becomes
the next index }\6
${}\|f\MG\\{reason\_infos\_freelist}\K\\{ri};{}$\6
\4${}\}{}$\2\par
\fi

\M{103}Allocate and initialize the freelist.

\Y\B\4\X41:Initialize funcsat type\X${}\mathrel+\E{}$\6
$\|f\MG\\{reason\_infos\_freelist}\K\.{UINTMAX\_MAX}{}$;\C{ empty }\6
${}\|f\MG\\{reason\_infos}\K\\{vec\_reason\_info\_init}(\T{2});{}$\6
${}\|f\MG\\{reason\_infos}\MG\\{size}\K\T{0}{}$;\par
\fi

\M{104}Just grow and add the new elements to the freelist.
\Y\B\4\X104:Resize internal data structures up to new \PB{\\{numVars}}\X${}%
\E{}$\6
$\\{vec\_reason\_info\_grow\_to}(\|f\MG\\{reason\_infos},\39\\{numVars});{}$\6
\&{for} (\&{uintptr\_t} \|i${}\K\|f\MG\\{reason\_infos}\MG\\{size};{}$ ${}\|i<%
\\{numVars};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{reason\_info\_release}(\|f,\39\|i);{}$\6
\4${}\}{}$\2\6
${}\|f\MG\\{reason\_infos}\MG\\{size}\K\\{numVars}{}$;\par
\As131\ET154.
\U219.\fi

\M{105}For each new variable, push that it has no reason.
\Y\B\4\X72:Incrementally resize internal data structures up to new \PB{%
\\{numVars}}\X${}\mathrel+\E{}$\6
$\\{vec\_uintptr\_push}(\|f\MG\\{reason},\39\.{NO\_CLS}){}$;\par
\fi

\M{106}Destroy.
\Y\B\4\X42:Destroy funcsat type\X${}\mathrel+\E{}$\6
$\\{vec\_uintptr\_destroy}(\|f\MG\\{reason});{}$\6
${}\\{vec\_reason\_info\_destroy}(\|f\MG\\{reason\_infos});{}$\6
${}\\{vec\_ptr\_unmk}({\AND}\|f\MG\\{reason\_hooks}){}$;\par
\fi

\N{3}{107}Trail. The trail is managed pretty simply with \PB{\\{trailPush}} and
\PB{\\{trailPop}}.

\PB{\\{trailPush}} is for adding a new literal to the trail (inferred or
decided).

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{trailPush}(\&{funcsat} ${}{*}\|f,\39{}$\&{literal} \|p${},\39{}$%
\&{uintptr\_t} \\{reason\_info\_idx})\1\1\2\2\6
${}\{{}$\1\6
\&{variable} \|v${}\K\\{fs\_lit2var}(\|p);{}$\7
${}\\{assert}(\|v\Z\|f\MG\\{numVars});{}$\6
\8\#\&{ifndef} \.{NDEBUG}\6
\&{if} ${}(\|f\MG\\{model}.\\{data}[\|v]<\|f\MG\\{trail}.\\{size}){}$\5
${}\{{}$\1\6
${}\\{assert}(\|f\MG\\{trail}.\\{data}[\|f\MG\\{model}.\\{data}[\|v]]\I\|p);{}$%
\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
${}\\{clausePush}({\AND}\|f\MG\\{trail},\39\|p);{}$\6
${}\|f\MG\\{model}.\\{data}[\|v]\K\|f\MG\\{trail}.\\{size}-{}$(\&{uintmax\_t}) %
\T{1};\6
${}\|f\MG\\{phase}.\\{data}[\|v]\K\|p;{}$\6
${}\|f\MG\\{level}.\\{data}[\|v]\K{}$(\&{literal}) \|f${}\MG%
\\{decisionLevel};{}$\6
\&{if} ${}(\\{reason\_info\_idx}\I\.{NO\_CLS}){}$\5
${}\{{}$\1\6
\&{struct} \&{reason\_info} ${}{*}\|r\K\\{reason\_info\_ptr}(\|f,\39\\{reason%
\_info\_idx});{}$\7
\&{if} ${}(\|r\MG\\{ty}\E\.{REASON\_CLS\_TY}){}$\5
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\|r\MG%
\\{cls});{}$\7
${}\|h\MG\\{is\_reason}\K\\{true};{}$\6
\4${}\}{}$\2\6
${}\|f\MG\\{reason}\MG\\{data}[\|v]\K\\{reason\_info\_idx};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{108}\PB{\\{trailPop}} is for removing the last pushed literal from the
trail. The
\PB{\&{literal}} is returned.

In order to pop the trail, you usually want to make sure you don't lose any
facts we have around for the literal you're popping. If that is true, supply a
list to merge with. If facts is \PB{$\NULL$}, any facts are released.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{literal} \\{trailPop}(\&{funcsat} ${}{*}\|f,\39{}$\&{head\_tail} ${}{*}%
\\{facts}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} \|p${}\K\\{clausePeek}({\AND}\|f\MG\\{trail});{}$\6
\&{variable} \|v${}\K\\{fs\_lit2var}(\|p);{}$\6
\&{uintptr\_t} \\{reason\_ix};\7
\&{if} ${}(\\{facts}\W\R\\{head\_tail\_is\_empty}({\AND}\|f\MG\\{unit\_facts}[%
\|v])){}$\1\5
${}\\{head\_tail\_append}(\|f,\39\\{facts},\39{\AND}\|f\MG\\{unit\_facts}[%
\|v]);{}$\2\6
\8\#\&{if} \T{0}\6
${}\\{exonerateClauses}(\|f,\39\|v);{}$\6
\8\#\&{endif}\6
\&{if} ${}(\|f\MG\\{decisions}.\\{data}[\|v]\I\T{0}){}$\5
${}\{{}$\C{Added by SEAN!!!}\1\6
\&{if} ${}(\|f\MG\\{Backtrack\_hook}){}$\1\5
${}\|f\MG\\{Backtrack\_hook}{}$((\&{uintptr\_t} ${}{*}){}$ \|f${}\MG\\{conf}\MG%
\\{user},\39\|f\MG\\{decisionLevel});{}$\2\6
${}\|f\MG\\{decisionLevel}\MM;{}$\6
${}\|f\MG\\{decisions}.\\{data}[\|v]\K\T{0};{}$\6
\4${}\}{}$\C{ no need to clear model }\C{ \PB{$\|f\MG\\{model}.\\{data}[\|v]\K%
\T{0};$} }\2\6
${}\|f\MG\\{level}.\\{data}[\|v]\K\\{Unassigned};{}$\6
${}\\{reason\_ix}\K\|f\MG\\{reason}\MG\\{data}[\|v];{}$\6
\&{if} ${}(\\{reason\_ix}\I\.{NO\_CLS}){}$\5
${}\{{}$\1\6
\&{struct} \&{reason\_info} ${}{*}\|r\K\\{reason\_info\_ptr}(\|f,\39\\{reason%
\_ix});{}$\7
\&{if} ${}(\|r\MG\\{ty}\E\.{REASON\_CLS\_TY}){}$\5
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\|r\MG%
\\{cls});{}$\7
${}\|h\MG\\{is\_reason}\K\\{false};{}$\6
\4${}\}{}$\2\6
${}\\{reason\_info\_release}(\|f,\39\\{reason\_ix});{}$\6
${}\|f\MG\\{reason}\MG\\{data}[\|v]\K\.{NO\_CLS};{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{bh\_is\_in\_heap}(\|f,\39\|v)){}$\5
${}\{{}$\6
\8\#\&{ifndef} \.{NDEBUG}\1\6
\\{bh\_check}(\|f);\6
\8\#\&{endif}\6
${}\\{bh\_insert}(\|f,\39\|v);{}$\6
\4${}\}{}$\2\6
${}\\{clausePop}({\AND}\|f\MG\\{trail});{}$\6
\&{if} ${}(\|f\MG\\{propq}\G\|f\MG\\{trail}.\\{size}){}$\1\5
${}\|f\MG\\{propq}\K\|f\MG\\{trail}.\\{size};{}$\2\6
\&{return} \|p;\6
\4${}\}{}$\2\par
\fi

\M{109}

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{literal} \\{trailPeek}(\&{funcsat} ${}{*}\|f){}$\1\1\2%
\2\6
${}\{{}$\1\6
\&{literal} \|p${}\K\\{clausePeek}({\AND}\|f\MG\\{trail});{}$\7
\&{return} \|p;\6
\4${}\}{}$\2\par
\fi

\M{110}The prototypes.
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{void} \\{trailPush}(\&{funcsat} ${}{*}\|f,\39{}$\&{literal} \|p${},\39{}$%
\&{uintptr\_t} \\{reason\_info\_idx});\6
\&{literal} \\{trailPop}(\&{funcsat} ${}{*}\|f,\39{}$\&{head\_tail} ${}{*}%
\\{facts});{}$\6
\&{static} \&{inline} \&{literal} \\{trailPeek}(\&{funcsat} ${}{*}\|f);{}$\6
\&{static} \&{inline} \&{uintptr\_t} \\{reason\_info\_mk}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{uintptr\_t} \\{ix});\par
\fi

\N{3}{111}Jailing and exoneration. Clause jailing is simply stashing clauses
that we
can easily prove BCP won't ever need to consider (in a particular part of the
search tree).

Right now it's turned off.

Preconditions:
\unorderedlist
\li the clause is alone through the 1st literal
\li \PB{\\{trueLit}} is true
\li the clause is (2-watch) linked through the 0th literal
\endunorderedlist

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{void} \\{jailClause}(\&{funcsat} ${}{*}\|f,\39{}$\&{literal} %
\\{trueLit}${},\39{}$\&{clause} ${}{*}\|c){}$\1\1\2\2\6
${}\{{}$\6
\8\#\&{if} \T{0}\1\6
${}\PP\|f\MG\\{numJails};{}$\6
${}\\{dopen}(\|f,\39\.{"jail"});{}$\6
${}\\{assert}(\\{funcsatValue}(\|f,\39\\{trueLit})\E\\{true});{}$\7
\&{const} \&{variable} \\{trueVar}${}\K\\{fs\_lit2var}(\\{trueLit});{}$\7
${}\\{dmsg}(\|f,\39\.{"jail"},\39\T{7},\39\\{false},\39\.{"jailed\ for\ \%ju:\
"},\39\\{trueVar});{}$\6
\\{clauseUnSpliceWatch}((\&{clause} ${}{*}{*}){}$ ${}{\AND}\\{watches}\MG%
\\{data}[\\{fs\_lit2idx}({-}\|c\MG\\{data}[\T{0}])],\39\|c,\39\T{0});{}$\7
\&{clause} ${}{*}\\{cell}\K{\AND}\|f\MG\\{jail}.\\{data}[\\{trueVar}];{}$\7
${}\\{clauseSplice1}(\|c,\39{\AND}\\{cell});{}$\6
${}\\{dclose}(\|f,\39\.{"jail"});{}$\6
${}\\{assert}(\R\|c\MG\\{is\_watched});{}$\6
\8\#\&{endif}\6
\4${}\}{}$\2\7
\&{static} \&{void} \\{exonerateClauses}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{variable} \|v)\1\1\2\2\6
${}\{{}$\1\6
\&{uintptr\_t} \|p${},{}$ \|c${},{}$ \\{nx};\7
\&{for\_head\_tail} ${}(\|f,\39{\AND}\|f\MG\\{jail}[\|v],\39\|p,\39\|c,\39%
\\{nx}){}$\5
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\|c);{}$\7
${}\|h\MG\\{link}\K\.{NO\_CLS};{}$\6
${}\\{addWatchUnchecked}(\|f,\39\|c);{}$\6
\4${}\}{}$\2\7
\&{head\_tail} \\{tmp};\7
${}\\{head\_tail\_clear}({\AND}\\{tmp});{}$\6
${}\\{memcpy}({\AND}\|f\MG\\{jail}[\|v],\39{\AND}\\{tmp},\39{}$\&{sizeof} (%
\\{tmp}));\6
\4${}\}{}$\2\par
\fi

\N{2}{112}Decisions. We use a heap to organize our unassigned variables. Then a
decision is made based on their priority. The heap needs to have in it at least
all unassigned variables, though it may have assigned variables in it.

\paragraphit{\it Digression.}
%
I originally wrote a fibonacci heap because I believe it would be the fastest
for this application. (Asymptotically, it is very fast.) But there are a few
problems with it:

\numberedlist

\li It is big. Each node needs something like four pointers, and even though I
allocate all the nodes contiguously, that's big. It's going to affect the cache
behavior.

An array-backed binary heap one pointer for each heap element: the pointer
points to the node associated with its position in the heap. The ``pointers''
to
the child elements are just array index expressions.

\li I've since learned about pairing heaps, which are alleged to be just as
fast
(or faster) than fibheaps, and much cheaper to implement. From what I've read,
it looks like you can get a pairing heap with only two pointers per node
(instead of four).

I wonder, though, if people use pairing heaps chiefly because they're afraid of
trying to implement a fibonacci heap.

\endnumberedlist \hfill{\it End Digression.}

Anyway, back to this code. This is how we decide on the next branching
variable:

\numberedlist

\li We extract the highest priority variable. It might be assigned or not, so
we
have to check for that. If it is assigned, we keep picking variables until
(1)~we can't anymore or (2)~we find an unassigned one.

\li We check which phase the variable should get. (This should be made more
general. Probably we should have a heap of literals, not variables.)

\li Once we have a literal to set to true, we put it on the trail and adjust a
few other data structures.

\endnumberedlist

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{literal} \\{funcsatMakeDecision}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}%
\|p){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} \|l${}\K\T{0};{}$\7
\&{if} ${}(\|f\MG\\{ExternalHeuristic\_hook}\I\NULL){}$\5
${}\{{}$\1\6
${}\|l\K\|f\MG\\{ExternalHeuristic\_hook}{}$((\&{uintptr\_t} ${}{*}){}$ \|f${}%
\MG\\{conf}\MG\\{user});{}$\7
\&{variable} \|v${}\K\\{fs\_lit2var}(\|l);{}$\7
${}\PP\|f\MG\\{numDecisions};{}$\6
${}\\{trailPush}(\|f,\39\|l,\39\.{NO\_CLS});{}$\6
${}\|f\MG\\{level}.\\{data}[\|v]\K{}$(\&{intmax\_t}) ${}\PP\|f\MG%
\\{decisionLevel};{}$\6
${}\|f\MG\\{decisions}.\\{data}[\|v]\K\|f\MG\\{decisionLevel};{}$\6
${}\\{fslog}(\|f,\39\.{"solve"},\39\T{2},\39\.{"branched\ on\ \%ji\\n"},\39%
\|l);{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{while} ${}(\\{bh\_size}(\|f)>\T{0}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"decide"},\39\T{5},\39\.{"extracting\\n"});{}$\7
\&{variable} \|v${}\K\\{bh\_pop}(\|f);{}$\6
\8\#\&{ifndef} \.{NDEBUG}\7
\\{bh\_check}(\|f);\6
\8\#\&{endif}\6
${}\\{fslog}(\|f,\39\.{"decide"},\39\T{5},\39\.{"extracted\ \%ju\\n"},\39%
\|v);{}$\7
\&{literal} \|p${}\K{-}\\{fs\_var2lit}(\|v);{}$\7
\&{if} ${}(\\{funcsatValue}(\|f,\39\|p)\E\\{unknown}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|f\MG\\{conf}\MG\\{usePhaseSaving}){}$\1\5
${}\|l\K\|f\MG\\{phase}.\\{data}[\|v];{}$\2\6
\&{else}\1\5
${}\|l\K\|p;{}$\2\6
${}\PP\|f\MG\\{numDecisions};{}$\6
${}\\{trailPush}(\|f,\39\|l,\39\.{NO\_CLS});{}$\6
${}\|f\MG\\{level}.\\{data}[\|v]\K{}$(\&{intmax\_t}) ${}\PP\|f\MG%
\\{decisionLevel};{}$\6
${}\|f\MG\\{decisions}.\\{data}[\|v]\K\|f\MG\\{decisionLevel};{}$\6
${}\\{fslog}(\|f,\39\.{"solve"},\39\T{2},\39\.{"branched\ on\ \%ji\\n"},\39%
\|l);{}$\6
\&{break};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{assert}(\|l\I\T{0}\V\\{bh\_size}(\|f)\E\T{0});{}$\6
\4${}\}{}$\C{Added by SEAN!!!}\2\6
\&{if} ${}(\|f\MG\\{MakeDecision\_hook}){}$\1\5
${}\|f\MG\\{MakeDecision\_hook}{}$((\&{uintptr\_t} ${}{*}){}$ \|f${}\MG\\{conf}%
\MG\\{user});{}$\2\6
\&{return} \|l;\6
\4${}\}{}$\2\par
\fi

\M{113}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{literal} \\{funcsatMakeDecision}(\&{funcsat} ${}{*},\39{}$\&{void}
${}{*}){}$;\par
\fi

\M{114}Because the variable ordering is dynamic, we can choose strategic points
at
which to ``bump'' the priority of a variable. So if at some point during
solving
we decide that a given variable is a but more important, we call
\PB{\\{varBumpScore}}.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{inline} \&{void} \\{varBumpScore}(\&{funcsat} ${}{*}\|f,\39{}$\&{variable} %
\|v)\1\1\2\2\6
${}\{{}$\1\6
\&{double} ${}{*}\\{activity\_v}\K\\{bh\_var2act}(\|f,\39\|v);{}$\6
\&{double} \\{origActivity}${},{}$ \\{activity};\7
${}\\{origActivity}\K\\{activity}\K{*}\\{activity\_v};{}$\6
\&{if} ${}((\\{activity}\MRL{+{\K}}\|f\MG\\{varInc})>\T{1\_100}){}$\5
${}\{{}$\C{ rescale }\1\6
\&{for} (\&{variable} \|j${}\K\T{1};{}$ ${}\|j\Z\|f\MG\\{numVars};{}$ ${}\|j%
\PP){}$\5
${}\{{}$\1\6
\&{double} ${}{*}\|m\K\\{bh\_var2act}(\|f,\39\|j);{}$\7
${}\\{fslog}(\|f,\39\.{"decide"},\39\T{5},\39\.{"old\ activity\ \%f,\ re}\)%
\.{scaling\\n"},\39{*}\|m);{}$\6
${}{*}\|m\MRL{*{\K}}\T{1\_-100};{}$\6
\4${}\}{}$\2\7
\&{double} \\{oldVarInc}${}\K\|f\MG\\{varInc};{}$\7
${}\|f\MG\\{varInc}\MRL{*{\K}}\T{1\_-100};{}$\6
${}\\{fslog}(\|f,\39\.{"decide"},\39\T{1},\39\.{"setting\ varInc\ from}\)\.{\ %
\%f\ to\ \%f\\n"},\39\\{oldVarInc},\39\|f\MG\\{varInc});{}$\6
${}\\{activity}\MRL{*{\K}}\T{1\_-100};{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{bh\_is\_in\_heap}(\|f,\39\|v)){}$\5
${}\{{}$\1\6
${}\\{bh\_increase\_activity}(\|f,\39\|v,\39\\{activity});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}{*}\\{activity\_v}\K\\{activity};{}$\6
\4${}\}{}$\2\6
${}\\{fslog}(\|f,\39\.{"decide"},\39\T{5},\39\.{"bumped\ \%ju\ from\ \%.3}\)%
\.{0f\ to\ \%.30f\\n"},\39\|v,\39\\{origActivity},\39{*}\\{activity\_v});{}$\6
\4${}\}{}$\2\par
\fi

\M{115}Activities are stored as \PB{\&{double}}s. Comparing them always returns
1 if the
first activity is {\it more active} than the second (and therefore should be
branched on first).

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{int} \\{activity\_compare}(\&{double} \|x${},\39{}$%
\&{double} \|y)\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\|x>\|y){}$\1\5
\&{return} \T{1};\2\6
\&{else} \&{if} ${}(\|x<\|y){}$\1\5
\&{return} ${}{-}\T{1};{}$\2\6
\&{else}\1\5
\&{return} \T{0};\2\6
\4${}\}{}$\2\par
\fi

\M{116}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{int} \\{activity\_compare}(\&{double} \|x${},\39{}$%
\&{double} \|y);\par
\fi

\N{3}{117}Binary decision variable heap. This basic data structure is what
Minisat
uses. This implementation, however, is original. The idea is pretty simple.

The heap (\PB{$\|f\MG\\{binvar\_heap}$}) is represented as a single array of
nodes. Each
possible heap node is stored at some index of an array, {\it whether it's in
the
heap or not}. If the node is not in the heap, it is stored after the
\PB{$\|f\MG\\{binvar\_heap\_size}$} index. If the node is in the heap, its
children are stored
at known offsets of the parent. We can do this since we know the array must be
of size \PB{$\|f\MG\\{numVars}$}. The heap invariant is that a heap node is no
smaller than
each of its children.

Each heap node is 16 bytes:
\numberedlist
\li a \PB{\&{double}} priority (can we make this a \PB{\&{float}}?)
\li a \PB{\&{variable}} variable (needed to find out which var to return on a %
\PB{\\{bh\_pop}})
\endnumberedlist

The auxiliary array of {\it positions} (\PB{$\|f\MG\\{binvar\_pos}$}) maps a %
\PB{\&{variable}} to
its current position in the heap. This way when we adjust a \PB{\&{variable}}'s
priority we can easily find the variable in the heap.  The \PB{$\|f\MG\\{binvar%
\_pos}$}
invariant is that \PB{$\|f\MG\\{binvar\_pos}[\|v]$} is the index of the heap
node corresponding
to variable \PB{\|v}.

\Y\B\4\X38:Internal types\X${}\mathrel+\E{}$\6
\&{struct} \&{bh\_node} ${}\{{}$\1\6
\&{variable} \\{var};\6
\&{double} \\{act};\2\6
${}\}{}$;\par
\fi

\M{118}Returns the index into \PB{$\|f\MG\\{binvar\_heap}$} that gives the
current variable's
priority.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{uintmax\_t} \\{bh\_var2pos}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{variable} \|v)\1\1\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{binvar\_pos}[\|v];{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{bool} \\{bh\_is\_in\_heap}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{variable} \|v)\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\\{bh\_var2pos}(\|f,\39\|v)>\T{0});{}$\6
\&{return} \\{bh\_var2pos}${}(\|f,\39\|v)\Z\|f\MG\\{binvar\_heap\_size};{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{bool} \\{bh\_node\_is\_in\_heap}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{struct} \&{bh\_node} ${}{*}\|n){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\|n\G\|f\MG\\{binvar\_heap});{}$\6
\&{return} ${}(\&{uintmax\_t})(\|n-\|f\MG\\{binvar\_heap})\Z\|f\MG\\{binvar%
\_heap\_size};{}$\6
\4${}\}{}$\2\par
\fi

\M{119}\PB{\\{bh\_increase\_activity}} needs to adjust the priority---the
following function
is used for this.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{double} ${}{*}{}$\\{bh\_var2act}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{variable} \|v)\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}{\AND}\|f\MG\\{binvar\_heap}[\\{bh\_var2pos}(\|f,\39\|v)].%
\\{act};{}$\6
\4${}\}{}$\2\par
\fi

\M{120}The following functions allow one to traverse heap: to obtain the
children and
the parent of a given node. Note, as with other \PB{\&{variable}} data
structures, the
first node of the heap is at index 1, leaving index 0 unused.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{struct} \&{bh\_node} ${}{*}{}$\\{bh\_top}(\&{funcsat}
${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{binvar\_heap}+\T{1};{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{struct} \&{bh\_node} ${}{*}{}$\\{bh\_bottom}(%
\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{binvar\_heap}+\|f\MG\\{binvar\_heap\_size};{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{bool} \\{bh\_is\_top}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{struct} \&{bh\_node} ${}{*}\|v){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{bh\_top}(\|f)${}\E\|v;{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{struct} \&{bh\_node} ${}{*}{}$\\{bh\_left}(\&{funcsat}
${}{*}\|f,\39{}$\&{struct} \&{bh\_node} ${}{*}\|v){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{binvar\_heap}+(\T{2}*(\|v-\|f\MG\\{binvar\_heap}));{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{struct} \&{bh\_node} ${}{*}{}$\\{bh\_right}(%
\&{funcsat} ${}{*}\|f,\39{}$\&{struct} \&{bh\_node} ${}{*}\|v){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{binvar\_heap}+(\T{2}*(\|v-\|f\MG\\{binvar\_heap})+%
\T{1});{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{struct} \&{bh\_node} ${}{*}{}$\\{bh\_parent}(%
\&{funcsat} ${}{*}\|f,\39{}$\&{struct} \&{bh\_node} ${}{*}\|v){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{binvar\_heap}+((\|v-\|f\MG\\{binvar\_heap})/\T{2});{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{uintmax\_t} \\{bh\_size}(\&{funcsat} ${}{*}\|f){}$\1\1%
\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{binvar\_heap\_size};{}$\6
\4${}\}{}$\2\par
\fi

\M{121}Getting the node location in the heap for an arbitrary \PB{\&{variable}}
is
accomplished with the help of \PB{$\|f\MG\\{binvar\_pos}$}, which records
exactly that
information.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{struct} \&{bh\_node} ${}{*}{}$\\{bh\_node\_get}(%
\&{funcsat} ${}{*}\|f,\39{}$\&{variable} \|v)\1\1\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{binvar\_heap}+\|f\MG\\{binvar\_pos}[\|v];{}$\6
\4${}\}{}$\2\par
\fi

\M{122}decls
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{uintmax\_t} \\{bh\_var2pos}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{variable} \|v);\6
\&{static} \&{inline} \&{bool} \\{bh\_is\_in\_heap}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{variable} \|v);\6
\&{static} \&{inline} \&{bool} \\{bh\_node\_is\_in\_heap}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{struct} \&{bh\_node} ${}{*});{}$\6
\&{static} \&{inline} \&{double} ${}{*}{}$\\{bh\_var2act}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{variable} \|v);\6
\&{static} \&{inline} \&{struct} \&{bh\_node} ${}{*}{}$\\{bh\_top}(\&{funcsat}
${}{*}\|f);{}$\6
\&{static} \&{inline} \&{struct} \&{bh\_node} ${}{*}{}$\\{bh\_bottom}(%
\&{funcsat} ${}{*}\|f);{}$\6
\&{static} \&{inline} \&{bool} \\{bh\_is\_top}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{struct} \&{bh\_node} ${}{*}\|v);{}$\6
\&{static} \&{inline} \&{struct} \&{bh\_node} ${}{*}{}$\\{bh\_left}(\&{funcsat}
${}{*}\|f,\39{}$\&{struct} \&{bh\_node} ${}{*}\|v);{}$\6
\&{static} \&{inline} \&{struct} \&{bh\_node} ${}{*}{}$\\{bh\_right}(%
\&{funcsat} ${}{*}\|f,\39{}$\&{struct} \&{bh\_node} ${}{*}\|v);{}$\6
\&{static} \&{inline} \&{struct} \&{bh\_node} ${}{*}{}$\\{bh\_parent}(%
\&{funcsat} ${}{*}\|f,\39{}$\&{struct} \&{bh\_node} ${}{*}\|v);{}$\6
\&{static} \&{inline} \&{uintmax\_t} \\{bh\_size}(\&{funcsat} ${}{*}\|f);{}$\6
\&{static} \&{inline} \&{variable} \\{bh\_pop}(\&{funcsat} ${}{*}\|f);{}$\6
\&{static} \&{inline} \&{void} \\{bh\_insert}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{variable} \|v);\par
\fi

\M{123}Insert. After incrementing the heap size, the to insert is placed at the
last
free location of the heap. Then it gets bubbled up to the location where the
heap invariant holds again.

Insertion and deletion need often to swap two elements of the heap. \PB{\\{bh%
\_swap}}
helps with this.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{bh\_swap}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{struct} \&{bh\_node} ${}{*}{*}\|x,\39{}$\&{struct} \&{bh\_node} ${}{*}{*}%
\|y){}$\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{bh\_node} \\{tmp}${}\K{*}{*}\|x,{}$ ${}{*}\\{tmpp}\K{*}\|x;{}$\7
${}{*}{*}\|x\K{*}{*}\|y,\39{*}{*}\|y\K\\{tmp};{}$\6
${}{*}\|x\K{*}\|y,\39{*}\|y\K\\{tmpp}{}$;\C{ swap the pointers, too }\6
${}\|f\MG\\{binvar\_pos}[({*}\|x)\MG\\{var}]\K{*}\|x-\|f\MG\\{binvar\_heap};{}$%
\6
${}\|f\MG\\{binvar\_pos}[({*}\|y)\MG\\{var}]\K{*}\|y-\|f\MG\\{binvar\_heap};{}$%
\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{void} \\{bh\_bubble\_up}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{struct} \&{bh\_node} ${}{*}\|e){}$\1\1\2\2\6
${}\{{}$\1\6
\&{while} ${}(\R\\{bh\_is\_top}(\|f,\39\|e)){}$\5
${}\{{}$\1\6
\&{struct} \&{bh\_node} ${}{*}\|p\K\\{bh\_parent}(\|f,\39\|e);{}$\7
\&{if} ${}(\\{activity\_compare}(\|p\MG\\{act},\39\|e\MG\\{act})<\T{0}){}$\5
${}\{{}$\1\6
${}\\{bh\_swap}(\|f,\39{\AND}\|p,\39{\AND}\|e);{}$\6
\4${}\}{}$\2\6
\&{else}\1\5
\&{break};\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{void} \\{bh\_insert}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{variable} \|v)\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\\{bh\_size}(\|f)+\T{1}\Z\|f\MG\\{numVars});{}$\6
${}\\{assert}(\\{bh\_var2pos}(\|f,\39\|v)>\|f\MG\\{binvar\_heap\_size});{}$\7
\&{struct} \&{bh\_node} ${}{*}\\{node}\K{\AND}\|f\MG\\{binvar\_heap}[\\{bh%
\_var2pos}(\|f,\39\|v)];{}$\7
${}\\{assert}(\\{node}\MG\\{var}\E\|v);{}$\6
${}\|f\MG\\{binvar\_heap\_size}\PP;{}$\7
\&{struct} \&{bh\_node} ${}{*}\\{last}\K{\AND}\|f\MG\\{binvar\_heap}[\|f\MG%
\\{binvar\_heap\_size}];{}$\7
${}\\{bh\_swap}(\|f,\39{\AND}\\{node},\39{\AND}\\{last});{}$\6
${}\\{bh\_bubble\_up}(\|f,\39\\{node});{}$\6
${}\\{assert}(\|f\MG\\{binvar\_heap}[\\{bh\_var2pos}(\|f,\39\|v)].\\{var}\E%
\|v){}$;\C{ invariant }\6
\4${}\}{}$\2\par
\fi

\M{124}Extract Max. We take the bottom element of the heap and replace the top
with
it. Then we bubble it down until the heap property holds again.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{bh\_bubble\_down}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{struct} \&{bh\_node} ${}{*}\|e){}$\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{bh\_node} ${}{*}\|l,{}$ ${}{*}\|r;{}$\7
\&{goto} \\{bh\_bd\_begin};\6
\&{while} ${}(\\{bh\_node\_is\_in\_heap}(\|f,\39\|l)){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{bh\_node\_is\_in\_heap}(\|f,\39\|r)){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{activity\_compare}(\|l\MG\\{act},\39\|r\MG\\{act})<\T{0}){}$\1\5
${}\|l\K\|r{}$;\C{ put max child in \PB{\|l} }\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{activity\_compare}(\|e\MG\\{act},\39\|l\MG\\{act})<\T{0}){}$\5
${}\{{}$\1\6
${}\\{bh\_swap}(\|f,\39{\AND}\|e,\39{\AND}\|l);{}$\6
\4${}\}{}$\2\6
\&{else}\1\5
\&{break};\2\6
\4\\{bh\_bd\_begin}:\5
${}\|l\K\\{bh\_left}(\|f,\39\|e),\39\|r\K\\{bh\_right}(\|f,\39\|e);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{variable} \\{bh\_pop}(\&{funcsat} ${}{*}\|f){}$\1\1\2%
\2\6
${}\{{}$\1\6
${}\\{assert}(\|f\MG\\{binvar\_heap\_size}>\T{0});{}$\7
\&{struct} \&{bh\_node} ${}{*}\\{top}\K\\{bh\_top}(\|f);{}$\6
\&{struct} \&{bh\_node} ${}{*}\\{bot}\K\\{bh\_bottom}(\|f);{}$\7
${}\\{bh\_swap}(\|f,\39{\AND}\\{top},\39{\AND}\\{bot});{}$\6
${}\|f\MG\\{binvar\_heap\_size}\MM;{}$\6
${}\\{bh\_bubble\_down}(\|f,\39\\{bh\_top}(\|f));{}$\6
\&{return} \\{top}${}\MG\\{var};{}$\6
\4${}\}{}$\2\par
\fi

\M{125}decls
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{bh\_increase\_activity}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{variable} \|v${},\39{}$\&{double} \\{act\_new})\1\1\2\2\6
${}\{{}$\1\6
\&{double} ${}{*}\\{act\_curr}\K\\{bh\_var2act}(\|f,\39\|v);{}$\6
\&{struct} \&{bh\_node} ${}{*}\|n\K\\{bh\_node\_get}(\|f,\39\|v);{}$\7
${}\\{assert}(\|n\MG\\{var}\E\|v);{}$\6
${}\\{assert}({*}\\{act\_curr}\Z\\{act\_new});{}$\6
${}{*}\\{act\_curr}\K\\{act\_new};{}$\6
${}\\{bh\_bubble\_up}(\|f,\39\|n);{}$\6
\4${}\}{}$\2\par
\fi

\M{126}decl
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{bh\_increase\_activity}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{uintmax\_t} \\{node\_pos}${},\39{}$\&{double} \\{new\_act});\par
\fi

\M{127}we should check the heap property!
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{void} \\{bh\_check\_node}(\&{funcsat} ${}{*}\|f,\39{}$\&{struct} %
\&{bh\_node} ${}{*}\|x){}$\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{bh\_node} ${}{*}\|l\K\\{bh\_left}(\|f,\39\|x),{}$ ${}{*}\|r\K%
\\{bh\_right}(\|f,\39\|x);{}$\7
\&{if} ${}(\\{bh\_node\_is\_in\_heap}(\|f,\39\|l)){}$\5
${}\{{}$\1\6
${}\\{assert}(\\{activity\_compare}(\|l\MG\\{act},\39\|x\MG\\{act})\Z\T{0});{}$%
\6
${}\\{bh\_check\_node}(\|f,\39\|l);{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{bh\_node\_is\_in\_heap}(\|f,\39\|r)){}$\5
${}\{{}$\1\6
${}\\{assert}(\\{activity\_compare}(\|r\MG\\{act},\39\|x\MG\\{act})\Z\T{0});{}$%
\6
${}\\{bh\_check\_node}(\|f,\39\|r);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{static} \&{void} \\{bh\_check}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{bh\_node} ${}{*}\\{root}\K\\{bh\_top}(\|f);{}$\7
\&{if} ${}(\\{bh\_node\_is\_in\_heap}(\|f,\39\\{root})){}$\5
${}\{{}$\1\6
${}\\{bh\_check\_node}(\|f,\39\\{root});{}$\6
\4${}\}{}$\2\6
\&{for} (\&{uintmax\_t} \|i${}\K\T{1};{}$ ${}\|i<\|f\MG\\{numVars};{}$ ${}\|i%
\PP){}$\5
${}\{{}$\1\6
${}\\{assert}(\\{bh\_node\_get}(\|f,\39\|i)\MG\\{var}\E\|i);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{128}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{void} \\{bh\_check}(\&{funcsat} ${}{*}\|f){}$;\par
\fi

\M{129}Initializing is easy.
\Y\B\4\X41:Initialize funcsat type\X${}\mathrel+\E{}$\6
$\.{FS\_CALLOC}(\|f\MG\\{binvar\_heap},\39\T{2},\39{}$\&{sizeof} ${}({*}\|f\MG%
\\{binvar\_heap}));{}$\6
${}\.{FS\_CALLOC}(\|f\MG\\{binvar\_pos},\39\T{2},\39{}$\&{sizeof} ${}({*}\|f\MG%
\\{binvar\_pos}));{}$\6
${}\|f\MG\\{binvar\_heap\_size}\K\T{0}{}$;\par
\fi

\M{130}Destroying.
\Y\B\4\X42:Destroy funcsat type\X${}\mathrel+\E{}$\6
$\\{free}(\|f\MG\\{binvar\_heap});{}$\6
${}\\{free}(\|f\MG\\{binvar\_pos});{}$\6
${}\|f\MG\\{binvar\_heap\_size}\K\T{0}{}$;\par
\fi

\M{131}Allocating is easy.
\Y\B\4\X104:Resize internal data structures up to new \PB{\\{numVars}}\X${}%
\mathrel+\E{}$\6
$\.{FS\_REALLOC}(\|f\MG\\{binvar\_heap},\39\\{numVars}+\T{1},\39{}$\&{sizeof}
${}({*}\|f\MG\\{binvar\_heap}));{}$\6
${}\.{FS\_REALLOC}(\|f\MG\\{binvar\_pos},\39\\{numVars}+\T{1},\39{}$\&{sizeof}
${}({*}\|f\MG\\{binvar\_pos})){}$;\par
\fi

\M{132}Initializing each activity is also easy.
\Y\B\4\X72:Incrementally resize internal data structures up to new \PB{%
\\{numVars}}\X${}\mathrel+\E{}$\6
$\|f\MG\\{binvar\_heap}[\|v].\\{var}\K\|v;{}$\6
${}\|f\MG\\{binvar\_heap}[\|v].\\{act}\K\|f\MG\\{conf}\MG%
\\{getInitialActivity}({\AND}\|v);{}$\6
${}\|f\MG\\{binvar\_pos}[\|v]\K\|v;{}$\6
${}\\{bh\_insert}(\|f,\39\|v);{}$\6
${}\\{assert}(\|f\MG\\{binvar\_pos}[\|v]\I\T{0}){}$;\par
\fi

\M{133}Print the heap.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{void} \\{bh\_padding}(\&{funcsat} ${}{*}\|f,\39{}$\&{const} %
\&{char} ${}{*}\|s,\39{}$\&{int} \|x)\1\1\2\2\6
${}\{{}$\1\6
\&{while} ${}(\|x\MM>\T{0}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\%s"},\39\|s);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{static} \&{bool} \\{bh\_print\_levels}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE}
${}{*}\\{dotfile},\39{}$\&{struct} \&{bh\_node} ${}{*}\|r,\39{}$\&{int} %
\\{level})\1\1\2\2\6
${}\{{}$\1\6
\\{assert}(\|r);\6
\&{if} ${}(\\{bh\_node\_is\_in\_heap}(\|f,\39\|r)){}$\5
${}\{{}$\1\6
\&{bool} \\{lf}${},{}$ \\{ri};\7
${}\\{lf}\K\\{bh\_print\_levels}(\|f,\39\\{dotfile},\39\\{bh\_left}(\|f,\39%
\|r),\39\\{level}+\T{1});{}$\6
${}\\{ri}\K\\{bh\_print\_levels}(\|f,\39\\{dotfile},\39\\{bh\_right}(\|f,\39%
\|r),\39\\{level}+\T{1});{}$\6
\&{if} (\\{lf})\1\5
${}\\{fprintf}(\\{dotfile},\39\.{"\%ju\ ->\ \%ju\ [label=\\}\)\.{"L\\"];\\n"},%
\39\|r\MG\\{var},\39\\{bh\_left}(\|f,\39\|r)\MG\\{var});{}$\2\6
\&{if} (\\{ri})\1\5
${}\\{fprintf}(\\{dotfile},\39\.{"\%ju\ ->\ \%ju\ [label=\\}\)\.{"R\\"];\\n"},%
\39\|r\MG\\{var},\39\\{bh\_right}(\|f,\39\|r)\MG\\{var});{}$\2\6
${}\\{fprintf}(\\{dotfile},\39\.{"\%ju\ [label=\\"\%ju\%s,}\)\.{\ \%.1f\\"];%
\\n"},\39\|r\MG\\{var},\39\|r\MG\\{var},\39(\\{funcsatValue}(\|f,\39\|r\MG%
\\{var})\E\\{true}\?\.{"T"}:(\\{funcsatValue}(\|f,\39\|r\MG\\{var})\E\\{false}%
\?\.{"F"}:\.{"?"})),\39\|r\MG\\{act});{}$\6
\&{return} \\{true};\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{return} \\{false};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{static} \&{void} \\{bh\_print}(\&{funcsat} ${}{*}\|f,\39{}$\&{const} %
\&{char} ${}{*}\\{path},\39{}$\&{struct} \&{bh\_node} ${}{*}\|r){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\R\|r){}$\1\5
${}\|r\K\\{bh\_top}(\|f);{}$\2\7
\&{FILE} ${}{*}\\{dotfile};{}$\7
\&{if} ${}(\NULL\E(\\{dotfile}\K\\{fopen}(\\{path},\39\.{"w"}))){}$\1\5
${}\\{perror}(\.{"fopen"}),\39\\{exit}(\T{1});{}$\2\6
${}\\{fprintf}(\\{dotfile},\39\.{"digraph\ G\ \{\\n"});{}$\6
${}\\{bh\_print\_levels}(\|f,\39\\{dotfile},\39\|r,\39\T{0});{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"\}\\n"});{}$\6
\&{if} ${}(\T{0}\I\\{fclose}(\\{dotfile})){}$\1\5
\\{perror}(\.{"fclose"});\2\6
${}\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\\n"});{}$\6
\4${}\}{}$\2\par
\fi

\M{134}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{void} \\{bh\_print}(\&{funcsat} ${}{*}\|f,\39{}$\&{const} %
\&{char} ${}{*}\\{path},\39{}$\&{struct} \&{bh\_node} ${}{*}\|r){}$;\par
\fi

\N{3}{135}Backtracking.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{backtrack}(\&{funcsat} ${}{*}\|f,\39{}$\&{variable} %
\\{newLevel}${},\39{}$\&{head\_tail} ${}{*}\\{facts},\39{}$\&{bool} %
\\{isRestart})\1\1\2\2\6
${}\{{}$\1\6
\&{head\_tail} \\{restart\_facts};\7
\&{if} (\\{isRestart})\5
${}\{{}$\1\6
${}\\{assert}(\\{newLevel}\E\T{0\$U\$L}),\39\\{assert}(\R\\{facts});{}$\6
${}\\{facts}\K{\AND}\\{restart\_facts};{}$\6
${}\\{head\_tail\_clear}({\AND}\\{restart\_facts});{}$\6
\4${}\}{}$\2\6
\&{while} ${}(\|f\MG\\{decisionLevel}\I\\{newLevel}){}$\1\5
${}\\{trailPop}(\|f,\39\\{facts});{}$\2\6
\&{if} (\\{isRestart})\5
${}\{{}$\1\6
\&{literal} \\{top};\C{Added by SEAN!!!}\7
\&{if} ${}(\|f\MG\\{Backtrack\_hook}){}$\1\5
${}\|f\MG\\{Backtrack\_hook}{}$((\&{uintptr\_t} ${}{*}){}$ \|f${}\MG\\{conf}\MG%
\\{user},\39\T{0});{}$\2\6
\&{if} ${}(\|f\MG\\{MakeDecision\_hook}){}$\1\5
${}\|f\MG\\{MakeDecision\_hook}{}$((\&{uintptr\_t} ${}{*}){}$ \|f${}\MG\\{conf}%
\MG\\{user});{}$\2\6
${}\|f\MG\\{propq}\K\T{0};{}$\6
${}\\{restore\_facts}(\|f,\39\\{facts});{}$\6
\&{if} ${}(\|f\MG\\{trail}.\\{size}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{top}\K\\{trailPeek}(\|f);{}$\6
${}\\{head\_tail\_append}(\|f,\39{\AND}\|f\MG\\{unit\_facts}[\\{fs\_lit2var}(%
\\{top})],\39\\{facts});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{static} \&{void} \\{restore\_facts}(\&{funcsat} ${}{*}\|f,\39{}$\&{head%
\_tail} ${}{*}\\{facts}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{uintptr\_t} \\{prev}${},{}$ \\{curr}${},{}$ \\{next};\7
\&{for\_head\_tail} ${}(\|f,\39\\{facts},\39\\{prev},\39\\{curr},\39%
\\{next}){}$\5
${}\{{}$\C{ if the clause was subsumed, it could be here but not learned }\1\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39%
\\{curr});{}$\7
${}\\{assert}(\|h\MG\\{sz}\G\T{1});{}$\6
\&{if} ${}(\|h\MG\\{sz}\E\T{1}){}$\5
${}\{{}$\1\6
\&{literal} \|p${}\K\|h\MG\\{lits}[\T{0}];{}$\6
\&{mbool} \\{val}${}\K\\{funcsatValue}(\|f,\39\|p);{}$\7
${}\\{assert}(\\{val}\I\\{false});{}$\6
\&{if} ${}(\\{val}\E\\{unknown}){}$\5
${}\{{}$\1\6
${}\\{trailPush}(\|f,\39\|p,\39\\{reason\_info\_mk}(\|f,\39\\{curr}));{}$\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{5},\39\.{"\ =>\ \%ji\\n"},\39\|p);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{head\_tail\_iter\_rm}(\|f,\39\\{facts},\39\\{prev},\39\\{curr},\39%
\\{next});{}$\6
${}\\{addWatchUnchecked}(\|f,\39\\{curr});{}$\6
\8\#\&{ifndef} \.{NDEBUG}\6
\\{watches\_check}(\|f);\6
\8\#\&{endif}\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{136}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{void} \\{restore\_facts}(\&{funcsat} ${}{*}\|f,\39{}$\&{head%
\_tail} ${}{*}\\{facts}){}$;\par
\fi

\N{2}{137}Clause learning.\definexref{pg-clause-learn}{\folio}{page} \funcsat\
learns
unique implication point (UIP) clauses. It can learn any number of them,
starting with the first. The top-level procedure is \PB{\\{analyze\_conflict}},
which
assumes:

\numberedlist

\li the solver is in conflict (\PB{$\|f\MG\\{conflict\_clause}$} is set)

\li the literals in \PB{$\|f\MG\\{conflict\_clause}$} are all \PB{\\{false}}
(under \PB{\\{funcsatValue}})

\endnumberedlist

Initially the conflict clause is unset.
\Y\B\4\X41:Initialize funcsat type\X${}\mathrel+\E{}$\6
$\|f\MG\\{conflict\_clause}\K\.{NO\_CLS}{}$;\par
\fi

\M{138}This function is just a wrapper around the real work. It makes sure that
we
approximate how much of the space we've explored and returns whether we have
proven the problem unsat to the caller. The real work is done in \PB{\\{find%
\_uips}}.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{bool} \\{analyze\_conflict}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_iter} \\{it};\6
\&{variable} \|i${},{}$ \|c${}\K\T{0}{}$;\C{ c -- count current-decision-level
literals in the                       learned clause }\6
\&{literal} ${}{*}\|p;{}$\6
\&{head\_tail} \\{facts};\6
\&{literal} \\{uipLit}${}\K\T{0};{}$\7
${}\PP\|f\MG\\{numConflicts};{}$\6
${}\\{assert}(\|f\MG\\{uipClause}.\\{size}\E\T{0});{}$\6
${}\\{clause\_iter\_init}(\|f,\39\|f\MG\\{conflict\_clause},\39{\AND}%
\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
${}\\{clausePush}({\AND}\|f\MG\\{uipClause},\39{*}\|p);{}$\6
\4${}\}{}$\2\6
\8\#\&{if} ${}\R{}$\&{defined} (\.{NDEBUG})${}\W{}$\&{defined} (\.{PRINT\_IMPL%
\_GRAPH})\6
${}\\{print\_dot\_impl\_graph}(\|f,\39{\AND}\|f\MG\\{uipClause});{}$\6
\8\#\&{endif}\6
${}\\{head\_tail\_clear}({\AND}\\{facts});{}$\6
${}\\{litpos\_clear}({\AND}\|f\MG\\{litpos\_uip});{}$\6
\\{litpos\_init\_from\_uip\_clause}(\|f);\6
\&{for\_clause} ${}(\|p,\39{\AND}\|f\MG\\{uipClause}){}$\1\6
\&{if} ((\&{uintmax\_t}) \\{levelOf}${}(\|f,\39\\{fs\_lit2var}({*}\|p))\E\|f\MG%
\\{decisionLevel}){}$\1\5
${}\|c\PP;{}$\2\2\7
\&{int64\_t} \\{entrydl}${}\K{}$(\&{int64\_t}) \|f${}\MG\\{decisionLevel};{}$\6
\8\#\&{ifndef} \.{NDEBUG}\7
\\{watches\_check}(\|f);\6
\8\#\&{endif}\7
\&{bool} \\{isUnsat}${}\K\\{find\_uips}(\|f,\39\|c,\39{\AND}\\{facts},\39{\AND}%
\\{uipLit});{}$\7
\&{if} (\\{isUnsat})\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"solve"},\39\T{1},\39\.{"find\_uips\ returned\ }\)%
\.{isUnsat\\n"});{}$\6
${}\|f\MG\\{conflict\_clause}\K\.{NO\_CLS};{}$\6
\&{return} \\{false};\6
\4${}\}{}$\2\6
${}\|f\MG\\{conf}\MG\\{decayAfterConflict}(\|f);{}$\6
${}\|f\MG\\{conflict\_clause}\K\.{NO\_CLS};{}$\6
${}\|f\MG\\{uipClause}.\\{size}\K\T{0};{}$\6
\8\#\&{ifndef} \.{NDEBUG}\6
\\{watches\_check}(\|f);\6
\8\#\&{endif}\6
\&{if} ${}(\R\\{propagateFacts}(\|f,\39{\AND}\\{facts},\39\\{uipLit})){}$\5
${}\{{}$\1\6
\&{return} \\{analyze\_conflict}(\|f);\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{return} \\{true};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{139}\PB{\\{find\_uips}} does the heavy lifting of forming the \UIP\ clauses.
Returns
\PB{\\{true}} only if the \SAT\ instance is \UNSAT.

If we don't learn all the \UIP s that we could then there may be literals after
the decision literal on the trail. So we need to pop them; finally we pop the
decision literal.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{bool} \\{find\_uips}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintmax\_t} \|c${},%
\39{}$\&{head\_tail} ${}{*}\\{facts},\39{}$\&{literal} ${}{*}\\{lit\_uip}){}$\1%
\1\2\2\6
${}\{{}$\1\6
\&{uint32\_t} \\{num\_uips\_learned}${}\K\T{0},{}$ \\{num\_uips\_to\_learn}${}%
\K\|f\MG\\{conf}\MG\\{numUipsToLearn};{}$\6
\&{uint32\_t} \\{num\_resolutions}${}\K\T{0};{}$\6
\&{literal} \|p;\7
\&{fs\_ifdbg} ${}(\|f,\39\.{"find\_uips"},\39\T{1}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"find\_uips"},\39\T{1},\39\.{"conflict@\%ju\ (\#\%"}%
\\{PRIu64}\.{")\ with\ "},\39\|f\MG\\{decisionLevel},\39\|f\MG%
\\{numConflicts});{}$\6
${}\\{fs\_clause\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39{\AND}\|f\MG%
\\{uipClause});{}$\6
${}\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
${}\\{dopen}(\|f,\39\.{"find\_uips"});{}$\6
\&{do}\5
${}\{{}$\1\6
\X140:Find the next \UIP\ clause\X\6
\4${}\}{}$\2\5
\&{while} ${}(\\{num\_uips\_learned}<\\{num\_uips\_to\_learn});{}$\6
${}{*}\\{lit\_uip}\K\|p;{}$\6
\&{while} ${}(\R\\{isDecision}(\|f,\39\\{fs\_lit2var}(\\{trailPeek}(\|f)))){}$%
\1\5
${}\\{trailPop}(\|f,\39\\{facts});{}$\2\6
${}\|p\K\\{trailPop}(\|f,\39\\{facts}){}$;\C{ pop decision literal }\6
${}\\{fslog}(\|f,\39\.{"find\_uips"},\39\T{5},\39\.{"learned\ \%"}\\{PRIu32}%
\.{"\ UIPs\\n"},\39\\{num\_uips\_learned});{}$\6
${}\\{dclose}(\|f,\39\.{"find\_uips"});{}$\6
${}\\{fslog}(\|f,\39\.{"find\_uips"},\39\T{5},\39\.{"done\\n"});{}$\6
\&{return} \\{false};\6
\4${}\}{}$\2\par
\fi

\M{140}Initially, there might be some junk on the trail that hasn't been used
for
propagation yet. We need to undo trail assignments until the top of the trail
is
in the clause. This allows us to pick the most recently inferred literal and
resolve it out of the conflict clause.

After a single resolution step, one a few things has happened:

\orderedlist

\li In the common case we will have added some new literals from the current
level, keeping \PB{$\|c>\T{1}$}. We will want to keep resolving. However, it
often happens
that there are literals on the trail that don't occur in \PB{$\|f\MG%
\\{uipClause}$} (the
clause we're building). We want to ignore those so we need to pop literals from
the trail until we find one that's in the conflict clause.

\li In the \UIP\ case, we find a \UIP: \PB{$\|c\E\T{1}$} and we need to add the
new \UIP\ clause
to the clause database. In this case it's also desirable to pop literals from
the trail until we find one in the conflict clause.

\li It can happen that we resolve all current-level literals out and, although
the clause isn't empty, \PB{$\|c\E\T{0}$}. This means a decision level really
wasn't
responsible for the current conflict and we need to backtrack over it until
we find something in the conflict clause (I think?).

\endorderedlist

During learning, there are a few conditions which mean we proved the problem
\UNSAT: (\osf{1}) if we backtrack to decision level 0 or (\osf{2}) if the \UIP\
clause becomes empty. We check these in the loop conditions.

Finally, if our \UIP\ literal is a decision variable, we need to stop learning
\UIP s -- so we check for that at the very end of this section.
\Y\B\4\X140:Find the next \UIP\ clause\X${}\E{}$\6
\&{while} ${}(\R\\{litpos\_contains}({\AND}\|f\MG\\{litpos\_uip},\39\|p\K%
\\{trailPeek}(\|f))){}$\1\5
${}\\{trailPop}(\|f,\39\\{facts});{}$\2\6
\&{do}\5
${}\{{}$\1\6
\&{uintptr\_t} \\{ix\_reason};\6
\&{uintmax\_t} \\{num\_new\_lits};\C{ new current-level lits }\7
\X141:Check \UIP\ learning invariants if \PB{\.{NDEBUG}} is not present\X\6
${}\\{assert}(\\{litpos\_contains}({\AND}\|f\MG\\{litpos\_uip},\39\|p));{}$\6
${}\\{ix\_reason}\K\\{getReason}(\|f,\39\|p);{}$\6
${}\\{num\_new\_lits}\K\\{pop\_and\_resolve}(\|f,\39\\{ix\_reason},\39%
\\{facts});{}$\6
${}\\{num\_resolutions}\PP;{}$\6
${}\|c\K\|c-\T{1}+\\{num\_new\_lits};{}$\6
\&{while} ${}(\|f\MG\\{trail}.\\{size}>\T{0}\W\R\\{litpos\_contains}({\AND}\|f%
\MG\\{litpos\_uip},\39\|p\K\\{trailPeek}(\|f))){}$\1\5
${}\\{trailPop}(\|f,\39\\{facts});{}$\2\6
\&{if} ${}(\|c\E\T{0}){}$\5
${}\{{}$\C{ reset count cuz we backtracked }\1\6
\&{literal} ${}{*}\|q;{}$\7
\&{for\_clause} ${}(\|q,\39{\AND}\|f\MG\\{uipClause}){}$\1\6
\&{if} ${}(\\{levelOf}(\|f,\39\\{fs\_lit2var}({*}\|q))\E{}$(\&{literal}) \|f${}%
\MG\\{decisionLevel}){}$\1\5
${}\|c\PP;{}$\2\2\6
${}\\{fslog}(\|f,\39\.{"find\_uips"},\39\T{6},\39\.{"c=0,\ backtracked\ to}\)%
\.{\ level\ \%"}\\{PRIu64}\.{",\ c\ =\ \%"}\\{PRIu32}\.{",\ p\ =\ \%ji\\n"},\39%
\|f\MG\\{decisionLevel},\39\|c,\39\|p);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\5
\&{while} ${}(\|c\I\T{1}\W\|f\MG\\{uipClause}.\\{size}>\T{0}\W\|f\MG%
\\{decisionLevel}>\T{0});{}$\6
${}\\{num\_uips\_learned}\PP;{}$\6
\X146:Allocate and add the new \UIP\ clause to the unit facts for \PB{\\{fs%
\_lit2var}(\|p)}\X\6
\&{if} ${}(\\{isDecision}(\|f,\39\\{fs\_lit2var}(\|p))){}$\1\5
${}\\{num\_uips\_to\_learn}\K\\{num\_uips\_learned}{}$;\2\par
\U139.\fi

\M{141}Check loop invariants to at least \textit{try} to be careful.

\orderedlist
\li Top of the trail must be in the clause.
\li Count \PB{\|c} must be the number of current-decision-level literals.
\endorderedlist

These invariants should guarantee that there is at least one more UIP literal
to
learn.
\Y\B\4\X141:Check \UIP\ learning invariants if \PB{\.{NDEBUG}} is not present%
\X${}\E{}$\6
\8\#\&{ifndef} \.{NDEBUG}\6
${}\{{}$\1\6
\&{literal} ${}{*}\|q;{}$\6
\&{uint32\_t} \\{inner\_cnt}${}\K\T{0};{}$\7
${}\\{assert}(\\{litpos\_contains}({\AND}\|f\MG\\{litpos\_uip},\39%
\\{trailPeek}(\|f)));{}$\6
\&{for\_clause} ${}(\|q,\39{\AND}\|f\MG\\{uipClause}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{levelOf}(\|f,\39\\{fs\_lit2var}({*}\|q))\E{}$(\&{literal}) \|f${}%
\MG\\{decisionLevel}){}$\1\5
${}\\{inner\_cnt}\PP;{}$\2\6
\4${}\}{}$\2\6
${}\\{assert}(\\{inner\_cnt}\E\|c);{}$\6
\4${}\}{}$\2\6
\8\#\&{endif}\par
\U140.\fi

\M{142}At each step during learning a clause we perform a clause resolution. We
will
always resolve away the variable at the top of the trail. As a result, the
clause may shrink or expand in size.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{uintmax\_t} \\{pop\_and\_resolve}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{uintptr\_t} \\{ix\_reason}${},\39{}$\&{head\_tail} ${}{*}%
\\{facts}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} \|p;\7
\&{fs\_ifdbg} ${}(\|f,\39\.{"find\_uips"},\39\T{6}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"find\_uips"},\39\T{6},\39\.{"resolving\ "});{}$\6
${}\\{fs\_clause\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39{\AND}\|f\MG%
\\{uipClause});{}$\6
${}\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\ with\ "});{}$\6
${}\\{fs\_clause\_head\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39\\{ix%
\_reason});{}$\6
${}\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
${}\|p\K\\{trailPop}(\|f,\39\\{facts});{}$\6
${}\|f\MG\\{conf}\MG\\{bumpReason}(\|f,\39\\{ix\_reason});{}$\6
\X143:Resolve \PB{$\|f\MG\\{uipClause}$} with reason for \PB{\|p} and count
literals\X\6
\4${}\}{}$\2\par
\fi

\M{143}Here the actual resolution step is performed. This code performs a
resolution
on the literal \PB{\|p} using the position list, which is stored in
\PB{\&{funcsat} $\MG$ \\{litPos}}. The code copies over all literals not
currently in
\PB{$\|f\MG\\{uipClause}$}; then, it deletes \PB{${-}\|p$} from \PB{$\|f\MG%
\\{uipClause}$}.

Preconditions:
\unorderedlist
\li \PB{\\{ix\_reason}} is the clause index for \PB{\|p}'s reason
\li \PB{\|p} is in \PB{\\{ix\_reason}}
\li \PB{${-}\|p$} is in \PB{$\|f\MG\\{uipClause}$}
\endunorderedlist

Returns the number of current-decision-level literals found in the \PB{\\{ix%
\_reason}}
clause.

\Y\B\4\X143:Resolve \PB{$\|f\MG\\{uipClause}$} with reason for \PB{\|p} and
count literals\X${}\E{}$\6
\&{variable} \|i${},{}$ \|c${}\K\T{0},{}$ \\{pvar}${}\K\\{fs\_lit2var}(\|p);{}$%
\6
\&{uintptr\_t} \\{pos\_p};\6
\&{struct} \&{clause\_iter} \\{it};\7
${}\PP\|f\MG\\{numResolutions};{}$\6
${}\\{clause\_iter\_init}(\|f,\39\\{ix\_reason},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|q\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|q; ${}\|q\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
\&{literal} \|l${}\K{*}\|q;{}$\7
\&{if} ${}(\R\\{litpos\_contains}({\AND}\|f\MG\\{litpos\_uip},\39\|l)){}$\5
${}\{{}$\1\6
\&{literal} ${}{*}\\{new\_lit};{}$\7
${}\\{clausePush}({\AND}\|f\MG\\{uipClause},\39\|l);{}$\6
${}\\{new\_lit}\K\|f\MG\\{uipClause}.\\{data}+\|f\MG\\{uipClause}.\\{size}-%
\T{1};{}$\6
${}\\{assert}({*}\\{new\_lit}\E\|l);{}$\6
${}\\{litpos\_set}({\AND}\|f\MG\\{litpos\_uip},\39\\{new\_lit});{}$\6
${}\\{litpos\_check}({\AND}\|f\MG\\{litpos\_uip});{}$\6
\&{if} ${}(\\{levelOf}(\|f,\39\\{fs\_lit2var}(\|l))\E{}$(\&{literal}) \|f${}\MG%
\\{decisionLevel}){}$\1\5
${}\|c\PP;{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\X144:Delete \PB{${-}\|p$} from \PB{$\|f\MG\\{uipClause}$} after resolution\X\6
\&{return} \|c;\par
\U142.\fi

\M{144}Swap \PB{${-}\|p$} and the last element of \PB{$\|f\MG\\{uipClause}$}
and decrement the clause
size. Simple.
\Y\B\4\X144:Delete \PB{${-}\|p$} from \PB{$\|f\MG\\{uipClause}$} after
resolution\X${}\E{}$\6
\&{literal} ${}{*}\\{data}\K\|f\MG\\{uipClause}.\\{data};{}$\7
${}\\{pos\_p}\K\\{litpos\_pos}({\AND}\|f\MG\\{litpos\_uip},\39\|p);{}$\6
${}\\{swap}(\&{literal},\39\\{data}[\\{pos\_p}],\39\\{data}[\|f\MG%
\\{uipClause}.\\{size}-\T{1}]);{}$\6
${}\\{litpos\_set}({\AND}\|f\MG\\{litpos\_uip},\39\\{data}+\\{pos\_p});{}$\6
${}\\{litpos\_unset}({\AND}\|f\MG\\{litpos\_uip},\39\\{data}[\|f\MG%
\\{uipClause}.\\{size}-\T{1}]);{}$\6
${}\|f\MG\\{uipClause}.\\{size}\MM;{}$\6
${}\\{litpos\_check}({\AND}\|f\MG\\{litpos\_uip}){}$;\par
\U143.\fi

\M{145}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{uintmax\_t} \\{pop\_and\_resolve}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{uintptr\_t} \\{ix\_reason}${},\39{}$\&{head\_tail} ${}{*}%
\\{facts}){}$;\par
\fi

\M{146}You might think that allocating a new internal clause from the new \UIP\
clause would be straightforward.

But you would be wrong.

The first bit of (slight) complexity is that since we might generate more than
one learned clause per conflict, we need a list to store them. We use the unit
fact list at the current UIP literal \PB{\|p} for our storage.

The second bit of complexity is that the order if literals in the learned
clause
matters. (See the section \PB{$\X148:Order unit fact literals and minimize the
learned clause\X$} for details.)

\Y\B\4\X146:Allocate and add the new \UIP\ clause to the unit facts for \PB{%
\\{fs\_lit2var}(\|p)}\X${}\E{}$\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"find\_uips"},\39\T{6}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"find\_uips"},\39\T{6},\39\.{"found\ raw\ UIP:\ "});{}$\6
${}\\{fs\_clause\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39{\AND}\|f\MG%
\\{uipClause});{}$\6
${}\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
\X147:Check for \UNSAT\ after learning\X\6
\X148:Order unit fact literals and minimize the learned clause\X\7
\&{uintptr\_t} \\{ix\_uip}${}\K\\{clause\_head\_alloc\_from\_clause}(\|f,\39{%
\AND}\|f\MG\\{uipClause});{}$\6
\&{struct} \&{clause\_head} ${}{*}\\{h\_uip}\K\\{clause\_head\_ptr}(\|f,\39%
\\{ix\_uip});{}$\7
${}\|f\MG\\{conf}\MG\\{bumpLearned}(\|f,\39\\{ix\_uip});{}$\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"find\_uips"},\39\T{5}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"find\_uips"},\39\T{5},\39\.{"found\ min\ UIP:\ "});{}$\6
${}\\{fs\_clause\_head\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39\\{ix\_uip});{}$\6
${}\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
${}\\{h\_uip}\MG\\{is\_learned}\K\\{true};{}$\6
${}\\{h\_uip}\MG\\{where}\K\.{CLAUSE\_UNIT};{}$\6
${}\\{head\_tail\_add}(\|f,\39{\AND}\|f\MG\\{unit\_facts}[\\{fs\_lit2var}(%
\|p)],\39\\{ix\_uip});{}$\6
${}\\{vec\_uintptr\_push}(\|f\MG\\{learned\_clauses},\39\\{ix\_uip});{}$\6
${}\PP\|f\MG\\{numLearnedClauses}{}$;\par
\U140.\fi

\M{147}After we have learned a \UIP\ we may have discovered that the \SAT\
instance
is unsatisfiable. This can happen when we backtrack all the way to decision
level 0 or if we resolve the empty clause directly.

\Y\B\4\X147:Check for \UNSAT\ after learning\X${}\E{}$\6
\&{if} ${}(\|f\MG\\{decisionLevel}\E\T{0}\V\|f\MG\\{uipClause}.\\{size}\E%
\T{0}){}$\1\5
\&{return} \\{true};\2\par
\U146.\fi

\M{148}While munging the unit facts, we need to ensure that the invariant on
\PB{$\|f\MG\\{unitFacts}$} for \PB{\\{propagateFacts}} holds for this clause:
the \UIP\ literal
needs to be the first literal in the clause, and the second literal is the one
that was most recently inferred.

We minimize the learned clause here, too.

\Y\B\4\X148:Order unit fact literals and minimize the learned clause\X${}\E{}$\6
\&{literal} \\{watch2}${}\K\T{0},{}$ \\{watch2\_level}${}\K{-}\T{1};{}$\6
\&{uintmax\_t} \\{pPos}${}\K\\{litpos\_pos}({\AND}\|f\MG\\{litpos\_uip},\39%
\|p);{}$\7
${}\\{swap}(\&{literal},\39\|f\MG\\{uipClause}.\\{data}[\T{0}],\39\|f\MG%
\\{uipClause}.\\{data}[\\{pPos}]);{}$\6
${}\\{litpos\_set}({\AND}\|f\MG\\{litpos\_uip},\39{\AND}\|f\MG\\{uipClause}.%
\\{data}[\T{0}]);{}$\6
${}\\{litpos\_set}({\AND}\|f\MG\\{litpos\_uip},\39{\AND}\|f\MG\\{uipClause}.%
\\{data}[\\{pPos}]);{}$\6
\&{if} ${}(\|f\MG\\{conf}\MG\\{minimizeLearnedClauses}){}$\1\5
${}\\{minimizeUip}(\|f,\39({\AND}\|f\MG\\{uipClause}));{}$\2\6
\&{for} (\&{variable} \|i${}\K\T{1};{}$ ${}\|i<({\AND}\|f\MG\\{uipClause})\MG%
\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\C{ find max level literal }\1\6
\&{literal} \\{lev}${}\K\\{levelOf}(\|f,\39\\{fs\_lit2var}(({\AND}\|f\MG%
\\{uipClause})\MG\\{data}[\|i]));{}$\7
\&{if} ${}(\\{watch2\_level}<\\{lev}){}$\5
${}\{{}$\1\6
${}\\{watch2\_level}\K\\{lev};{}$\6
${}\\{watch2}\K{}$(\&{literal}) \|i;\6
\4${}\}{}$\2\6
\&{if} ${}(\\{lev}\E{}$(\&{literal}) \|f${}\MG\\{decisionLevel}){}$\1\5
\&{break};\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{watch2\_level}\I{-}\T{1}){}$\5
${}\{{}$\1\6
${}\\{swap}(\&{literal},\39\|f\MG\\{uipClause}.\\{data}[\T{1}],\39\|f\MG%
\\{uipClause}.\\{data}[\\{watch2}]);{}$\6
${}\\{litpos\_set}({\AND}\|f\MG\\{litpos\_uip},\39{\AND}\|f\MG\\{uipClause}.%
\\{data}[\T{1}]);{}$\6
${}\\{litpos\_set}({\AND}\|f\MG\\{litpos\_uip},\39{\AND}\|f\MG\\{uipClause}.%
\\{data}[\\{watch2}]);{}$\6
\4${}\}{}$\2\par
\Q146.
\U146.\fi

\M{149}During learning we may discover learned (intermediate or \UIP) clauses
that
subsume existing clauses. If so, we should take that information and strengthen
our clause database.

\Y\B\4\X149:Deal with subsumed clauses\X${}\E{}$\6
\8\#\&{if} \T{0}\6
\&{if} ${}(\|f\MG\\{conf}\MG\\{useSelfSubsumingResolution}){}$\5
${}\{{}$\1\6
\&{for\_vec\_ptr99} (\&{clause} ${}{*}{*},\39\\{it},\39{\AND}\|f\MG%
\\{subsumed}){}$\5
${}\{{}$\1\6
\&{bool} \\{subsumedByUip}${}\K{}$(\&{bool}) ${}{*}\\{it};{}$\7
${}\PP\\{it};{}$\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"subsumption"},\39\T{1}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{dbgout}(\|f),\39\.{"removing\ clause\ due}\)\.{\ to\
subsumption:\ "});{}$\6
${}\\{clause\_head\_print\_dimacs}(\\{dbgout}(\|f),\39{*}\\{it});{}$\6
${}\\{fprintf}(\\{dbgout}(\|f),\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(({*}\\{it})\MG\\{isLearnt}){}$\5
${}\{{}$\1\6
\&{clause} ${}{*}\\{removedClause}\K\\{funcsatRemoveClause}(\|f,\39{*}%
\\{it});{}$\7
\\{assert}(\\{removedClause});\6
\&{if} (\\{subsumedByUip})\1\5
\\{clauseFree}(\\{removedClause});\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{removedClause}\MG\\{data}[\T{0}]\K\\{removedClause}\MG\\{data}[\MM%
\\{removedClause}\MG\\{size}];{}$\6
${}\\{vec\_ptr\_push}({\AND}\|f\MG\\{learnedClauses},\39\\{removedClause});{}$\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"subsumption"},\39\T{1}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{dbgout}(\|f),\39\.{"new\ adjusted\ clause}\)\.{:\ "});{}$\6
${}\\{clause\_head\_print\_dimacs}(\\{dbgout}(\|f),\39\\{removedClause});{}$\6
${}\\{fprintf}(\\{dbgout}(\|f),\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{removedClause}\MG\\{is\_watched}){}$\5
${}\{{}$\1\6
${}\\{addWatch}(\|f,\39\\{removedClause});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\|f\MG\\{subsumed}.\\{size}\K\T{0};{}$\6
\4${}\}{}$\2\6
\8\#\&{endif}\par
\fi

\M{150}Prototypes.
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{bool} \\{isAssumption}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{variable} \|v);\par
\fi

\M{151}Learned clauses often contain redundant literals. Use Van Gelder's
algorithm
to remove them.

\fi

\M{152}
\Y\B\4\X41:Initialize funcsat type\X${}\mathrel+\E{}$\6
$\\{vec\_uintmax\_mk}({\AND}\|f\MG\\{seen},\39\T{2});{}$\6
${}\\{vec\_uintmax\_push}({\AND}\|f\MG\\{seen},\39\\{false});{}$\6
${}\\{vec\_intmax\_mk}({\AND}\|f\MG\\{analyseToClear},\39\T{2});{}$\6
${}\\{vec\_intmax\_push}({\AND}\|f\MG\\{analyseToClear},\39\T{0});{}$\6
${}\\{vec\_uintmax\_mk}({\AND}\|f\MG\\{analyseStack},\39\T{2});{}$\6
${}\\{vec\_uintmax\_push}({\AND}\|f\MG\\{analyseStack},\39\T{0});{}$\6
${}\\{vec\_uintmax\_mk}({\AND}\|f\MG\\{allLevels},\39\T{2});{}$\6
${}\\{vec\_uintmax\_push}({\AND}\|f\MG\\{allLevels},\39\\{false}){}$;\par
\fi

\M{153}
\Y\B\4\X72:Incrementally resize internal data structures up to new \PB{%
\\{numVars}}\X${}\mathrel+\E{}$\6
$\\{vec\_uintmax\_push}({\AND}\|f\MG\\{seen},\39\\{false});{}$\6
${}\\{vec\_uintmax\_push}({\AND}\|f\MG\\{allLevels},\39\\{false}){}$;\par
\fi

\M{154}
\Y\B\4\X104:Resize internal data structures up to new \PB{\\{numVars}}\X${}%
\mathrel+\E{}$\6
$\\{vec\_intmax\_grow\_to}({\AND}\|f\MG\\{analyseToClear},\39\\{numVars});{}$\6
${}\\{vec\_uintmax\_grow\_to}({\AND}\|f\MG\\{analyseStack},\39\\{numVars}){}$;%
\par
\fi

\M{155}
\Y\B\4\X42:Destroy funcsat type\X${}\mathrel+\E{}$\6
$\\{vec\_uintmax\_unmk}({\AND}\|f\MG\\{allLevels});{}$\6
${}\\{vec\_uintmax\_unmk}({\AND}\|f\MG\\{analyseStack});{}$\6
${}\\{vec\_intmax\_unmk}({\AND}\|f\MG\\{analyseToClear});{}$\6
${}\\{vec\_uintmax\_unmk}({\AND}\|f\MG\\{seen}){}$;\par
\fi

\M{156}
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{void} \\{cleanSeen}(\&{funcsat} ${}{*}\|f,\39{}$\&{variable} %
\\{top})\1\1\2\2\6
${}\{{}$\1\6
\&{while} ${}(\|f\MG\\{analyseToClear}.\\{size}>\\{top}){}$\5
${}\{{}$\1\6
\&{variable} \|v${}\K\\{fs\_lit2var}(\\{vec\_intmax\_pop}({\AND}\|f\MG%
\\{analyseToClear}));{}$\7
${}\|f\MG\\{seen}.\\{data}[\|v]\K\\{false};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{bool} \\{isAssumption}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{variable} \|v)\1\1\2\2\6
${}\{{}$\1\6
\&{literal} ${}{*}\\{it};{}$\7
\&{for\_clause} ${}(\\{it},\39{\AND}\|f\MG\\{assumptions}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{fs\_lit2var}({*}\\{it})\E\|v){}$\5
${}\{{}$\1\6
\&{return} \\{true};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{return} \\{false};\6
\4${}\}{}$\C{*  * Performs a depth-first search of the conflict graph beginning
at q0.  }\2\7
\&{static} \&{bool} \\{litRedundant}(\&{funcsat} ${}{*}\|f,\39{}$\&{literal} %
\\{q0})\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{levelOf}(\|f,\39\\{fs\_lit2var}(\\{q0}))\E\T{0}){}$\1\5
\&{return} \\{false};\2\6
\&{if} ${}(\\{isDecision}(\|f,\39\\{fs\_lit2var}(\\{q0}))){}$\1\5
\&{return} \\{false};\2\6
${}\\{assert}(\R\\{isAssumption}(\|f,\39\\{fs\_lit2var}(\\{q0}))){}$;%
\C{fprintf(f->conf->debugStream, "literal %jd is not trivally redundant\n",
%q0);}\6
${}\\{vec\_uintmax\_clear}({\AND}\|f\MG\\{analyseStack});{}$\6
${}\\{vec\_uintmax\_push}({\AND}\|f\MG\\{analyseStack},\39\\{fs\_lit2var}(%
\\{q0}));{}$\7
\&{variable} \\{top}${}\K\|f\MG\\{analyseToClear}.\\{size}{}$;%
\C{fprintf(f->conf->debugStream, "pushing literal %jd to stack\n", q0);}\7
\&{while} ${}(\|f\MG\\{analyseStack}.\\{size}>\T{0}){}$\5
${}\{{}$\1\6
\&{variable} \|p${}\K\\{vec\_uintmax\_pop}({\AND}\|f\MG\\{analyseStack}){}$;%
\C{fprintf(f->conf->debugStream, "popping variable %ju from stack to get reason
%clause\n", p);}\6
\&{uintptr\_t} \\{ix}${}\K\\{getReason}(\|f,\39{}$(\&{literal}) \|p);%
\C{fs_clause_head_print(f, fs_dbgout(f), ix);}\6
\&{struct} \&{clause\_iter} \\{it};\6
\&{literal} ${}{*}\|q;{}$\7
${}\\{clause\_iter\_init}(\|f,\39\\{ix},\39{\AND}\\{it}){}$;\C{    q =
clause_iter_next(f, &it);}\C{    if (q) {}}\C{ begins at 1 because \PB{$\\{fs%
\_lit2var}(\|c\MG\\{data}[\T{0}])\E\|p$} }\6
\&{for} ${}(\|q\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$ \|q; ${}\|q\K%
\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\C{fprintf(f->conf->debugStream, "considering literal %jd from clause%
%\n", *q);}\C{assert(q0 != *q);}\1\6
\&{if} ${}({*}\|q\E\\{q0}){}$\1\5
\&{continue};\2\7
\&{variable} \|v${}\K\\{fs\_lit2var}({*}\|q);{}$\6
\&{literal} \\{lev}${}\K\\{levelOf}(\|f,\39\|v);{}$\7
\&{if} ${}(\R\|f\MG\\{seen}.\\{data}[\|v]\W\\{lev}>\T{0}){}$\5
${}\{{}$\1\6
\&{if} ${}(\R\\{isDecision}(\|f,\39\\{fs\_lit2var}({*}\|q))\W\|f\MG%
\\{allLevels}.\\{data}[\\{lev}]){}$\5
${}\{{}$\1\6
${}\\{vec\_uintmax\_push}({\AND}\|f\MG\\{analyseStack},\39\|v);{}$\6
${}\\{vec\_intmax\_push}({\AND}\|f\MG\\{analyseToClear},\39{*}\|q);{}$\6
${}\|f\MG\\{seen}.\\{data}[\|v]\K\\{true};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{cleanSeen}(\|f,\39\\{top});{}$\6
\&{return} \\{false};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\C{}\2\6
\4${}\}{}$\2\6
\&{return} \\{true};\6
\4${}\}{}$\2\par
\fi

\M{157}\PB{\\{minimizeUip}} assumes that the \UIP\ literal is at the first
position in the
clause.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{minimizeUip}(\&{funcsat} ${}{*}\|f,\39{}$\&{clause} ${}{*}%
\\{learned}){}$\1\1\2\2\6
${}\{{}$\C{* todo use integer to denote the levels in the set, then just
increment }\1\6
\&{variable} \|i${},{}$ \|j;\7
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\\{learned}\MG\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{literal} \|l${}\K\\{levelOf}(\|f,\39\\{fs\_lit2var}(\\{learned}\MG\\{data}[%
\|i]));{}$\7
${}\\{assert}(\|l\I\\{Unassigned});{}$\6
${}\|f\MG\\{allLevels}.\\{data}[\|l]\K\\{true};{}$\6
\4${}\}{}$\2\6
${}\\{vec\_intmax\_clear}({\AND}\|f\MG\\{analyseToClear});{}$\7
\&{literal} ${}{*}\\{it};{}$\7
${}\\{forClause}(\\{it},\39\\{learned}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{vec\_intmax\_push}({\AND}\|f\MG\\{analyseToClear},\39{*}\\{it});{}$\6
\4${}\}{}$\C{ \PB{$\\{memset}(\|f\MG\\{seen}.\\{data},\T{0},\|f\MG\\{seen}.%
\\{capacity}*{}$\&{sizeof} ${}({*}\|f\MG\\{seen}.\\{data}));$} }\2\7
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\\{learned}\MG\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\|f\MG\\{seen}.\\{data}[\\{fs\_lit2var}(\\{learned}\MG\\{data}[\|i])]\K%
\\{true};{}$\6
\4${}\}{}$\C{ uip literal is assumed to be in \PB{$\\{learned}\MG\\{data}[%
\T{0}]$}, so skip it by starting at    * \PB{$\|i\K\T{1}$} }\2\6
${}\\{fslog}(\|f,\39\.{"minimizeUip"},\39\T{6},\39\.{"searching\ learned\ c}\)%
\.{lause\ for\ redundant\ }\)\.{literals\\n"}){}$;\C{fs_clause_print(f,
fs_dbgout(f), learned);}\6
\&{for} ${}(\|i\K\T{1},\39\|j\K\T{1};{}$ ${}\|i<\\{learned}\MG\\{size};{}$ ${}%
\|i\PP){}$\5
${}\{{}$\1\6
\&{literal} \|p${}\K\\{learned}\MG\\{data}[\|i]{}$;%
\C{fprintf(f->conf->debugStream, "considering literal %jd\n", p);}\7
\&{if} ${}(\R\\{litRedundant}(\|f,\39\|p)){}$\5
${}\{{}$\1\6
${}\\{learned}\MG\\{data}[\|j]\K\|p;{}$\6
${}\\{litpos\_set}({\AND}\|f\MG\\{litpos\_uip},\39\\{learned}\MG\\{data}+%
\|j);{}$\6
${}\|j\PP;{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{assert}(\R\\{isAssumption}(\|f,\39\\{fs\_lit2var}(\|p)));{}$\6
${}\\{litpos\_unset}({\AND}\|f\MG\\{litpos\_uip},\39\|p);{}$\6
${}\\{fslog}(\|f,\39\.{"minimizeUip"},\39\T{5},\39\.{"deleted\ \%ji\\n"},\39%
\|p);{}$\6
${}\PP\|f\MG\\{numLiteralsDeleted};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{learned}\MG\\{size}\MRL{-{\K}}\|i-\|j{}$;\C{ specialised \PB{$%
\\{cleanSeen}(\|f,\T{0})$} to include clearing of \PB{\\{allLevels}} }\6
\&{while} ${}(\|f\MG\\{analyseToClear}.\\{size}>\T{0}){}$\5
${}\{{}$\1\6
\&{literal} \|l${}\K\\{vec\_intmax\_pop}({\AND}\|f\MG\\{analyseToClear});{}$\6
\&{variable} \|v${}\K\\{fs\_lit2var}(\|l);{}$\7
${}\|f\MG\\{seen}.\\{data}[\|v]\K\\{false};{}$\6
${}\|f\MG\\{allLevels}.\\{data}[\\{levelOf}(\|f,\39\|v)]\K\\{false};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{158}
\Y\B\4\X158:Find the most recent\X${}\E{}$\6
\&{while} ${}(\R\\{litpos\_contains}({\AND}\|f\MG\\{litpos\_uip},\39\|p\K%
\\{trailPeek}(\|f))){}$\5
${}\{{}$\1\6
${}\\{trailPop}(\|f,\39\\{facts});{}$\6
\4${}\}{}$\2\par
\fi

\M{159}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{void} \\{print\_dot\_impl\_graph}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{clause} ${}{*}\\{cc}){}$;\par
\fi

\M{160}It is convenient to be able to dump the implication graph to a dot file
so we can
render it in graphviz.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{char} ${}{*}{}$\\{dot\_lit2label}(\&{literal} \|p)\1\1\2\2\6
${}\{{}$\1\6
\&{static} \&{char} \\{buf}[\T{64}];\7
${}\\{sprintf}(\\{buf},\39\.{"lit\%ji"},\39\\{fs\_lit2var}(\|p));{}$\6
\&{return} \\{buf};\6
\4${}\}{}$\2\7
\&{static} \&{void} \\{print\_dot\_impl\_graph\_rec}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{FILE} ${}{*}\\{dotfile},\39{}$\&{struct} \\{vec\_bool} ${}{*}\\{seen},%
\39{}$\&{literal} \|p)\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{seen}\MG\\{data}[\\{fs\_lit2var}(\|p)]\E\\{false}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{dotfile},\39\.{"\%s\ "},\39\\{dot\_lit2label}(\|p));{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"[label=\\"\%ji\ @\ \%ju\%}\)\.{s\\"\%s];%
\\n"},\39(\\{funcsatValue}(\|f,\39\|p)\E\\{false}\?{-}\|p:\|p),\39\\{levelOf}(%
\|f,\39\\{fs\_lit2var}(\|p)),\39(\\{funcsatValue}(\|f,\39\|p)\E\\{unknown}\?%
\.{"*"}:\.{""}),\39(\\{levelOf}(\|f,\39\\{fs\_lit2var}(\|p))\E{}$(\&{literal}) %
\|f${}\MG\\{decisionLevel}\?\.{",color=green"}:\.{""}));{}$\6
${}\\{seen}\MG\\{data}[\\{fs\_lit2var}(\|p)]\K\\{true};{}$\7
\&{bool} \\{isdec}${}\K\\{isDecision}(\|f,\39\\{fs\_lit2var}(\|p));{}$\7
\&{if} ${}(\R\\{isdec}){}$\5
${}\{{}$\1\6
\&{uintptr\_t} \\{ix\_r}${}\K\\{getReason}(\|f,\39\|p);{}$\6
\&{struct} \&{clause\_iter} \\{it};\7
${}\\{clause\_iter\_init}(\|f,\39\\{ix\_r},\39{\AND}\\{it});{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"/*\ reason\ for\ \%ji:\ }\)\.{"},\39\|p);{}$\6
${}\\{fs\_clause\_head\_print}(\|f,\39\\{dotfile},\39\\{ix\_r});{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"*/\\n"});{}$\6
\&{for} (\&{literal} ${}{*}\|q\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|q; ${}\|q\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
\&{if} ${}({*}\|q\I{-}\|p){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{dotfile},\39\.{"\%s"},\39\\{dot\_lit2label}({*}\|q));{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"\ ->\ "});{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"\%s;\\n"},\39\\{dot\_lit2label}(\|p));{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{clause\_iter\_init}(\|f,\39\\{ix\_r},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|q\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|q; ${}\|q\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
${}\\{print\_dot\_impl\_graph\_rec}(\|f,\39\\{dotfile},\39\\{seen},\39{*}%
\|q);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{fprintf}(\\{dotfile},\39\.{"/*\ no\ reason\ for\ \%j}\)\.{i\ */\\n"},\39%
\|p);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{static} \&{void} \\{print\_dot\_impl\_graph}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{clause} ${}{*}\\{cc}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} ${}{*}\|p,{}$ ${}{*}\|q;{}$\6
\&{struct} \\{vec\_bool} ${}{*}\\{seen}\K\\{vec\_bool\_init}(\|f\MG\\{numVars}+%
\T{1});{}$\7
${}\\{seen}\MG\\{size}\K\|f\MG\\{numVars}+\T{1};{}$\7
\&{char} \\{buf}[\T{64}];\7
${}\\{snprintf}(\\{buf},\39\T{64},\39\.{"conflict\%"}\\{PRIu64}\.{".dot"},\39%
\|f\MG\\{numConflicts}),\39\\{buf}[\T{63}]\K\T{0};{}$\7
\&{FILE} ${}{*}\\{dotfile}\K\\{fopen}(\\{buf},\39\.{"w"});{}$\7
${}\\{fprintf}(\\{dotfile},\39\.{"digraph\ G\ \{\\n"});{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"/*\ conflict\ clause:}\)\.{\ "});{}$\6
${}\\{fs\_clause\_print}(\|f,\39\\{dotfile},\39\\{cc});{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"*/\\n"});{}$\6
${}\\{buf}[\\{strlen}(\\{buf})-\\{strlen}(\.{".dot"})]\K\T{0};{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"\%s\ [shape=note];\\n"},\39\\{buf});{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"cclause\ [shape=note}\)\.{,label=\\""}){}$;%
\C{ conflict clause }\6
\&{for\_clause} ${}(\|p,\39\\{cc}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{dotfile},\39\.{"\%ji\%s\ "},\39{*}\|p,\39(\\{funcsatValue}(%
\|f,\39{*}\|p)\E\\{unknown}\?\.{"*"}:\.{""}));{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{dotfile},\39\.{"\\"];\\n"});{}$\6
\&{for\_clause} ${}(\|p,\39\\{cc}){}$\1\5
${}\\{print\_dot\_impl\_graph\_rec}(\|f,\39\\{dotfile},\39\\{seen},\39{*}%
\|p);{}$\2\6
${}\\{fprintf}(\\{dotfile},\39\.{"lambda\ [label=L];\\n}\)\.{"});{}$\6
\&{for\_clause} ${}(\|p,\39\\{cc}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{dotfile},\39\.{"\%s"},\39\\{dot\_lit2label}({*}\|p));{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"\ ->\ "});{}$\6
${}\\{fprintf}(\\{dotfile},\39\.{"lambda\ [color=\\"red}\)\.{\\"];\\n"});{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{dotfile},\39\.{"\\n\}"});{}$\6
\\{vec\_bool\_destroy}(\\{seen});\6
\\{fclose}(\\{dotfile});\6
\4${}\}{}$\2\par
\fi

\M{161}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\8\#\&{include} \.{"funcsat/vec\_bool.h"}\par
\fi

\N{3}{162}Unit facts. At the end of learning we have a list of new clauses. We
need to
propagate them, and more importantly shunt them into {\it unit fact lists}.

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{bool} \\{find\_uips}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintmax\_t} \|c${},%
\39{}$\&{head\_tail} ${}{*}\\{facts},\39{}$\&{literal} ${}{*}\\{uipLit});{}$\6
\&{bool} \\{propagateFacts}(\&{funcsat} ${}{*}\|f,\39{}$\&{head\_tail} ${}{*}%
\\{facts},\39{}$\&{literal} \\{uipLit});\6
\&{static} \&{uintmax\_t} \\{resetLevelCount}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{uintmax\_t} \|c${},\39{}$\&{head\_tail} ${}{*}\\{facts});{}$\6
\&{static} \&{void} \\{checkSubsumption}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{literal} \|p${},\39{}$\&{clause} ${}{*}\\{learn},\39{}$\&{clause} ${}{*}%
\\{reason},\39{}$\&{bool} \\{learnIsUip});\par
\fi

\M{163}The following function propagates the given unit facts.  Each clause is
either:
%
\numberedlist
\li unit
\li or has at least two unassigned literals.
\endnumberedlist In the first case, we immediately make an assignment, but this
function will
ignore that assignment for the purposes of detecting a conflict.  In the latter
case, we add the clause to the watched literals lists.  The uips not added to
the watched literal lists are attached as unit facts to the variable dec.

It is possible that propagateFacts may discover a conflict.  If so, it returns
\PB{\\{false}}.


\fi

\M{164}The following code is wrapped around the crucial node, \PB{$%
\X165:Propagate single unit fact\X$}.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{bool} \\{propagateFacts}(\&{funcsat} ${}{*}\|f,\39{}$\&{head\_tail} ${}{*}%
\\{facts},\39{}$\&{literal} \\{uipLit})\1\1\2\2\6
${}\{{}$\1\6
\&{bool} \\{isConsistent}${}\K\\{true};{}$\6
\&{variable} \\{uipVar}${}\K\\{fs\_lit2var}(\\{uipLit});{}$\6
\&{uintmax\_t} \\{cnt}${}\K\T{0};{}$\7
${}\\{dopen}(\|f,\39\.{"bcp"}){}$;\C{ Assign each unit fact }\7
\&{uintptr\_t} \\{ix\_prev}${},{}$ \\{ix\_curr}${},{}$ \\{ix\_next};\7
\&{for\_head\_tail} ${}(\|f,\39\\{facts},\39\\{ix\_prev},\39\\{ix\_curr},\39%
\\{ix\_next}){}$\5
${}\{{}$\1\6
${}\PP\|f\MG\\{numUnitFactProps},\39\PP\\{cnt};{}$\6
\X165:Propagate single unit fact\X\6
\&{if} ${}(\R\\{isConsistent}){}$\1\5
\&{break};\2\6
\4${}\}{}$\2\6
${}\\{dclose}(\|f,\39\.{"bcp"});{}$\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{1},\39\.{"propagated\ \%ju\ fact}\)\.{s%
\\n"},\39\\{cnt});{}$\6
\&{if} ${}(\|f\MG\\{conflict\_clause}\I\.{NO\_CLS}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{funcsatValue}(\|f,\39\\{uipLit})\E\\{unknown}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|f\MG\\{decisionLevel}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{uipVar}\K\\{fs\_lit2var}(\|f\MG\\{trail}.\\{data}[\|f\MG\\{trail}.%
\\{size}-\T{1}]);{}$\6
\4${}\}{}$\2\6
\&{else}\1\5
\&{goto} \\{ReallyDone};\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\8\#\&{if} \T{0}\6
${}\\{assert}(\R\\{head}\V\\{funcsatValue}(\|f,\39\\{fs\_var2lit}(\\{uipVar}))%
\I\\{unknown});{}$\6
${}\\{assert}(\\{clauseIsAlone}({\AND}\|f\MG\\{unitFacts}.\\{data}[\\{uipVar}],%
\39\T{0}));{}$\6
\8\#\&{endif}\C{ if var@0, then all learns are SAT@0 }\6
\&{if} ${}(\\{levelOf}(\|f,\39\\{uipVar})\I\T{0}){}$\5
${}\{{}$\1\6
${}\\{head\_tail\_append}(\|f,\39{\AND}\|f\MG\\{unit\_facts}[\\{uipVar}],\39%
\\{facts});{}$\6
\4${}\}{}$\2\6
\4\\{ReallyDone}:\5
\&{return} \\{isConsistent};\6
\4${}\}{}$\2\par
\fi

\M{165}Using the list of \PB{\\{facts}}, \PB{\\{curr}} and \PB{\\{prev}}, we
can propagate a single unit
fact. If we detect an inconsistency we set \PB{\\{isConsistent}} to \PB{%
\\{false}}.

\Y\B\4\X165:Propagate single unit fact\X${}\E{}$\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"bcp"},\39\T{5}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{5},\39\.{""}){}$;\C{ logging label }\6
${}\\{fs\_clause\_head\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39\\{ix\_curr});{}$\6
${}\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\\n"});{}$\6
\4${}\}{}$\2\7
\&{struct} \&{clause\_head} ${}{*}\\{h\_curr}\K\\{clause\_head\_ptr}(\|f,\39%
\\{ix\_curr});{}$\7
\&{if} ${}(\\{h\_curr}\MG\\{sz}\E\T{0}){}$\1\5
\&{goto} \\{Conflict};\2\6
\&{else} \&{if} ${}(\\{h\_curr}\MG\\{sz}\E\T{1}){}$\5
${}\{{}$\1\6
\&{literal} \|p${}\K\\{h\_curr}\MG\\{lits}[\T{0}];{}$\6
\&{mbool} \\{val}${}\K\\{funcsatValue}(\|f,\39\|p);{}$\7
\&{if} ${}(\\{val}\E\\{false}){}$\1\5
\&{goto} \\{Conflict};\2\6
\&{else} \&{if} ${}(\\{val}\E\\{unknown}){}$\5
${}\{{}$\1\6
${}\\{trailPush}(\|f,\39\|p,\39\\{reason\_info\_mk}(\|f,\39\\{ix\_curr}));{}$\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{1},\39\.{"\ =>\ \%ji\\n"},\39\|p);{}$\6
\4${}\}{}$\2\6
\&{continue};\6
\4${}\}{}$\2\7
\&{literal} \|p${}\K\\{h\_curr}\MG\\{lits}[\T{0}],{}$ \|q${}\K\\{h\_curr}\MG%
\\{lits}[\T{1}];{}$\7
${}\\{assert}(\|p\I\T{0}\W\|q\I\T{0}\W\.{"unset\ literals"});{}$\6
${}\\{assert}(\|p\I\|q\W\.{"did\ not\ find\ distin}\)\.{ct\ literals"});{}$\7
\&{mbool} \\{vp}${}\K\\{tentativeValue}(\|f,\39\|p),{}$ \\{vq}${}\K%
\\{tentativeValue}(\|f,\39\|q){}$;\C{ if \PB{$(\\{vp}\E\\{true}\W\\{vq}\E%
\\{true})$} (if jailing, put in jailed list for data[1],  * else put in watcher
list) }\7
\&{if} ${}(\\{vp}\E\\{true}\W\\{vq}\E\\{true}){}$\5
${}\{{}$\1\6
${}\\{head\_tail\_iter\_rm}(\|f,\39\\{facts},\39\\{ix\_prev},\39\\{ix\_curr},%
\39\\{ix\_next});{}$\6
${}\\{addWatchUnchecked}(\|f,\39\\{ix\_curr});{}$\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{5},\39\.{"\ =>\ watched\\n"});{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{vp}\E\\{true}\V\\{vq}\E\\{true}){}$\5
${}\{{}$\C{ clause is SAT }\1\6
;\C{ leave in unit facts }\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{5},\39\.{"\ =>\ unmolested\\n"});{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{vp}\E\\{unknown}\W\\{vq}\E\\{unknown}){}$\5
${}\{{}$\1\6
${}\\{head\_tail\_iter\_rm}(\|f,\39\\{facts},\39\\{ix\_prev},\39\\{ix\_curr},%
\39\\{ix\_next});{}$\6
${}\\{addWatchUnchecked}(\|f,\39\\{ix\_curr});{}$\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{5},\39\.{"\ =>\ watched\\n"});{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{vp}\E\\{unknown}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{funcsatValue}(\|f,\39\|p)\E\\{false}){}$\1\5
\&{goto} \\{Conflict};\2\6
${}\\{assert}(\\{h\_curr}\MG\\{lits}[\T{0}]\E\|p);{}$\6
${}\\{trailPush}(\|f,\39\|p,\39\\{reason\_info\_mk}(\|f,\39\\{ix\_curr})){}$;%
\C{ clause is unit, implying p }\6
${}\|f\MG\\{conf}\MG\\{bumpUnitClause}(\|f,\39\\{ix\_curr});{}$\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{1},\39\.{"\ =>\ \%ji\\n"},\39\|p);{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{vq}\E\\{unknown}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{funcsatValue}(\|f,\39\|q)\E\\{false}){}$\1\5
\&{goto} \\{Conflict};\2\6
${}\\{assert}(\\{h\_curr}\MG\\{lits}[\T{1}]\E\|q);{}$\6
${}\\{h\_curr}\MG\\{lits}[\T{0}]\K\|q,\39\\{h\_curr}\MG\\{lits}[\T{1}]\K\|p;{}$%
\6
${}\\{trailPush}(\|f,\39\|q,\39\\{reason\_info\_mk}(\|f,\39\\{ix\_curr})){}$;%
\C{ clause is unit, implying q }\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{1},\39\.{"\ =>\ \%ji\\n"},\39\|q);{}$\6
${}\|f\MG\\{conf}\MG\\{bumpUnitClause}(\|f,\39\\{ix\_curr});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\4\\{Conflict}:\C{ clause is UNSAT }\6
${}\\{isConsistent}\K\\{false};{}$\6
${}\|f\MG\\{conflict\_clause}\K\\{ix\_curr};{}$\6
${}\\{fslog}(\|f,\39\.{"bcp"},\39\T{1},\39\.{"\ =>\ X\\n"});{}$\6
\4${}\}{}$\2\par
\Q164.
\U164.\fi

\M{166}A slightly thorny case, that I can't explain yet, is why we use
\PB{\\{tentativeValue}} here instead of \PB{\\{funcsatValue}}. \PB{%
\\{tentativeValue}} works just
like its counterpart, only looks at values that have been {\it already
propagated} by BCP. This can be fewer, but never more, than those that are
assigned.


\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{mbool} \\{tentativeValue}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{literal} \|p)\1\1\2\2\6
${}\{{}$\1\6
\&{variable} \|v${}\K\\{fs\_lit2var}(\|p);{}$\6
\&{literal} ${}{*}\\{valLoc}\K{\AND}\|f\MG\\{trail}.\\{data}[\|f\MG\\{model}.%
\\{data}[\|v]];{}$\6
\&{bool} \\{isTentative}${}\K\\{valLoc}\G\|f\MG\\{trail}.\\{data}+\|f\MG%
\\{propq};{}$\7
\&{if} ${}(\\{levelOf}(\|f,\39\|v)\I\\{Unassigned}\W\R\\{isTentative}){}$\1\5
\&{return} \|p${}\E{*}\\{valLoc};{}$\2\6
\&{else}\1\5
\&{return} \\{unknown};\2\6
\4${}\}{}$\2\par
\fi

\M{167}

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{mbool} \\{tentativeValue}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{literal} \|p);\par
\fi

\M{168}We need to initialize the unit facts.

\Y\B\4\X41:Initialize funcsat type\X${}\mathrel+\E{}$\6
$\.{FS\_CALLOC}(\|f\MG\\{unit\_facts},\39\T{2},\39{}$\&{sizeof} ${}({*}\|f\MG%
\\{unit\_facts}));{}$\6
${}\|f\MG\\{unit\_facts\_size}\K\T{1};{}$\6
${}\|f\MG\\{unit\_facts\_capacity}\K\T{2}{}$;\par
\fi

\M{169}And grow them.
\Y\B\4\X72:Incrementally resize internal data structures up to new \PB{%
\\{numVars}}\X${}\mathrel+\E{}$\6
\&{if} ${}(\|f\MG\\{unit\_facts\_size}\G\|f\MG\\{unit\_facts\_capacity}){}$\5
${}\{{}$\1\6
${}\.{FS\_REALLOC}(\|f\MG\\{unit\_facts},\39\|f\MG\\{unit\_facts\_capacity}*%
\T{2},\39{}$\&{sizeof} ${}({*}\|f\MG\\{unit\_facts}));{}$\6
${}\|f\MG\\{unit\_facts\_capacity}\MRL{*{\K}}\T{2};{}$\6
\4${}\}{}$\2\6
${}\\{head\_tail\_clear}({\AND}\|f\MG\\{unit\_facts}[\|f\MG\\{unit\_facts%
\_size}]);{}$\6
${}\|f\MG\\{unit\_facts\_size}\PP{}$;\par
\fi

\M{170}And free them.
\Y\B\4\X42:Destroy funcsat type\X${}\mathrel+\E{}$\6
$\\{free}(\|f\MG\\{unit\_facts}){}$;\par
\fi

\M{171}

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{void} \\{minimizeUip}(\&{funcsat} ${}{*}\|f,\39{}$\&{clause} ${}{*}%
\\{learned}){}$;\par
\fi

\N{3}{172}\PB{\\{litpos}}. The \PB{\\{litpos}} structure maintains a mapping of
literals to indices
-- so that one can quickly query, ``is this literal in this clause?'' The
\PB{\\{indices}} field is literally just a table indexed by \PB{\&{literal}}s
and mapping to
associated clause indices.

\Y\B\4\D$\.{NO\_POS}$ \5
\.{UINTPTR\_MAX}\par
\Y\B\4\X38:Internal types\X${}\mathrel+\E{}$\6
\&{struct} \&{litpos} ${}\{{}$\1\6
\&{clause} ${}{*}\|c{}$;\C{ associated clause }\6
\&{struct} \&{vec\_uintptr} ${}{*}\\{indices}{}$;\C{ size is normally \PB{$\|f%
\MG\\{numVars}$} }\2\6
${}\}{}$;\par
\fi

\M{173}
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{litpos\_init}(\&{struct} \&{litpos} ${}{*}%
\|r){}$\1\1\2\2\6
${}\{{}$\1\6
${}\|r\MG\|c\K\NULL;{}$\6
${}\|r\MG\\{indices}\K\\{vec\_uintptr\_init}(\T{2});{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{void} \\{litpos\_destroy}(\&{struct} \&{litpos} ${}{*}%
\\{lp}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{vec\_uintptr\_destroy}(\\{lp}\MG\\{indices});{}$\6
\4${}\}{}$\2\par
\fi

\M{174}Maps the literal \PB{${*}\|p$} to its index in the current clause. We
require a pointer
to ``prove'' that the literal is in the clause.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{litpos\_set}(\&{struct} \&{litpos} ${}{*}%
\\{lp},\39{}$\&{literal} ${}{*}\|p){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\\{lp}\MG\|c\MG\\{data}\Z\|p);{}$\6
${}\\{assert}(\|p<\\{lp}\MG\|c\MG\\{data}+\\{lp}\MG\|c\MG\\{size});{}$\6
${}\\{lp}\MG\\{indices}\MG\\{data}[\\{fs\_lit2var}({*}\|p)]\K(\&{uintptr\_t})(%
\|p-\\{lp}\MG\|c\MG\\{data});{}$\6
\4${}\}{}$\2\par
\fi

\M{175}Various ways to test/get a literal.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{literal} ${}{*}{}$\\{litpos\_lit}(\&{struct} %
\&{litpos} ${}{*}\\{lp},\39{}$\&{literal} \|l)\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}{\AND}\\{lp}\MG\|c\MG\\{data}[\\{litpos\_pos}(\\{lp},\39\|l)];{}$%
\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{uintptr\_t} \\{litpos\_pos}(\&{struct} \&{litpos}
${}{*}\\{lp},\39{}$\&{literal} \|l)\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{lp}${}\MG\\{indices}\MG\\{data}[\\{fs\_lit2var}(\|l)];{}$\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{bool} \\{litpos\_contains}(\&{struct} \&{litpos}
${}{*}\\{lp},\39{}$\&{literal} \|l)\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{lp}${}\MG\\{indices}\MG\\{data}[\\{fs\_lit2var}(\|l)]\I\.{NO%
\_POS};{}$\6
\4${}\}{}$\2\par
\fi

\M{176}Removes the mapping for \PB{\&{literal}} \PB{\|p}. We don't take a
pointer because \PB{\|p}
may not be in the clause.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{litpos\_unset}(\&{struct} \&{litpos} ${}{*}%
\\{lp},\39{}$\&{literal} \|p)\1\1\2\2\6
${}\{{}$\1\6
${}\\{lp}\MG\\{indices}\MG\\{data}[\\{fs\_lit2var}(\|p)]\K\.{NO\_POS};{}$\6
\4${}\}{}$\2\par
\fi

\M{177}Clears all positions and removes clause association.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{litpos\_clear}(\&{struct} \&{litpos} ${}{*}%
\\{lp}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{for\_vec\_uintptr} ${}(\\{up},\39\\{lp}\MG\\{indices}){}$\1\5
${}{*}\\{up}\K\.{NO\_POS};{}$\2\6
\4${}\}{}$\2\par
\fi

\M{178}Check invariant.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{inline} \&{void} \\{litpos\_check}(\&{struct} \&{litpos} ${}{*}\\{lp}){}$\1%
\1\2\2\6
${}\{{}$\6
\8\#\&{ifndef} \.{NDEBUG}\1\6
\&{literal} ${}{*}\|p;{}$\7
\&{for\_clause} ${}(\|p,\39\\{lp}\MG\|c){}$\1\5
${}\\{assert}(\\{lp}\MG\|c\MG\\{data}[\\{litpos\_pos}(\\{lp},\39{*}\|p)]\E{*}%
\|p);{}$\2\6
\8\#\&{endif}\6
\4${}\}{}$\2\par
\fi

\M{179}The next few sections deal with how \PB{\&{litpos}} is used during
solving.

When a new \PB{\&{funcsat}} gets instantiated, we need to make sure it has a %
\PB{\&{litpos}}
in it.

\Y\B\4\X41:Initialize funcsat type\X${}\mathrel+\E{}$\6
$\\{litpos\_init}({\AND}\|f\MG\\{litpos\_uip});{}$\6
${}\|f\MG\\{litpos\_uip}.\|c\K{\AND}\|f\MG\\{uipClause};{}$\6
${}\\{vec\_uintptr\_grow\_to}(\|f\MG\\{litpos\_uip}.\\{indices},\39\|f\MG%
\\{numVars}+\T{1});{}$\6
${}\\{vec\_uintptr\_push}(\|f\MG\\{litpos\_uip}.\\{indices},\39\.{NO\_POS}){}$;%
\par
\fi

\M{180}When resizing, resize with no new position info.

\Y\B\4\X72:Incrementally resize internal data structures up to new \PB{%
\\{numVars}}\X${}\mathrel+\E{}$\6
$\\{vec\_uintptr\_push}(\|f\MG\\{litpos\_uip}.\\{indices},\39\.{NO\_POS}){}$;%
\par
\fi

\M{181}When a new \PB{\&{funcsat}} is destroy, we free.
\Y\B\4\X42:Destroy funcsat type\X${}\mathrel+\E{}$\6
$\\{litpos\_destroy}({\AND}\|f\MG\\{litpos\_uip}){}$;\par
\fi

\M{182}When conflict analysis begins, we will initialize our
(already-allocated)
\PB{\&{litpos}} with the positions of all literals in the conflicting clause.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{litpos\_init\_from\_uip\_clause}(\&{funcsat}
${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} ${}{*}\|p;{}$\6
\&{struct} \&{litpos} ${}{*}\\{lp}\K{\AND}\|f\MG\\{litpos\_uip};{}$\7
${}\\{assert}(\|f\MG\\{numVars}+\T{1}\E\\{lp}\MG\\{indices}\MG\\{size});{}$\6
${}\\{assert}(\\{lp}\MG\|c\E{\AND}\|f\MG\\{uipClause});{}$\6
\&{for\_clause} ${}(\|p,\39\\{lp}\MG\|c){}$\1\5
${}\\{litpos\_set}(\\{lp},\39\|p);{}$\2\6
\4${}\}{}$\2\par
\fi

\M{183}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{void} \\{litpos\_init}(\&{struct} \&{litpos}
${}{*});{}$\6
\&{static} \&{inline} \&{void} \\{litpos\_destroy}(\&{struct} \&{litpos} ${}{*}%
\\{lp});{}$\6
\&{static} \&{inline} \&{void} \\{litpos\_init\_from\_uip\_clause}(\&{funcsat}
${}{*}\|f);{}$\6
\&{static} \&{inline} \&{void} \\{litpos\_set}(\&{struct} \&{litpos} ${}{*}%
\\{lp},\39{}$\&{literal} ${}{*}\|p);{}$\6
\&{static} \&{inline} \&{void} \\{litpos\_unset}(\&{struct} \&{litpos} ${}{*}%
\\{lp},\39{}$\&{literal} \|p);\6
\&{static} \&{inline} \&{literal} ${}{*}{}$\\{litpos\_lit}(\&{struct} %
\&{litpos} ${}{*}\\{pos},\39{}$\&{literal} \|l);\6
\&{static} \&{inline} \&{uintptr\_t} \\{litpos\_pos}(\&{struct} \&{litpos}
${}{*}\\{lp},\39{}$\&{literal} \|l);\6
\&{static} \&{inline} \&{bool} \\{litpos\_contains}(\&{struct} \&{litpos}
${}{*}\\{pos},\39{}$\&{literal} \|l);\6
\&{static} \&{inline} \&{void} \\{litpos\_clear}(\&{struct} \&{litpos} ${}{*}%
\\{lp});{}$\6
\&{extern} \&{void} \\{litpos\_check}(\&{struct} \&{litpos} ${}{*}\\{lp}){}$;%
\par
\fi

\N{2}{184}Clause sweeping.

It turns you need to sweep the clause database from time to time. \funcsat\
exposes several strategios for sweeping.

\fi

\N{3}{185}glucose strategy. The first strategy we discuss is the %
\textit{literal
blocks distance} (\LBD) heuristic first introduced by glucose. (In this paper:
``Predicting Learnt Clauses Quality in Modern SAT Solvers'' by Audemard and
Simon.) The \LBD\ score of a clause is the number of different decision levels
of the literals that participate in a clause. For example, for the clause $(-5
\or 6 \or 7)$, if $-5$ and $6$ were set at level 1 and $7$ at level 2, then the
\LBD\ of the clause is 2. Incidentally, clauses with \LBD\ 2 are special --
they
are called \textit{glue clauses} because they glue decision levels together.

We compute the \LBD\ score by walking over the clause and counting levels. But
we use a trick borrowed from lookahead solvers: if a literal of level $d$
occurs
in the clause, we map that level $d$ to a counter value $c$. If there is a
level
in the map that is mapped to something other than $c$, we know it didn't occur
in this clause. This makes ``clearing'' the map trivial -- we simply increment
the counter (which is done on entry to this function).

Our auxiliary map is \PB{$\|f\MG\\{LBD\_levels}$}. \PB{$\|f\MG\\{LBD\_levels}.%
\\{data}[\|d]\E\|f\MG\\{LBD\_count}$}
iff we've seen a literal l in \PB{\|c} whose level is \PB{\|d}. \PB{$\|f\MG%
\\{LBD\_count}$} is our
counter.

Things to do:
\orderedlist

\li I may eventually add a callback to adjust the \LBD\ of clauses as they are
unit propagated.

\endorderedlist

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{uint8\_t} \\{LBD\_compute\_score}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{uint8\_t} \\{score}${}\K\T{0};{}$\6
\&{struct} \&{clause\_iter} \\{it};\6
\8\#\&{ifndef} \.{NDEBUG}\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\\{ix}){}$;%
\C{ only used by \PB{\\{assert}} }\6
\8\#\&{endif}\7
${}\|f\MG\\{LBD\_count}\PP{}$;\C{ effectively zeros \PB{$\|f\MG\\{LBD%
\_levels}$} }\6
${}\\{clause\_iter\_init}(\|f,\39\\{ix},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
\&{literal} \\{level}${}\K\\{levelOf}(\|f,\39\\{fs\_lit2var}({*}\|p));{}$\7
${}\\{assert}(\\{level}\I\\{Unassigned});{}$\6
\&{if} ${}(\|f\MG\\{LBD\_levels}.\\{data}[\\{level}]\I\|f\MG\\{LBD\_count}){}$\5
${}\{{}$\1\6
${}\|f\MG\\{LBD\_levels}.\\{data}[\\{level}]\K\|f\MG\\{LBD\_count};{}$\6
${}\\{score}\PP;{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{score}>\.{LBD\_SCORE\_MAX}){}$\1\5
\&{break};\C{ who cares if the score is big. }\2\6
\4${}\}{}$\2\6
${}\\{assert}(\|h\MG\\{sz}\E\T{0}\V\\{score}\I\T{0}){}$;\C{ \PB{$\\{sz}\I%
\T{0}$} implies \PB{$\\{score}\I\T{0}$} }\6
\&{return} \\{score};\6
\4${}\}{}$\2\par
\fi

\M{186}Like many data structures, auxiliary \LBD\ structures need to be
initialized,
resized, and destroyed. The next few sections take care of this.
\Y\B\4\X41:Initialize funcsat type\X${}\mathrel+\E{}$\6
$\\{vec\_uint64\_mk}({\AND}\|f\MG\\{LBD\_levels},\39\T{2});{}$\6
${}\\{vec\_uint64\_push}({\AND}\|f\MG\\{LBD\_levels},\39\T{0}){}$;\par
\fi

\M{187}
\Y\B\4\X72:Incrementally resize internal data structures up to new \PB{%
\\{numVars}}\X${}\mathrel+\E{}$\6
$\\{vec\_uint64\_push}({\AND}\|f\MG\\{LBD\_levels},\39\T{0}){}$;\par
\fi

\M{188}
\Y\B\4\X42:Destroy funcsat type\X${}\mathrel+\E{}$\6
$\\{vec\_uint64\_unmk}({\AND}\|f\MG\\{LBD\_levels}){}$;\par
\fi

\M{189}
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{LBD\_decay\_after\_conflict}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\6
\8\#\&{if} \T{0}\1\6
\\{varDecayActivity}(\|f);\6
\8\#\&{endif}\6
\4${}\}{}$\2\par
\fi

\M{190}Each time a new, minimized clause is learned, this function is used to
adjust
its \LBD\ heuristic value.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{LBD\_bump\_learned}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} %
\\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_iter} \\{it};\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\\{ix});{}$%
\7
${}\|h\MG\\{lbd\_score}\K\\{LBD\_compute\_score}(\|f,\39\\{ix});{}$\6
${}\\{clause\_iter\_init}(\|f,\39\\{ix},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
${}\\{varBumpScore}(\|f,\39\\{fs\_lit2var}({*}\|p));{}$\6
\4${}\}{}$\2\6
\\{varDecayActivity}(\|f);\6
\4${}\}{}$\2\par
\fi

\M{191}As clauses are being learned, we encounter various ``reason'' clauses
that
participate in the conflict. This function will be called on each of them to
adjust their priority.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{LBD\_bump\_reason}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} %
\\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_iter} \\{it};\7
${}\\{clause\_iter\_init}(\|f,\39\\{ix},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
\&{variable} \|v${}\K\\{fs\_lit2var}({*}\|p);{}$\6
\8\#\&{if} \T{0}\6
\&{uintptr\_t} \|r${}\K\\{getReason}(\|f,\39{}$(\&{literal}) \|v);\7
\&{if} ${}(\|r\I\.{NO\_CLS}){}$\5
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\|r);{}$\7
\&{if} ${}(\|h\MG\\{lbd\_score}\E\T{2}){}$\5
${}\{{}$\C{ bump twice for glue }\1\6
${}\\{varBumpScore}(\|f,\39\\{fs\_lit2var}(\|h\MG\\{lits}[\T{0}]));{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
${}\\{varBumpScore}(\|f,\39\\{fs\_lit2var}({*}\|p));{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{192}The first task of \PB{\\{LBD\_sweep}} is to figure out if it's time to
perform a
sweep. We use essentially the same test as in glucose.


\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{LBD\_sweep}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}\\{user}){}$%
\1\1\2\2\6
${}\{{}$\1\6
\&{uint64\_t} \\{diffConfl}${}\K\|f\MG\\{numConflicts}-\|f\MG\\{LBD\_last\_num%
\_conflicts};{}$\6
\8\#\&{if} \T{0}\6
\&{uint64\_t} \\{avg}${}\K\\{diffConfl}\E\T{0}\?\T{1}:\\{Max}(\T{1},\39%
\\{diffLearn}/\\{diffConfl});{}$\6
\8\#\&{endif}\6
\&{uint64\_t} \\{next}${}\K\|f\MG\\{LBD\_base}+\|f\MG\\{LBD\_increment}*\|f\MG%
\\{numSweeps}{}$;\C{ in the glucose paper they used 20000+500*num }\7
${}\\{assert}(\\{next}>\T{0});{}$\6
\&{if} ${}(\\{diffConfl}>\\{next}){}$\5
${}\{{}$\1\6
${}\PP\|f\MG\\{numSweeps};{}$\6
\X194:Sweep clauses with \LBD\ heuristic\X\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{193}Settings from the glucose paper.
\Y\B\4\X41:Initialize funcsat type\X${}\mathrel+\E{}$\6
$\|f\MG\\{LBD\_base}\K\T{20000};{}$\6
${}\|f\MG\\{LBD\_increment}\K\T{500}{}$;\par
\fi

\M{194}Both original and learned clauses are in the same watcher list data
structure. It would be nice not to have to entirely recreate that structure
every time we want to delete clauses.

First, compute the max number of clauses to delete, $m$. Let $M$ be
\PB{\.{LBD\_SCORE\_MAX}}. Second, compute a histogram of \LBD\ scores. For each
score (in
ascending order) from $n \in [1,M]$, count how many clauses have that
score. Beginning from $M$, compute a running sum $x$ until $x+n > m$. This way
all clauses with score greater than the threshold $n$ will surely be deleted
(unless they are pinned -- more later); scores $n$ and lower contain some
clauses that may be deleted and others that won't. Basically, we've computed a
loose percentile of the clauses to delete.

Next, walk over the learned clauses again and mark to delete those beyond the
threshold. And walk over the watchlists to delete the references to them.

Guess what -- we don't have to sort the learned clauses by priority!

Now if only I can get away with not walking over the watchlists....

\Y\B\4\X194:Sweep clauses with \LBD\ heuristic\X${}\E{}$\6
\&{uint64\_t} \\{bad\_clauses};\C{ num. clauses worse than threshold }\6
\&{uint8\_t} \\{del\_score};\C{ deletion threshold }\6
\&{uint64\_t} \\{max\_del}${}\K\|f\MG\\{learned\_clauses}\MG\\{size}/\T{2},{}$ %
\\{num\_del}${}\K\T{0};{}$\7
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{1},\39\.{"\%ju\ learned\ clauses}\)\.{%
\\n"},\39\|f\MG\\{learned\_clauses}\MG\\{size});{}$\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{1},\39\.{"max\_del\ is\ \%"}\\{PRIu64}%
\.{"\\n"},\39\\{max\_del});{}$\6
\X195:Create histogram of \LBD\ scores and compute \PB{\\{del\_score}} and \PB{%
\\{bad\_clauses}}\X\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{2},\39\.{"bad\_clauses\ is\ \%"}%
\\{PRIu64}\.{"\\n"},\39\\{bad\_clauses});{}$\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{2},\39\.{"del\_score\ is\ \%"}\\{PRIu8}%
\.{"\\n"},\39\\{del\_score});{}$\6
\&{if} ${}(\\{del\_score}>\T{2}){}$\5
${}\{{}$\1\6
\X198:Delete clauses worse than \LBD\ score of \PB{\\{del\_score}}\X\6
\X200:Delete middling clauses by \LBD\X\6
\4${}\}{}$\2\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{1},\39\.{"deleted\ \%"}\\{PRIu64}\.{"\
clauses\\n"},\39\\{num\_del});{}$\6
${}\|f\MG\\{LBD\_last\_num\_conflicts}\K\|f\MG\\{numConflicts}{}$;\par
\U192.\fi

\M{195}
\Y\B\4\X195:Create histogram of \LBD\ scores and compute \PB{\\{del\_score}}
and \PB{\\{bad\_clauses}}\X${}\E{}$\6
$\\{del\_score}\K\T{0},\39\\{bad\_clauses}\K\T{0};{}$\6
${}\\{vec\_uint64\_zero}({\AND}\|f\MG\\{LBD\_histogram});{}$\6
\&{for\_vec\_uintptr} ${}(\\{ix\_cls},\39\|f\MG\\{learned\_clauses}){}$\5
${}\{{}$\1\6
${}\\{assert}(\\{clause\_head\_ptr}(\|f,\39{*}\\{ix\_cls})\MG\\{lbd\_score}>%
\T{0});{}$\6
${}\|f\MG\\{LBD\_histogram}.\\{data}[\\{clause\_head\_ptr}(\|f,\39{*}\\{ix%
\_cls})\MG\\{lbd\_score}]\PP;{}$\6
\4${}\}{}$\2\6
\&{for} (\&{uint8\_t} \|s${}\K\.{LBD\_SCORE\_MAX};{}$ ${}\|s>\T{0};{}$ ${}\|s%
\MM){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{bad\_clauses}+\|f\MG\\{LBD\_histogram}.\\{data}[\|s]>\\{max%
\_del}){}$\5
${}\{{}$\1\6
${}\\{del\_score}\K\|s;{}$\6
\&{break};\6
\4${}\}{}$\2\6
${}\\{bad\_clauses}\MRL{+{\K}}\|f\MG\\{LBD\_histogram}.\\{data}[\|s];{}$\6
\4${}\}{}$\2\6
\\{assert}(\\{del\_score});\par
\U194.\fi

\M{196}
\Y\B\4\X196:We can mark head \PB{\|h} for deletion\X${}\E{}$\6
$(\|h\MG\\{is\_learned}\W\R\|h\MG\\{is\_reason}\W\|h\MG\\{where}\E\.{CLAUSE%
\_WATCHED}\W\|h\MG\\{lbd\_score}>\\{del\_score}{}$)\par
\U199.\fi

\M{197}Same as previous section except we assume the clause is learned.
\Y\B\4\X197:We can mark learned head \PB{\|h} for deletion\X${}\E{}$\6
$(\R\|h\MG\\{is\_reason}\W\|h\MG\\{where}\E\.{CLAUSE\_WATCHED}\W\|h\MG\\{lbd%
\_score}>\\{del\_score}{}$)\par
\U198.\fi

\M{198}Deleting the clauses has two steps. First we walk the watchlist to
delete the
corresponding watches. Second we walk the learned clauses free them globally --
this way we don't have dangling pointers.

\Y\B\4\X198:Delete clauses worse than \LBD\ score of \PB{\\{del\_score}}\X${}%
\E{}$\6
\&{if} (\\{bad\_clauses})\5
${}\{{}$\1\6
\&{uintptr\_t} \|i${},{}$ \\{new\_size};\7
\&{for} (\&{variable} \|v${}\K\T{1};{}$ ${}\|v\Z\|f\MG\\{numVars};{}$ ${}\|v%
\PP){}$\5
${}\{{}$\1\6
\&{struct} \&{watchlist\_elt} ${}{*}\\{elt},{}$ ${}{*}\\{dump};{}$\6
\&{struct} \&{watchlist} ${}{*}\\{wl};{}$\7
${}\\{wl}\K{\AND}\|f\MG\\{watches}.\\{wlist}{}$[\\{fs\_lit2idx}((\&{literal}) %
\|v)]${},\39\\{new\_size}\K\\{wl}\MG\\{size};{}$\6
\&{for\_watchlist} ${}(\\{elt},\39\\{dump},\39\\{wl}){}$\5
${}\{{}$\1\6
\X199:Delete watchlist \PB{\\{elt}} if score no less than \PB{\\{del\_score}}\X%
\6
\4${}\}{}$\2\6
${}\\{wl}\MG\\{size}\K\\{new\_size};{}$\6
${}\\{wl}\K{\AND}\|f\MG\\{watches}.\\{wlist}[\\{fs\_lit2idx}({-}{}$(%
\&{literal}) \|v)]${},\39\\{new\_size}\K\\{wl}\MG\\{size};{}$\6
\&{for\_watchlist} ${}(\\{elt},\39\\{dump},\39\\{wl}){}$\5
${}\{{}$\1\6
\X199:Delete watchlist \PB{\\{elt}} if score no less than \PB{\\{del\_score}}\X%
\6
\4${}\}{}$\2\6
${}\\{wl}\MG\\{size}\K\\{new\_size};{}$\6
\4${}\}{}$\2\6
\&{for} ${}(\|i\K\T{0},\39\\{new\_size}\K\T{0};{}$ ${}\|i<\|f\MG\\{learned%
\_clauses}\MG\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{uintptr\_t} \\{elt}${}\K\|f\MG\\{learned\_clauses}\MG\\{data}[\|i];{}$\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39%
\\{elt});{}$\7
\&{if} (\X197:We can mark learned head \PB{\|h} for deletion\X)\5
${}\{{}$\1\6
${}\\{num\_del}\PP,\39\\{bad\_clauses}\MM;{}$\6
${}\|f\MG\\{numLearnedDeleted}\PP;{}$\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{6},\39\.{"deleted\ \%"}\\{PRIuPTR}\.{"%
\\n"},\39\\{elt});{}$\6
${}\\{clause\_release}(\|f,\39\\{elt});{}$\6
\4${}\}{}$\2\6
\&{else}\1\5
${}\|f\MG\\{learned\_clauses}\MG\\{data}[\\{new\_size}\PP]\K\\{elt};{}$\2\6
\4${}\}{}$\2\6
${}\|f\MG\\{learned\_clauses}\MG\\{size}\K\\{new\_size};{}$\6
\4${}\}{}$\2\par
\U194.\fi

\M{199}
\Y\B\4\X199:Delete watchlist \PB{\\{elt}} if score no less than \PB{\\{del%
\_score}}\X${}\E{}$\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\\{elt}\MG%
\\{cls});{}$\7
\&{if} (\X196:We can mark head \PB{\|h} for deletion\X)\5
${}\{{}$\1\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"sweep"},\39\T{5}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{5},\39\.{"marked\ clause\ "});{}$\6
${}\\{fs\_clause\_head\_print}(\|f,\39\\{fs\_dbgout}(\|f),\39\\{elt}\MG%
\\{cls});{}$\6
${}\\{fprintf}(\\{fs\_dbgout}(\|f),\39\.{"\ score\ is\ \%x"},\39{}$(%
\&{unsigned}) \\{clause\_head\_ptr}${}(\|f,\39\\{elt}\MG\\{cls})\MG\\{lbd%
\_score});{}$\6
\.{NEWLINE}(\\{fs\_dbgout}(\|f));\6
\4${}\}{}$\2\6
${}\\{new\_size}\MM;{}$\6
\&{continue};\C{ means to delete this \PB{\&{watchlist\_elt}} }\6
\4${}\}{}$\2\6
${}{*}\\{dump}\K{*}\\{elt},\39\\{watchlist\_next\_elt}(\\{dump},\39\\{wl}){}$;%
\C{ keep \PB{\\{elt}} in this \PB{\\{wl}} }\par
\U198.\fi

\M{200}This isn't implemented yet.

\Y\B\4\X200:Delete middling clauses by \LBD\X${}\E{}$\par
\U194.\fi

\M{201}Obviously we should initialize the histogram when \funcsat\ starts up.
\Y\B\4\X41:Initialize funcsat type\X${}\mathrel+\E{}$\6
$\\{vec\_uint64\_mk}({\AND}\|f\MG\\{LBD\_histogram},\39\.{LBD\_SCORE\_MAX}+%
\T{1});{}$\6
${}\|f\MG\\{LBD\_histogram}.\\{size}\K\.{LBD\_SCORE\_MAX}+\T{1}{}$;\par
\fi

\M{202}
\Y\B\4\X42:Destroy funcsat type\X${}\mathrel+\E{}$\6
$\\{vec\_uint64\_unmk}({\AND}\|f\MG\\{LBD\_histogram}){}$;\par
\fi

\M{203}
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{int} \\{LBD\_compare\_rev}(\&{void} ${}{*}\\{fp},\39{}$\&{const} %
\&{void} ${}{*}\\{cl1},\39{}$\&{const} \&{void} ${}{*}\\{cl2}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{funcsat} ${}{*}\|f\K{}$(\&{funcsat} ${}{*}){}$ \\{fp};\6
\&{struct} \&{clause\_head} ${}{*}\\{c1}\K\\{clause\_head\_ptr}(\|f,\39{*}{}$(%
\&{uintptr\_t} ${}{*}){}$ \\{cl1});\6
\&{struct} \&{clause\_head} ${}{*}\\{c2}\K\\{clause\_head\_ptr}(\|f,\39{*}{}$(%
\&{uintptr\_t} ${}{*}){}$ \\{cl2});\6
\&{uint64\_t} \\{s1}${}\K\\{c1}\MG\\{lbd\_score},{}$ \\{s2}${}\K\\{c2}\MG\\{lbd%
\_score};{}$\7
\&{if} ${}(\\{s1}\E\\{s2}){}$\1\5
\&{return} \T{0};\2\6
\&{else} \&{if} ${}(\\{s1}>\\{s2}){}$\1\5
\&{return} ${}{-}\T{1};{}$\2\6
\&{else}\1\5
\&{return} \T{1};\2\6
\4${}\}{}$\2\par
\fi

\M{204}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{int} \\{compareByActivityRev}(\&{const} \&{void} ${}{*}\\{cl1},%
\39{}$\&{const} \&{void} ${}{*}\\{cl2});{}$\6
\&{static} \&{int} \\{LBD\_compare\_rev}(\&{void} ${}{*}\|f,\39{}$\&{const} %
\&{void} ${}{*}\\{cl1},\39{}$\&{const} \&{void} ${}{*}\\{cl2});{}$\6
\&{void} \\{LBD\_bump\_reason}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} \|c);%
\6
\&{void} \\{LBD\_bump\_learned}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} %
\|C);\6
\&{static} \&{inline} \&{uint8\_t} \\{LBD\_compute\_score}(\&{funcsat} ${}{*}%
\|f,\39{}$\&{uintptr\_t} \|c);\6
\&{void} \\{LBD\_decay\_after\_conflict}(\&{funcsat} ${}{*}\|f);{}$\6
\&{void} \\{LBD\_sweep}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}%
\\{user}){}$;\par
\fi

\M{205}In order to use the \LBD\ strategy, we expose a client function.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{funcsatSetupLbdGc}(\&{funcsat\_config} ${}{*}\\{conf}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{conf}\MG\\{gc}\K\\{true};{}$\6
${}\\{conf}\MG\\{sweepClauses}\K\\{LBD\_sweep};{}$\6
${}\\{conf}\MG\\{bumpReason}\K\\{LBD\_bump\_reason};{}$\6
${}\\{conf}\MG\\{bumpLearned}\K\\{LBD\_bump\_learned};{}$\6
${}\\{conf}\MG\\{decayAfterConflict}\K\\{LBD\_decay\_after\_conflict};{}$\6
\4${}\}{}$\2\par
\fi

\M{206}
\Y\B\4\X15:External declarations\X${}\mathrel+\E{}$\6
\&{void} \\{funcsatSetupLbdGc}(\&{funcsat\_config} ${}{*}){}$;\par
\fi

\N{3}{207}activity strategy.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{claActivitySweep}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}%
\\{user}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{static} \&{uint64\_t} \\{num}${}\K\T{0},{}$ \\{lastNumConflicts}${}\K%
\T{0},{}$ \\{lastNumLearnedClauses}${}\K\T{0};{}$\6
\8\#\&{if} \T{0}\6
\&{const} \&{uint64\_t} \\{diffConfl}${}\K\|f\MG\\{numConflicts}-%
\\{lastNumConflicts};{}$\6
\&{const} \&{uint64\_t} \\{diffLearn}${}\K\|f\MG\\{numLearnedClauses}-%
\\{lastNumLearnedClauses};{}$\6
\&{uint64\_t} \\{size}${}\K\|f\MG\\{learnedClauses}.\\{size};{}$\6
\&{double} \\{extraLim}${}\K\|f\MG\\{claInc}/(\\{size}*\T{1.\$F});{}$\7
\&{if} ${}(\|f\MG\\{numLearnedClauses}*\T{1.\$F}\G\|f\MG\\{maxLearned}){}$\5
${}\{{}$\1\6
${}\PP\|f\MG\\{numSweeps};{}$\7
\&{uint64\_t} \\{numDeleted}${}\K\T{0}{}$;\C{ sort by activity and delete half
}\7
${}\\{qsort}(\|f\MG\\{learnedClauses}.\\{data},\39\|f\MG\\{learnedClauses}.%
\\{size},\39{}$\&{sizeof}(\&{clause} ${}{*}),\39\\{compareByActivityRev});{}$\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"sweep"},\39\T{5}){}$\5
${}\{{}$\1\6
\&{uint64\_t} \\{dupCount}${}\K\T{0};{}$\6
\&{int32\_t} \\{lastLbd}${}\K\.{LBD\_SCORE\_MAX};{}$\6
\&{FILE} ${}{*}\\{out}\K\|f\MG\\{conf}\MG\\{debugStream};{}$\7
${}\\{fprintf}(\\{out},\39\.{"sorted:\\n"});{}$\7
\&{clause} ${}{*}{*}\\{it};{}$\7
\&{forVectorRev} (\&{clause} ${}{*}{*},\39\\{it},\39{\AND}\|f\MG%
\\{learnedClauses}){}$\5
${}\{{}$\1\6
\&{if} ${}(({*}\\{it})\MG\\{lbdScore}\E\\{lastLbd}){}$\5
${}\{{}$\1\6
${}\\{dupCount}\PP;{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\\{dupCount}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"(repeats\ \%"}\\{PRIu64}\.{"\ times)\ \%d\ "},\39%
\\{dupCount},\39({*}\\{it})\MG\\{lbdScore});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"\%d\ "},\39({*}\\{it})\MG\\{lbdScore});{}$\6
\4${}\}{}$\2\6
${}\\{dupCount}\K\T{0};{}$\6
${}\\{lastLbd}\K({*}\\{it})\MG\\{lbdScore};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{dupCount}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{out},\39\.{"\%d\ (repeats\ \%"}\\{PRIu64}\.{"\ times)\ "},\39%
\\{lastLbd},\39\\{dupCount});{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{out},\39\.{"done\\n"});{}$\6
\4${}\}{}$\C{ restore proper clause ids after sort. \PB{%
\\{funcsatRemoveClause}} depends on this. }\2\6
\&{for} (\&{uintmax\_t} \|i${}\K\T{0};{}$ ${}\|i<\|f\MG\\{learnedClauses}.%
\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{clause} ${}{*}\|c\K\|f\MG\\{learnedClauses}.\\{data}[\|i];{}$\6
\4${}\}{}$\C{ remove clauses with 0 activity }\2\6
\8\#\&{if} \T{0}\6
\&{for} (\&{variable} \|i${}\K\T{0};{}$ ${}\|i<\|f\MG\\{learnedClauses}.%
\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{clause} ${}{*}\|c\K\|f\MG\\{learnedClauses}.\\{data}[\|i];{}$\7
\&{if} ${}(\|c\MG\\{activity}\E\T{0.\$F}){}$\5
${}\{{}$\1\6
\&{clause} ${}{*}\\{rmClause}\K\\{funcsatRemoveClause}(\|f,\39\|c);{}$\7
\&{if} (\\{rmClause})\5
${}\{{}$\1\6
\\{clauseFree}(\|c);\6
${}\MM\|f\MG\\{numLearnedClauses},\39\PP\|f\MG\\{numLearnedDeleted},\39\PP%
\\{numDeleted};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{else}\1\5
\&{break};\2\6
\4${}\}{}$\2\6
\8\#\&{endif}\7
\&{const} \&{uint64\_t} \\{max}${}\K\|f\MG\\{learnedClauses}.\\{size}/\T{2};{}$%
\7
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{1},\39\.{"deleting\ at\ most\ \%"}%
\\{PRIu64}\.{"\ clauses\ (of\ \%ju)\\n}\)\.{"},\39\\{max},\39\|f\MG%
\\{learnedClauses}.\\{size});{}$\6
\&{for} (\&{variable} \|i${}\K\T{0};{}$ ${}\|i<\|f\MG\\{learnedClauses}.%
\\{size}\W\|f\MG\\{learnedClauses}.\\{size}>\\{max};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{clause} ${}{*}\|c\K\|f\MG\\{learnedClauses}.\\{data}[\|i];{}$\7
\&{if} ${}(\|c\MG\\{size}>\T{2}){}$\5
${}\{{}$\1\6
\&{clause} ${}{*}\\{rmClause}\K\\{funcsatRemoveClause}(\|f,\39\|c);{}$\7
\&{if} (\\{rmClause})\5
${}\{{}$\1\6
\\{clauseFree}(\|c);\6
${}\MM\|f\MG\\{numLearnedClauses},\39\PP\|f\MG\\{numLearnedDeleted},\39\PP%
\\{numDeleted};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{1},\39\.{">>>\ deleted\ \%"}\\{PRIu64}%
\.{"\ clauses\\n"},\39\\{numDeleted});{}$\6
${}\\{num}\PP;{}$\6
${}\\{lastNumLearnedClauses}\K\|f\MG\\{numLearnedClauses};{}$\6
${}\\{lastNumConflicts}\K\|f\MG\\{numConflicts};{}$\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
\4${}\}{}$\2\par
\fi

\M{208}More bupming.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{bumpReasonByActivity}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} %
\\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_iter} \\{it};\7
${}\\{bumpClauseByActivity}(\|f,\39\\{ix});{}$\6
${}\\{clause\_iter\_init}(\|f,\39\\{ix},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
${}\\{varBumpScore}(\|f,\39\\{fs\_lit2var}({*}\|p));{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{void} \\{bumpLearnedByActivity}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} %
\\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_iter} \\{it};\7
${}\\{bumpClauseByActivity}(\|f,\39\\{ix});{}$\6
${}\\{clause\_iter\_init}(\|f,\39\\{ix},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
${}\\{varBumpScore}(\|f,\39\\{fs\_lit2var}({*}\|p));{}$\6
${}\\{varBumpScore}(\|f,\39\\{fs\_lit2var}({*}\|p));{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\MM\|f\MG\\{learnedSizeAdjustCnt}\E\T{0}){}$\5
${}\{{}$\1\6
${}\|f\MG\\{learnedSizeAdjustConfl}\MRL{*{\K}}\|f\MG%
\\{learnedSizeAdjustInc};{}$\6
${}\|f\MG\\{learnedSizeAdjustCnt}\K{}$(\&{uint64\_t}) \|f${}\MG%
\\{learnedSizeAdjustConfl};{}$\6
${}\|f\MG\\{maxLearned}\MRL{*{\K}}\|f\MG\\{learnedSizeInc};{}$\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{1},\39\.{"update:\ ml\ \%f\\n"},\39\|f\MG%
\\{maxLearned});{}$\6
\4${}\}{}$\2\6
\\{varDecayActivity}(\|f);\6
\\{claDecayActivity}(\|f);\6
\4${}\}{}$\2\7
\&{void} \\{lbdBumpActivity}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} \\{ix})%
\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_iter} \\{it};\7
${}\\{clause\_iter\_init}(\|f,\39\\{ix},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
\&{variable} \|v${}\K\\{fs\_lit2var}({*}\|p);{}$\6
\&{uintptr\_t} \\{reason}${}\K\\{getReason}(\|f,\39{}$(\&{literal}) \|v);\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39%
\\{reason});{}$\7
\&{if} ${}(\\{reason}\I\.{NO\_CLS}\W\|h\MG\\{lbd\_score}\E\T{2}){}$\5
${}\{{}$\1\6
${}\\{varBumpScore}(\|f,\39\|v);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{209}
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{void} \\{bumpClauseByActivity}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{uintptr\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_iter} \\{it};\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\\{ix}){}$;%
\C{ if the clause's activity is too large, rescale }\7
\&{if} ${}((\|h\MG\\{activity}\MRL{+{\K}}\|f\MG\\{claInc})>\T{1\_20}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{5},\39\.{"rescale\ for\ activit}\)\.{y\ %
\%f\\n"},\39\|h\MG\\{activity});{}$\6
\&{for\_vec\_uintptr} ${}(\\{ix\_cl},\39\|f\MG\\{learned\_clauses}){}$\5
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\\{h\_cl}\K\\{clause\_head\_ptr}(\|f,\39{*}%
\\{ix\_cl});{}$\6
\&{double} \\{oldActivity}${}\K\\{h\_cl}\MG\\{activity};{}$\7
${}\\{h\_cl}\MG\\{activity}\MRL{*{\K}}\T{1\_-20};{}$\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{5},\39\.{"setting\ activity\ fr}\)\.{om\ %
\%f\ to\ \%f\\n"},\39\\{oldActivity},\39\\{h\_cl}\MG\\{activity});{}$\6
\4${}\}{}$\2\7
\&{double} \\{oldClaInc}${}\K\|f\MG\\{claInc};{}$\7
${}\|f\MG\\{claInc}\MRL{*{\K}}\T{1\_-20};{}$\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{5},\39\.{"setting\ claInc\ from}\)\.{\ %
\%f\ to\ \%f\\n"},\39\\{oldClaInc},\39\|f\MG\\{claInc});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{static} \&{inline} \&{void} \\{varDecayActivity}(\&{funcsat} ${}{*}\|f){}$\1%
\1\2\2\6
${}\{{}$\1\6
${}\|f\MG\\{varInc}\MRL{*{\K}}(\T{1}/\|f\MG\\{varDecay});{}$\6
\4${}\}{}$\2\7
\&{static} \&{void} \\{claDecayActivity}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{double} \\{oldClaInc}${}\K\|f\MG\\{claInc};{}$\7
${}\|f\MG\\{claInc}\MRL{*{\K}}(\T{1}/\|f\MG\\{claDecay});{}$\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{9},\39\.{"decaying\ claInc\ fro}\)\.{m\ %
\%f\ to\ \%f\\n"},\39\\{oldClaInc},\39\|f\MG\\{claInc});{}$\6
\4${}\}{}$\2\par
\fi

\N{2}{210}Restart functions.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{incLubyRestart}(\&{funcsat} ${}{*}\|f,\39{}$\&{bool} \\{skip});\7
\&{bool} \\{funcsatNoRestart}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}%
\|p){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{false};\6
\4${}\}{}$\2\7
\&{bool} \\{funcsatLubyRestart}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}%
\|p){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ((\&{intmax\_t}) \|f${}\MG\\{numConflicts}\G\|f\MG\\{lrestart}\W\|f\MG%
\\{decisionLevel}>\T{2}){}$\5
${}\{{}$\1\6
${}\\{incLubyRestart}(\|f,\39\\{false});{}$\6
\&{return} \\{true};\6
\4${}\}{}$\2\6
\&{return} \\{false};\6
\4${}\}{}$\2\7
\&{bool} \\{funcsatInnerOuter}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}%
\|p){}$\1\1\2\2\6
${}\{{}$\1\6
\&{static} \&{uint64\_t} \\{inner}${}\K\T{100\$U\$L},{}$ \\{outer}${}\K\T{100%
\$U\$L},{}$ \\{conflicts}${}\K\T{1000\$U\$L};{}$\7
\&{if} ${}(\|f\MG\\{numConflicts}\G\\{conflicts}){}$\5
${}\{{}$\1\6
${}\\{conflicts}\MRL{+{\K}}\\{inner};{}$\6
\&{if} ${}(\\{inner}\G\\{outer}){}$\5
${}\{{}$\1\6
${}\\{outer}\MRL{*{\K}}\T{1.1};{}$\6
${}\\{inner}\K\T{100\$U\$L};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{inner}\MRL{*{\K}}\T{1.1};{}$\6
\4${}\}{}$\2\6
\&{return} \\{true};\6
\4${}\}{}$\2\6
\&{return} \\{false};\6
\4${}\}{}$\2\7
\&{bool} \\{funcsatMinisatRestart}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}%
\|p){}$\1\1\2\2\6
${}\{{}$\1\6
\&{static} \&{uint64\_t} \\{cutoff}${}\K\T{100\$U\$L};{}$\7
\&{if} ${}(\|f\MG\\{numConflicts}\G\\{cutoff}){}$\5
${}\{{}$\1\6
${}\\{cutoff}\MRL{*{\K}}\T{1.5};{}$\6
\&{return} \\{true};\6
\4${}\}{}$\2\6
\&{return} \\{false};\6
\4${}\}{}$\C{ This stuff was cribbed from \picosat\ and changed a smidge just
to get bigger  * integers. }\2\7
\&{int64\_t} \\{luby}(\&{int64\_t} \|i)\1\1\2\2\6
${}\{{}$\1\6
\&{int64\_t} \|k;\7
\&{for} ${}(\|k\K\T{1};{}$ ${}\|k<{}$(\&{int64\_t}) \&{sizeof} (\|k); ${}\|k%
\PP){}$\1\6
\&{if} ${}(\|i\E(\T{1}\LL\|k)-\T{1}){}$\1\5
\&{return} \T{1}${}\LL(\|k-\T{1});{}$\2\2\6
\&{for} ${}(\|k\K\T{1};{}$  ; ${}\|k\PP){}$\1\6
\&{if} ${}((\T{1}\LL(\|k-\T{1}))\Z\|i\W\|i<(\T{1}\LL\|k)-\T{1}){}$\1\5
\&{return} \\{luby}${}(\|i-(\T{1}\LL(\|k-\T{1}))+\T{1});{}$\2\2\6
\4${}\}{}$\2\7
\&{void} \\{incLubyRestart}(\&{funcsat} ${}{*}\|f,\39{}$\&{bool} \\{skip})\1\1%
\2\2\6
${}\{{}$\1\6
\&{uint64\_t} \\{delta};\C{ Luby calculation takes a really long time around
255? }\7
\&{if} ${}(\|f\MG\\{lubycnt}>\T{250}){}$\5
${}\{{}$\1\6
${}\|f\MG\\{lubycnt}\K\T{0};{}$\6
${}\|f\MG\\{lubymaxdelta}\K\T{0};{}$\6
${}\|f\MG\\{waslubymaxdelta}\K\\{false};{}$\6
\4${}\}{}$\2\6
${}\\{delta}\K\T{100}*{}$(\&{uint64\_t}) \\{luby}((\&{int64\_t}) ${}\PP\|f\MG%
\\{lubycnt});{}$\6
${}\|f\MG\\{lrestart}\K(\&{int64\_t})(\|f\MG\\{numConflicts}+\\{delta}){}$;\C{
if (waslubymaxdelta) }\C{   report (1, skip ? 'N' : 'R'); }\C{ else }\C{
report (2, skip ? 'n' : 'r'); }\6
\&{if} ${}(\\{delta}>\|f\MG\\{lubymaxdelta}){}$\5
${}\{{}$\1\6
${}\|f\MG\\{lubymaxdelta}\K\\{delta};{}$\6
${}\|f\MG\\{waslubymaxdelta}\K\T{1};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\|f\MG\\{waslubymaxdelta}\K\T{0};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\N{2}{211}Configuration. \funcsat\ is configurable in many ways. The \PB{%
\&{funcsat\_config}}
type is responsible for \funcsat's configuration.

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{void} \\{myDecayAfterConflict}(\&{funcsat} ${}{*}\|f){}$;\par
\fi

\M{212}
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{funcsat\_config} \\{funcsatDefaultConfig} $\K$ $\{$ $.$ $\\{user}\K\NULL$
$,$ $.$ $\\{name}\K\NULL$ $,$ $.$ $\\{usePhaseSaving}\K\\{true}$ $,$ $.$ $%
\\{useSelfSubsumingResolution}\K\\{false}$ $,$ $.$ $\\{minimizeLearnedClauses}%
\K\\{true}$ $,$ $.$ $\\{numUipsToLearn}\K\.{UINT32\_MAX}$ $,$ $.$ $\\{gc}\K%
\\{true}$ $,$ $.$ $\\{maxJailDecisionLevel}\K\T{0}$ $,$ $.$ $\\{logSyms}\K%
\NULL$ $,$ $.$ $\\{printLogLabel}\K\\{true}$ $,$ $.$ $\\{debugStream}\K\NULL$
$,$ $.$ $\\{isTimeToRestart}\K\\{funcsatLubyRestart}$ $,$ $.$ $%
\\{isResourceLimitHit}\K\\{funcsatIsResourceLimitHit}$ $,$ $.$ $%
\\{preprocessNewClause}\K\\{funcsatPreprocessNewClause}$ $,$ $.$ $%
\\{preprocessBeforeSolve}\K\\{funcsatPreprocessBeforeSolve}$ $,$ $.$ $%
\\{getInitialActivity}\K\\{funcsatDefaultStaticActivity}$ $,$ $.$ $%
\\{sweepClauses}\K\\{LBD\_sweep}$ $,$ $.$ $\\{bumpOriginal}\K\\{bumpOriginal}$
$,$ $.$ $\\{bumpReason}\K\\{LBD\_bump\_reason}$ $,$ $.$ $\\{bumpLearned}\K%
\\{LBD\_bump\_learned}$ $,$ $.$ $\\{bumpUnitClause}\K%
\\{bumpUnitClauseByActivity}$ $,$ $.$ $\\{decayAfterConflict}\K\\{LBD\_decay%
\_after\_conflict}$ $,$ $\}$  ;\par
\fi

\M{213}We have the option of bumping the priority of variables as clauses are
added
to \funcsat.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{bumpOriginal}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} \\{ix%
\_clause})\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\\{ix%
\_clause});{}$\6
\&{double} \\{orig\_varInc}${}\K\|f\MG\\{varInc};{}$\6
\&{struct} \&{clause\_iter} \\{it};\7
${}\|f\MG\\{varInc}\MRL{+{\K}}\T{2.}*(\T{1.}/{}$(\&{double}) \|h${}\MG%
\\{sz});{}$\6
${}\\{clause\_iter\_init}(\|f,\39\\{ix\_clause},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
${}\\{varBumpScore}(\|f,\39\\{fs\_lit2var}({*}\|p));{}$\6
\4${}\}{}$\2\6
${}\|f\MG\\{varInc}\K\\{orig\_varInc};{}$\6
\8\#\&{if} \T{0}\7
${}\\{forClause}(\\{it},\39\|c){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{varBumpScore}(\|f,\39\\{fs\_lit2var}({*}\\{it}));{}$\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
\4${}\}{}$\2\7
\&{double} \\{funcsatDefaultStaticActivity}(\&{variable} ${}{*}\|v){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \T{1.\$F};\6
\4${}\}{}$\2\7
\&{void} \\{myDecayAfterConflict}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\\{varDecayActivity}(\|f);\6
\\{claDecayActivity}(\|f);\6
\4${}\}{}$\2\7
\&{void} \\{bumpUnitClauseByActivity}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr%
\_t} \\{ix})\1\1\2\2\6
${}\{{}$\1\6
${}\\{bumpClauseByActivity}(\|f,\39\\{ix});{}$\6
\4${}\}{}$\2\par
\fi

\M{214}Prototypes.
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{void} \\{bumpOriginal}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} \|c);\6
\&{void} \\{bumpReasonByActivity}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} %
\|c);\6
\&{void} \\{bumpLearnedByActivity}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} %
\|c);\6
\&{void} \\{bumpUnitClauseByActivity}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr%
\_t} \|c);\6
\&{void} \\{lbdBumpActivity}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintptr\_t} \|c);\6
\&{static} \&{inline} \&{void} \\{varDecayActivity}(\&{funcsat} ${}{*}\|f);{}$\6
\&{static} \&{void} \\{claDecayActivity}(\&{funcsat} ${}{*}\|f);{}$\6
\&{static} \&{void} \\{bumpClauseByActivity}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{uintptr\_t} \|c);\6
\&{extern} \&{void} \\{varBumpScore}(\&{funcsat} ${}{*}\|f,\39{}$\&{variable} %
\|v);\par
\fi

\M{215}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{void} \\{claActivitySweep}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}%
\\{user}){}$;\par
\fi

\N{2}{216}Initialization. Requires an initialized configuration.

\Y\B\4\X216:Initialize parameters\X${}\E{}$\6
$\|f\MG\\{varInc}\K\T{1.\$F};{}$\6
${}\|f\MG\\{varDecay}\K\T{0.95\$F}{}$;\C{ or 0.999f; }\6
${}\|f\MG\\{claInc}\K\T{1.\$F};{}$\6
${}\|f\MG\\{claDecay}\K\T{0.9999\$F}{}$;\C{ or 0.95f; }\6
${}\|f\MG\\{learnedSizeFactor}\K\T{1.\$F}/\T{3.\$F};{}$\6
${}\|f\MG\\{learnedSizeAdjustConfl}\K\T{25000}{}$;\C{ see \PB{\\{startSolving}}
}\6
${}\|f\MG\\{learnedSizeAdjustCnt}\K\T{25000};{}$\6
${}\|f\MG\\{maxLearned}\K\T{20000.\$F};{}$\6
${}\|f\MG\\{learnedSizeAdjustInc}\K\T{1.5\$F};{}$\6
${}\|f\MG\\{learnedSizeInc}\K\T{1.1\$F}{}$;\par
\U217.\fi

\M{217}Initially allocates a \PB{\&{funcsat}} object.
\Y\B\&{funcsat} ${}{*}{}$\\{funcsatInit}(\&{funcsat\_config} ${}{*}\\{conf}){}$%
\1\1\2\2\6
${}\{{}$\1\6
\&{funcsat} ${}{*}\|f;{}$\7
${}\.{FS\_CALLOC}(\|f,\39\T{1},\39{}$\&{sizeof} ${}({*}\|f));{}$\6
${}\|f\MG\\{conf}\K\\{conf};{}$\6
${}\|f\MG\\{propq}\K\T{0};{}$\6
\X216:Initialize parameters\X\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{1},\39\.{"set\ maxLearned\ to\ \%}\)\.{f%
\\n"},\39\|f\MG\\{maxLearned});{}$\6
${}\\{fslog}(\|f,\39\.{"sweep"},\39\T{1},\39\.{"set\ 1/f->claDecoy\ t}\)\.{o\ %
\%f\\n"},\39\T{1.\$F}/\|f\MG\\{claDecay});{}$\6
${}\|f\MG\\{lrestart}\K\T{1};{}$\6
${}\|f\MG\\{lubycnt}\K\T{0};{}$\6
${}\|f\MG\\{lubymaxdelta}\K\T{0};{}$\6
${}\|f\MG\\{waslubymaxdelta}\K\\{false};{}$\6
${}\|f\MG\\{numVars}\K\T{0};{}$\6
\X41:Initialize funcsat type\X\6
${}\\{clauseInit}({\AND}\|f\MG\\{assumptions},\39\T{0});{}$\6
${}\\{vec\_uintmax\_mk}({\AND}\|f\MG\\{model},\39\T{2});{}$\6
${}\\{vec\_uintmax\_push}({\AND}\|f\MG\\{model},\39\T{0});{}$\6
${}\\{clauseInit}({\AND}\|f\MG\\{phase},\39\T{2});{}$\6
${}\\{clausePush}({\AND}\|f\MG\\{phase},\39\T{0});{}$\6
${}\\{clauseInit}({\AND}\|f\MG\\{level},\39\T{2});{}$\6
${}\\{clausePush}({\AND}\|f\MG\\{level},\39\\{Unassigned});{}$\6
${}\\{vec\_uintmax\_mk}({\AND}\|f\MG\\{decisions},\39\T{2});{}$\6
${}\\{vec\_uintmax\_push}({\AND}\|f\MG\\{decisions},\39\T{0});{}$\6
${}\\{clauseInit}({\AND}\|f\MG\\{trail},\39\T{2});{}$\6
\\{all\_watches\_init}(\|f);\6
${}\\{clauseInit}({\AND}\|f\MG\\{uipClause},\39\T{100});{}$\6
${}\\{vec\_ptr\_mk}({\AND}\|f\MG\\{subsumed},\39\T{10});{}$\6
\&{return} \|f;\6
\4${}\}{}$\2\par
\fi

\M{218}Initializes a \PB{\&{funcsat}} configuration.
\Y\B\&{funcsat\_config} ${}{*}{}$\\{funcsatConfigInit}(\&{void} ${}{*}%
\\{userData}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{funcsat\_config} ${}{*}\\{conf}\K{}$\\{malloc}(\&{sizeof} ${}({*}%
\\{conf}));{}$\7
${}\\{memcpy}(\\{conf},\39{\AND}\\{funcsatDefaultConfig},\39{}$\&{sizeof}
${}({*}\\{conf}));{}$\6
\8\#\&{ifdef} \.{FUNCSAT\_LOG}\6
${}\\{conf}\MG\\{logSyms}\K\\{create\_hashtable}(\T{16},\39\\{hashString},\39%
\\{stringEqual});{}$\6
${}\\{vec\_uintmax\_mk}({\AND}\\{conf}\MG\\{logStack},\39\T{2});{}$\6
${}\\{vec\_uintmax\_push}({\AND}\\{conf}\MG\\{logStack},\39\T{0});{}$\6
${}\\{conf}\MG\\{debugStream}\K\\{stderr};{}$\6
\8\#\&{endif}\6
\&{return} \\{conf};\6
\4${}\}{}$\2\7
\&{void} \\{funcsatConfigDestroy}(\&{funcsat\_config} ${}{*}\\{conf}){}$\1\1\2%
\2\6
${}\{{}$\6
\8\#\&{ifdef} \.{FUNCSAT\_LOG}\1\6
${}\\{hashtable\_destroy}(\\{conf}\MG\\{logSyms},\39\\{true},\39\\{true});{}$\6
${}\\{vec\_uintmax\_unmk}({\AND}\\{conf}\MG\\{logStack});{}$\6
\8\#\&{endif}\6
\\{free}(\\{conf});\6
\4${}\}{}$\2\par
\fi

\M{219}For incrementality, \funcsat\ resizes for a given predicted or known
number of
variables. It just goes through and grows every data structure to fit \PB{%
\\{numVars}}.

\Y\B\&{void} \\{funcsatResize}(\&{funcsat} ${}{*}\|f,\39{}$\&{variable} %
\\{numVars})\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\|f\MG\\{decisionLevel}\E\T{0}){}$;\C{ so we can fix up unit
facts }\6
\&{if} ${}(\\{numVars}>\|f\MG\\{numVars}){}$\5
${}\{{}$\1\6
\&{const} \&{variable} \\{old}${}\K\|f\MG\\{numVars},{}$ \\{new}${}\K%
\\{numVars};{}$\7
${}\|f\MG\\{numVars}\K\\{new};{}$\7
\&{variable} \|i;\7
${}\\{clauseGrowTo}({\AND}\|f\MG\\{uipClause},\39\\{numVars});{}$\6
\X104:Resize internal data structures up to new \PB{\\{numVars}}\X\6
\&{for} ${}(\|i\K\\{old};{}$ ${}\|i<\\{new};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{variable} \|v${}\K\|i+\T{1};{}$\7
\X72:Incrementally resize internal data structures up to new \PB{\\{numVars}}\X%
\6
\8\#\&{if} \T{0}\7
\&{literal} \|l${}\K\\{fs\_var2lit}(\|v);{}$\6
\8\#\&{endif}\7
${}\\{vec\_uintmax\_push}({\AND}\|f\MG\\{model},\39\.{UINTMAX\_MAX});{}$\6
${}\\{clausePush}({\AND}\|f\MG\\{phase},\39{-}\\{fs\_var2lit}(\|v));{}$\6
${}\\{clausePush}({\AND}\|f\MG\\{level},\39\\{Unassigned});{}$\6
${}\\{vec\_uintmax\_push}({\AND}\|f\MG\\{decisions},\39\T{0});{}$\6
\4${}\}{}$\2\7
\&{uintmax\_t} \\{highestIdx}${}\K\\{fs\_lit2idx}({-}{}$(\&{literal}) %
\\{numVars})${}+\T{1};{}$\7
${}\\{assert}(\|f\MG\\{model}.\\{size}\E\\{numVars}+\T{1});{}$\6
${}\\{assert}(\R\|f\MG\\{conf}\MG\\{usePhaseSaving}\V\|f\MG\\{phase}.\\{size}\E%
\\{numVars}+\T{1});{}$\6
${}\\{assert}(\|f\MG\\{level}.\\{size}\E\\{numVars}+\T{1});{}$\6
${}\\{assert}(\|f\MG\\{decisions}.\\{size}\E\\{numVars}+\T{1});{}$\6
${}\\{assert}(\|f\MG\\{reason}\MG\\{size}\E\\{numVars}+\T{1});{}$\6
${}\\{assert}(\|f\MG\\{unit\_facts\_size}\E\\{numVars}+\T{1});{}$\6
${}\\{assert}(\|f\MG\\{uipClause}.\\{capacity}\G\\{numVars});{}$\6
${}\\{assert}(\|f\MG\\{allLevels}.\\{size}\E\\{numVars}+\T{1});{}$\6
${}\\{assert}(\|f\MG\\{watches}.\\{size}\E\\{highestIdx});{}$\6
\&{if} ${}(\\{numVars}>\|f\MG\\{trail}.\\{capacity}){}$\5
${}\{{}$\1\6
${}\.{FS\_REALLOC}(\|f\MG\\{trail}.\\{data},\39\\{numVars},\39{}$\&{sizeof}
${}({*}\|f\MG\\{trail}.\\{data}));{}$\6
${}\|f\MG\\{trail}.\\{capacity}\K\\{numVars};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{220}Destroys a \PB{\&{funcsat}}.

\Y\B\&{void} \\{funcsatDestroy}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} \|i;\7
\&{while} ${}(\|f\MG\\{trail}.\\{size}>\T{0}){}$\1\5
${}\\{trailPop}(\|f,\39\NULL);{}$\2\6
\X42:Destroy funcsat type\X\6
${}\\{clauseDestroy}({\AND}\|f\MG\\{assumptions});{}$\6
${}\\{vec\_uintmax\_unmk}({\AND}\|f\MG\\{model});{}$\6
${}\\{clauseDestroy}({\AND}\|f\MG\\{phase});{}$\6
${}\\{clauseDestroy}({\AND}\|f\MG\\{level});{}$\6
${}\\{vec\_uintmax\_unmk}({\AND}\|f\MG\\{decisions});{}$\6
${}\\{clauseDestroy}({\AND}\|f\MG\\{trail});{}$\6
${}\\{clauseDestroy}({\AND}\|f\MG\\{uipClause});{}$\6
${}\\{vec\_ptr\_unmk}({\AND}\|f\MG\\{subsumed});{}$\6
\\{free}(\|f);\6
\4${}\}{}$\2\par
\fi

\M{221}

\Y\B\&{void} \\{funcsatSetupActivityGc}(\&{funcsat\_config} ${}{*}\\{conf}){}$%
\1\1\2\2\6
${}\{{}$\1\6
${}\\{conf}\MG\\{gc}\K\\{true};{}$\6
${}\\{conf}\MG\\{sweepClauses}\K\\{claActivitySweep};{}$\6
${}\\{conf}\MG\\{bumpReason}\K\\{bumpReasonByActivity};{}$\6
${}\\{conf}\MG\\{bumpLearned}\K\\{bumpLearnedByActivity};{}$\6
${}\\{conf}\MG\\{decayAfterConflict}\K\\{myDecayAfterConflict};{}$\6
\4${}\}{}$\2\7
\&{funcsat\_result} \\{funcsatResult}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{lastResult};{}$\6
\4${}\}{}$\2\par
\fi

\M{222}These two functions are for sanity's sake.

\Y\B\&{funcsat\_result} \\{startSolving}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
${}\|f\MG\\{numSolves}\PP;{}$\6
\&{if} ${}(\|f\MG\\{conflict\_clause}\I\.{NO\_CLS}){}$\5
${}\{{}$\1\6
\&{struct} \&{clause\_head} ${}{*}\|h\K\\{clause\_head\_ptr}(\|f,\39\|f\MG%
\\{conflict\_clause});{}$\7
\&{if} ${}(\|h\MG\\{sz}\E\T{0}){}$\5
${}\{{}$\1\6
\&{return} \.{FS\_UNSAT};\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\|f\MG\\{conflict\_clause}\K\.{NO\_CLS};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{backtrack}(\|f,\39\T{0\$U\$L},\39\NULL,\39\\{true});{}$\6
${}\|f\MG\\{lastResult}\K\.{FS\_UNKNOWN};{}$\6
${}\\{assert}(\|f\MG\\{decisionLevel}\E\T{0});{}$\6
\&{return} \.{FS\_UNKNOWN};\6
\4${}\}{}$\C{*  * Call me whenever (incremental) solving is done, whether
because of a timeout  * or whatever.  }\2\7
\&{static} \&{void} \\{finishSolving}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{\,\}{}$\par
\fi

\M{223}Another break.

\Y\B\&{static} \&{bool} \\{bcpAndJail}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\R\\{bcp}(\|f)){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"solve"},\39\T{2},\39\.{"returning\ false\ at\ }\)%
\.{toplevel\\n"});{}$\6
\&{return} \\{false};\6
\4${}\}{}$\2\6
${}\\{fslog}(\|f,\39\.{"solve"},\39\T{1},\39\.{"bcpAndJail\ trailsiz}\)\.{e\ is%
\ \%ju\\n"},\39\|f\MG\\{trail}.\\{size});{}$\7
\&{clause} ${}{*}{*}\\{cIt};{}$\6
\&{struct} \&{vec\_ptr} ${}{*}\\{watches};{}$\6
\&{uint64\_t} \\{numJails}${}\K\T{0};{}$\6
\8\#\&{if} \T{0}\7
\&{forVector} (\&{clause} ${}{*}{*},\39\\{cIt},\39{\AND}\|f\MG%
\\{origClauses}){}$\5
${}\{{}$\1\6
\&{if} ${}(({*}\\{cIt})\MG\\{is\_watched}){}$\5
${}\{{}$\1\6
\&{literal} ${}{*}\\{lIt};{}$\6
\&{bool} \\{allFalse}${}\K\\{true};{}$\7
${}\\{forClause}(\\{lIt},\39{*}\\{cIt}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{mbool} \\{value}${}\K\\{funcsatValue}(\|f,\39{*}\\{lIt});{}$\7
\&{if} ${}(\\{value}\E\\{false}){}$\1\5
\&{continue};\2\6
${}\\{allFalse}\K\\{false};{}$\6
\&{if} ${}(\\{value}\E\\{true}){}$\5
${}\{{}$\C{ jail the clause, it is satisfied }\1\6
\&{clause} ${}{*}{*}\\{w0}\K{}$(\&{clause} ${}{*}{*}){}$ ${}{\AND}\\{watches}%
\MG\\{data}[\\{fs\_lit2idx}({-}({*}\\{cIt})\MG\\{data}[\T{0}])]{}$;\C{
assert(watcherFind(*cIt, w0, 0)); }\6
\&{clause} ${}{*}{*}\\{w1}\K{}$(\&{clause} ${}{*}{*}){}$ ${}{\AND}\\{watches}%
\MG\\{data}[\\{fs\_lit2idx}({-}({*}\\{cIt})\MG\\{data}[\T{1}])]{}$;\C{
assert(watcherFind(*cIt, w1, 0)); }\C{ clauseUnSpliceWatch(w0, *cIt, 0); }\7
${}\\{clauseUnSpliceWatch}(\\{w1},\39{*}\\{cIt},\39\T{1});{}$\6
${}\\{jailClause}(\|f,\39{*}\\{lIt},\39{*}\\{cIt});{}$\6
${}\\{numJails}\PP;{}$\6
\&{break};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{if} (\\{allFalse})\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"solve"},\39\T{2},\39\.{"returning\ false\ at\ }\)%
\.{toplevel\\n"});{}$\6
\&{return} \\{false};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
${}\\{fslog}(\|f,\39\.{"solve"},\39\T{2},\39\.{"jailed\ \%"}\\{PRIu64}\.{"\
clauses\ at\ topleve}\)\.{l\\n"},\39\\{numJails});{}$\6
\&{return} \\{true};\6
\4${}\}{}$\2\7
\&{bool} \\{funcsatIsResourceLimitHit}(\&{funcsat} ${}{*}\|f,\39{}$\&{void}
${}{*}\|p){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{false};\6
\4${}\}{}$\2\7
\&{funcsat\_result} \\{funcsatPreprocessNewClause}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{void} ${}{*}\|p,\39{}$\&{clause} ${}{*}\|c){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}(\|f\MG\\{lastResult}\K\.{FS\_UNKNOWN});{}$\6
\4${}\}{}$\2\7
\&{funcsat\_result} \\{funcsatPreprocessBeforeSolve}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{void} ${}{*}\|p){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}(\|f\MG\\{lastResult}\K\.{FS\_UNKNOWN});{}$\6
\4${}\}{}$\2\par
\fi

\M{224}Rest of stuff.

\Y\B\&{void} \\{funcsatPrintStats}(\&{FILE} ${}{*}\\{stream},\39{}$\&{funcsat}
${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%"}\\{PRIu64}\.{"\ decisions\\n"},\39\|f%
\MG\\{numDecisions});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%"}\\{PRIu64}\.{"\ propagations\ (\%"}%
\\{PRIu64}\.{"\ unit)\\n"},\39\|f\MG\\{numProps}+\|f\MG\\{numUnitFactProps},\39%
\|f\MG\\{numUnitFactProps});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%"}\\{PRIu64}\.{"\ jailed\ clauses\\n"},%
\39\|f\MG\\{numJails});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%"}\\{PRIu64}\.{"\ conflicts\\n"},\39\|f%
\MG\\{numConflicts});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%"}\\{PRIu64}\.{"\ learned\ clauses\\n"},%
\39\|f\MG\\{numLearnedClauses});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%"}\\{PRIu64}\.{"\ learned\ clauses\ re}\)%
\.{moved\\n"},\39\|f\MG\\{numLearnedDeleted});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%"}\\{PRIu64}\.{"\ learned\ clause\ del}\)%
\.{etion\ sweeps\\n"},\39\|f\MG\\{numSweeps});{}$\6
\&{if} ${}(\R\|f\MG\\{conf}\MG\\{minimizeLearnedClauses}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"c\ (learned\ clause\ m}\)\.{inimisation\ off)%
\\n"});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%"}\\{PRIu64}\.{"\ redundant\ learned\ }\)%
\.{clause\ literals\\n"},\39\|f\MG\\{numLiteralsDeleted});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\R\|f\MG\\{conf}\MG\\{useSelfSubsumingResolution}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"c\ (on-the-fly\ self-}\)\.{subsuming\
resolution}\)\.{\ off)\\n"});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%"}\\{PRIu64}\.{"\ subsumptions\\n"},\39%
\|f\MG\\{numSubsumptions});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"c\ -\ \%"}\\{PRIu64}\.{"\ original\ clauses%
\\n}\)\.{"},\39\|f\MG\\{numSubsumedOrigClauses});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"c\ -\ \%"}\\{PRIu64}\.{"\ UIPs\ (\%2.2lf\%\%)%
\\n"},\39\|f\MG\\{numSubsumptionUips},\39{}$(\&{double}) \|f${}\MG%
\\{numSubsumptionUips}*\T{100.}/{}$(\&{double}) \|f${}\MG%
\\{numSubsumptions});{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%"}\\{PRIu64}\.{"\ restarts\\n"},\39\|f\MG%
\\{numRestarts});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%d\ assumptions\\n"},\39\|f\MG%
\\{assumptions}.\\{size});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%ju\ original\ clau}\)\.{ses\\n"},\39\|f%
\MG\\{orig\_clauses}\MG\\{size});{}$\6
\4${}\}{}$\2\7
\&{void} \\{funcsatPrintColumnStats}(\&{FILE} ${}{*}\\{stream},\39{}$%
\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \\{rusage} \\{usage};\7
${}\\{getrusage}(\.{RUSAGE\_SELF},\39{\AND}\\{usage});{}$\7
\&{double} \\{uTime}${}\K{}$((\&{double}) \\{usage}${}.\\{ru\_utime}.\\{tv%
\_sec})+{}$((\&{double}) \\{usage}${}.\\{ru\_utime}.\\{tv\_usec})/%
\T{1000000};{}$\6
\&{double} \\{sTime}${}\K{}$((\&{double}) \\{usage}${}.\\{ru\_stime}.\\{tv%
\_sec})+{}$((\&{double}) \\{usage}${}.\\{ru\_stime}.\\{tv\_usec})/%
\T{1000000};{}$\7
${}\\{fprintf}(\\{stream},\39\.{"Name,NumDecisions,N}\)\.{umPropagations,NumUf}%
\)\.{Propagations,"}\.{"NumLearnedClauses,N}\)\.{umLearnedClausesRemo}\)%
\.{ved,"}\.{"NumLearnedClauseSwe}\)\.{eps,NumConflicts,Num}\)\.{Subsumptions,"}%
\.{"NumSubsumedOrigClau}\)\.{ses,NumSubsumedUips,}\)\.{NumRestarts,"}%
\.{"UserTimeSeconds,Sys}\)\.{TimeSeconds\\n"});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"\%s,"},\39\|f\MG\\{conf}\MG\\{name});{}$\6
${}\\{fprintf}(\\{stream},\39\.{"\%"}\\{PRIu64}\.{",\%"}\\{PRIu64}\.{",\%"}%
\\{PRIu64}\.{",\%"}\\{PRIu64}\.{",\%"}\\{PRIu64}\.{",\%"}\\{PRIu64}\.{",\%"}%
\\{PRIu64}\.{",\%"}\\{PRIu64}\.{",\%"}\\{PRIu64}\.{",\%"}\\{PRIu64}\.{",\%"}%
\\{PRIu64}\.{",\%.2lf,\%.2lf\\n"},\39\|f\MG\\{numDecisions},\39\|f\MG%
\\{numProps}+\|f\MG\\{numUnitFactProps},\39\|f\MG\\{numUnitFactProps},\39\|f\MG%
\\{numLearnedClauses},\39\|f\MG\\{numLearnedDeleted},\39\|f\MG\\{numSweeps},\39%
\|f\MG\\{numConflicts},\39\|f\MG\\{numSubsumptions},\39\|f\MG%
\\{numSubsumedOrigClauses},\39\|f\MG\\{numSubsumptionUips},\39\|f\MG%
\\{numRestarts},\39\\{uTime},\39\\{sTime});{}$\6
\4${}\}{}$\2\7
\&{void} \\{funcsatBumpLitPriority}(\&{funcsat} ${}{*}\|f,\39{}$\&{literal} %
\|p)\1\1\2\2\6
${}\{{}$\1\6
${}\\{varBumpScore}(\|f,\39\\{fs\_lit2var}(\|p));{}$\6
\4${}\}{}$\C{ FORMERLY INTERNAL.H }\C{ defaults }\2\7
\&{literal} \\{levelOf}(\&{funcsat} ${}{*}\|f,\39{}$\&{variable} \|v)\1\1\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{level}.\\{data}[\|v];{}$\6
\4${}\}{}$\2\7
\&{literal} \\{fs\_var2lit}(\&{variable} \|v)\1\1\2\2\6
${}\{{}$\1\6
\&{literal} \\{result}${}\K{}$(\&{literal}) \|v;\7
\\{assert}((\&{variable}) \\{result}${}\E\|v);{}$\6
\&{return} \\{result};\6
\4${}\}{}$\2\7
\&{inline} \&{variable} \\{fs\_lit2var}(\&{literal} \|l)\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\|l<\T{0}){}$\5
${}\{{}$\1\6
${}\|l\K{-}\|l;{}$\6
\4${}\}{}$\2\6
\&{return} (\&{variable}) \|l;\6
\4${}\}{}$\2\7
\&{uintmax\_t} \\{fs\_lit2idx}(\&{literal} \|l)\1\1\2\2\6
${}\{{}$\C{ just move sign bit into the lowest bit instead of the highest }\1\6
\&{variable} \|v${}\K\\{fs\_lit2var}(\|l);{}$\7
${}\|v\MRL{{\LL}{\K}}\T{1};{}$\6
${}\|v\MRL{{\OR}{\K}}(\|l<\T{0});{}$\6
\&{return} \|v;\6
\4${}\}{}$\2\7
\&{inline} \&{bool} \\{isDecision}(\&{funcsat} ${}{*}\|f,\39{}$\&{variable} %
\|v)\1\1\2\2\6
${}\{{}$\1\6
\&{return} \T{0}${}\I\|f\MG\\{decisions}.\\{data}[\|v];{}$\6
\4${}\}{}$\2\6
\8\#\&{if} \T{0}\7
\&{void} \\{singlesPrint}(\&{FILE} ${}{*}\\{stream},\39{}$\&{clause} ${}{*}%
\\{begin}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{clause} ${}{*}\|c\K\\{begin};{}$\7
\&{if} (\|c)\5
${}\{{}$\1\6
\&{do}\5
${}\{{}$\1\6
\&{clause} ${}{*}\\{next}\K\|c\MG\\{next}[\T{0}];{}$\6
\&{clause} ${}{*}\\{prev}\K\|c\MG\\{prev}[\T{0}];{}$\7
\&{if} ${}(\R\\{next}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"next\ is\ NULL"});{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{prev}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"prev\ is\ NULL"});{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{next}\MG\\{prev}[\T{0}]\I\|c){}$\1\5
${}\\{fprintf}(\\{stream},\39\.{"n*"});{}$\2\6
\&{if} ${}(\\{prev}\MG\\{next}[\T{0}]\I\|c){}$\1\5
${}\\{fprintf}(\\{stream},\39\.{"p*"});{}$\2\6
${}\\{clause\_head\_print\_dimacs}(\\{stream},\39\|c);{}$\6
${}\|c\K\\{next};{}$\6
\&{if} ${}(\|c\I\\{begin}){}$\1\5
${}\\{fprintf}(\\{stream},\39\.{",\ "});{}$\2\6
\4${}\}{}$\2\5
\&{while} ${}(\|c\I\\{begin});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"NULL"});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
\8\#\&{if} \T{0}\7
\&{void} \\{watcherPrint}(\&{FILE} ${}{*}\\{stream},\39{}$\&{clause} ${}{*}\|c,%
\39{}$\&{uint8\_t} \|w)\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\R\|c){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"EMPTY\\n"});{}$\6
\&{return};\6
\4${}\}{}$\2\7
\&{clause} ${}{*}\\{begin}\K\|c;{}$\6
\&{literal} \\{data}${}\K\|c\MG\\{data}[\|w];{}$\7
${}\\{fprintf}(\\{stream},\39\.{"watcher\ list\ contai}\)\.{ning\ lit\ \%ji%
\\n"},\39\|c\MG\\{data}[\|w]);{}$\6
\&{do}\5
${}\{{}$\1\6
\&{uint8\_t} \|i${}\K\|c\MG\\{data}[\T{0}]\E\\{data}\?\T{0}:\T{1};{}$\6
\&{clause} ${}{*}\\{next}\K\|c\MG\\{next}[\|i];{}$\7
\&{if} ${}(\R\\{next}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"next\ is\ NULL\\n"});{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{if} ${}(\R(\\{next}\MG\\{prev}[\\{next}\MG\\{data}[\T{0}]\E\|c\MG\\{data}[%
\|i]\?\T{0}:\T{1}]\E\|c)){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"*"});{}$\6
\4${}\}{}$\2\6
${}\\{clause\_head\_print\_dimacs}(\\{stream},\39\|c);{}$\6
${}\\{fprintf}(\\{stream},\39\.{"\\n"});{}$\6
${}\|c\K\\{next};{}$\6
\4${}\}{}$\2\5
\&{while} ${}(\|c\I\\{begin});{}$\6
\4${}\}{}$\2\7
\&{bool} \\{watcherFind}(\&{clause} ${}{*}\|c,\39{}$\&{clause} ${}{*}{*}%
\\{watches},\39{}$\&{uint8\_t} \|w)\1\1\2\2\6
${}\{{}$\1\6
\&{clause} ${}{*}\\{curr}\K{*}\\{watches},{}$ ${}{*}\\{nx},{}$ ${}{*}%
\\{end};{}$\6
\&{uint8\_t} \\{wi};\6
\&{bool} \\{foundEnd};\7
${}\\{forEachWatchedClause}(\\{curr},\39\|c\MG\\{data}[\|w],\39\\{wi},\39%
\\{nx},\39\\{end},\39\\{foundEnd}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{curr}\E\|c){}$\1\5
\&{return} \\{true};\2\6
\4${}\}{}$\2\7
\&{return} \\{false};\6
\4${}\}{}$\2\7
\&{void} \\{binWatcherPrint}(\&{FILE} ${}{*}\\{stream},\39{}$\&{funcsat} ${}{*}%
\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{variable} \|v;\6
\&{uintmax\_t} \|i;\7
\&{for} ${}(\|v\K\T{1};{}$ ${}\|v\Z\|f\MG\\{numVars};{}$ ${}\|v\PP){}$\5
${}\{{}$\1\6
\&{binvec\_t} ${}{*}\\{bv}\K\|f\MG\\{watchesBin}.\\{data}[\\{fs\_lit2idx}(\\{fs%
\_var2lit}(\|v))];{}$\7
\&{if} ${}(\\{bv}\MG\\{size}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"\%5ji\ ->\ "},\39\\{fs\_var2lit}(\|v));{}$\6
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\\{bv}\MG\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{literal} \\{imp}${}\K\\{bv}\MG\\{data}[\|i].\\{implied};{}$\7
${}\\{fprintf}(\\{stream},\39\.{"\%ji"},\39\\{imp});{}$\6
\&{if} ${}(\|i+\T{1}\I\\{bv}\MG\\{size}){}$\1\5
${}\\{fprintf}(\\{stream},\39\.{",\ "});{}$\2\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stream},\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
${}\\{bv}\K\|f\MG\\{watchesBin}.\\{data}[\\{fs\_lit2idx}({-}\\{fs\_var2lit}(%
\|v))];{}$\6
\&{if} ${}(\\{bv}\MG\\{size}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"\%5ji\ ->\ "},\39{-}\\{fs\_var2lit}(\|v));{}$\6
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\\{bv}\MG\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{literal} \\{imp}${}\K\\{bv}\MG\\{data}[\|i].\\{implied};{}$\7
${}\\{fprintf}(\\{stream},\39\.{"\%ji"},\39\\{imp});{}$\6
\&{if} ${}(\|i+\T{1}\I\\{bv}\MG\\{size}){}$\1\5
${}\\{fprintf}(\\{stream},\39\.{",\ "});{}$\2\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stream},\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\8\#\&{endif}\7
\&{uintmax\_t} \\{funcsatNumClauses}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{orig\_clauses}\MG\\{size};{}$\6
\4${}\}{}$\2\7
\&{uintmax\_t} \\{funcsatNumVars}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \|f${}\MG\\{numVars};{}$\6
\4${}\}{}$\2\par
\fi

\M{225}

\Y\B\&{void} \\{funcsatPrintHeuristicValues}(\&{FILE} ${}{*}\|p,\39{}$%
\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{for} (\&{variable} \|i${}\K\T{1};{}$ ${}\|i\Z\|f\MG\\{numVars};{}$ ${}\|i%
\PP){}$\5
${}\{{}$\1\6
\&{double} ${}{*}\\{value}\K\\{bh\_var2act}(\|f,\39\|i);{}$\7
${}\\{fprintf}(\|p,\39\.{"\%ju\ =\ \%4.2lf\\n"},\39\|i,\39{*}\\{value});{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\|p,\39\.{"\\n"});{}$\6
\4${}\}{}$\2\7
\&{void} \\{fs\_print\_state}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE} ${}{*}%
\|p){}$\1\1\2\2\6
${}\{{}$\1\6
\&{variable} \|i;\6
\&{literal} ${}{*}\\{it};{}$\7
\&{if} ${}(\R\|p){}$\1\5
${}\|p\K\\{stderr};{}$\2\6
${}\\{fprintf}(\|p,\39\.{"assumptions:\ "});{}$\7
${}\\{forClause}(\\{it},\39{\AND}\|f\MG\\{assumptions}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{fprintf}(\|p,\39\.{"\%ji\ "},\39{*}\\{it});{}$\6
\4${}\}{}$\2\7
${}\\{fprintf}(\|p,\39\.{"\\n"});{}$\6
${}\\{fprintf}(\|p,\39\.{"dl\ \%ju\ (\%"}\\{PRIu64}\.{"\ X,\ \%"}\\{PRIu64}\.{"%
\ d,\ \%"}\\{PRIu64}\.{"\ r)\\n"},\39\|f\MG\\{decisionLevel},\39\|f\MG%
\\{numConflicts},\39\|f\MG\\{numDecisions},\39\|f\MG\\{numRestarts});{}$\6
\&{if} ${}(\|f\MG\\{conflict\_clause}\I\.{NO\_CLS}){}$\1\5
${}\\{fprintf}(\|p,\39\.{"cc\ \%"}\\{PRIuPTR}\.{"\\n"},\39\|f\MG\\{conflict%
\_clause});{}$\2\6
\&{if} ${}(\|f\MG\\{uipClause}.\\{size}>\T{0}){}$\1\5
${}\\{fprintf}(\|p,\39\.{"uipc\ "}),\39\\{fs\_clause\_print}(\|f,\39\|p,\39{%
\AND}\|f\MG\\{uipClause}),\39\\{fprintf}(\|p,\39\.{"\\n"});{}$\2\6
${}\\{fprintf}(\|p,\39\.{"trail\ (\%"}\\{PRIu32}\.{"):\ "},\39\|f\MG\\{trail}.%
\\{size});{}$\6
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\|f\MG\\{trail}.\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\|p,\39\.{"\%2ji"},\39\|f\MG\\{trail}.\\{data}[\|i]);{}$\6
\&{if} ${}(\|f\MG\\{decisions}.\\{data}[\\{fs\_lit2var}(\|f\MG\\{trail}.%
\\{data}[\|i])]\I\T{0}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\|p,\39\.{"@\%ju"},\39\|f\MG\\{decisions}.\\{data}[\\{fs%
\_lit2var}(\|f\MG\\{trail}.\\{data}[\|i])]);{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{head\_tail\_is\_empty}({\AND}\|f\MG\\{unit\_facts}[\\{fs%
\_lit2var}(\|f\MG\\{trail}.\\{data}[\|i])])){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\|p,\39\.{"*"});{}$\6
\4${}\}{}$\2\6
\8\#\&{if} \T{0}\6
\&{if} ${}(\R\\{clauseIsAlone}({\AND}\|f\MG\\{jail}.\\{data}[\\{fs\_lit2var}(%
\|f\MG\\{trail}.\\{data}[\|i])],\39\T{0})){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\|p,\39\.{"!"});{}$\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
${}\\{fprintf}(\|p,\39\.{"\ "});{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\|p,\39\.{"\\n"});{}$\6
${}\\{fprintf}(\|p,\39\.{"model:\ "});{}$\6
\&{for} ${}(\|i\K\T{1};{}$ ${}\|i\Z\|f\MG\\{numVars};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{levelOf}(\|f,\39\|i)\I\\{Unassigned}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\|p,\39\.{"\%3ji@\%ji\ "},\39\|f\MG\\{trail}.\\{data}[\|f\MG%
\\{model}.\\{data}[\|i]],\39\\{levelOf}(\|f,\39\|i));{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{fprintf}(\|p,\39\.{"\\n"});{}$\6
${}\\{fprintf}(\|p,\39\.{"pq:\ \%ju\ (->\ \%ji)\\n"},\39\|f\MG\\{propq},\39\|f%
\MG\\{trail}.\\{data}[\|f\MG\\{propq}]);{}$\6
\4${}\}{}$\2\par
\fi

\M{226}


\Y\B\&{void} \\{funcsatPrintConfig}(\&{FILE} ${}{*}\\{stream},\39{}$\&{funcsat}
${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{funcsat\_config} ${}{*}\\{conf}\K\|f\MG\\{conf};{}$\7
\&{if} ${}(\NULL\I\\{conf}\MG\\{user}){}$\1\5
${}\\{fprintf}(\\{stream},\39\.{"Has\ user\ data\\n"});{}$\2\6
\&{if} ${}(\NULL\I\\{conf}\MG\\{name}){}$\1\5
${}\\{fprintf}(\\{stream},\39\.{"Name:\ \%s\\n"},\39\\{conf}\MG\\{name});{}$\2\6
${}\\{conf}\MG\\{usePhaseSaving}\?\\{fprintf}(\\{stream},\39\.{"phsv\\t"}):%
\\{fprintf}(\\{stream},\39\.{"NO\ phsv\\t"});{}$\6
${}\\{conf}\MG\\{useSelfSubsumingResolution}\?\\{fprintf}(\\{stream},\39\.{"ssr%
\\t"}):\\{fprintf}(\\{stream},\39\.{"NO\ ssr\\t"});{}$\6
${}\\{conf}\MG\\{minimizeLearnedClauses}\?\\{fprintf}(\\{stream},\39\.{"min%
\\t"}):\\{fprintf}(\\{stream},\39\.{"NO\ min\\t"}){}$;\SHC{ TODO MAL check }\6
\&{if} ${}(\\{true}\E\\{conf}\MG\\{gc}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{LBD\_sweep}\E\\{conf}\MG\\{sweepClauses}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"gc\ glucose\\t"});{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{claActivitySweep}\E\\{conf}\MG\\{sweepClauses}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"gc\ minisat\\t"});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\\{abort}(\,);\C{ impossible }\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"NO\ gc\\t\\t"});{}$\6
${}\\{assert}(\NULL\E\\{conf}\MG\\{sweepClauses});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{funcsatLubyRestart}\E\\{conf}\MG\\{isTimeToRestart}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"restart\ luby\\t"});{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{funcsatNoRestart}\E\\{conf}\MG\\{isTimeToRestart}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"restart\ none\\t"});{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{funcsatInnerOuter}\E\\{conf}\MG\\{isTimeToRestart}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"restart\ inout\\t"});{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{funcsatMinisatRestart}\E\\{conf}\MG%
\\{isTimeToRestart}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"restart\ minisat\\t"});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\\{abort}(\,);\C{ impossible }\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stream},\39\.{"learn\ \%"}\\{PRIu32}\.{"\ uips\\t\\t"},\39%
\\{conf}\MG\\{numUipsToLearn}){}$;\SHC{ TODO MAL this is how to print? }\6
${}\\{fprintf}(\\{stream},\39\.{"Jail\ up\ to\ \%"}\\{PRIuMAX}\.{"\ uips\\n"},%
\39\\{conf}\MG\\{maxJailDecisionLevel});{}$\6
\8\#\&{if} \T{0}\6
\&{if} ${}(\\{funcsatIsResourceLimitHit}\E\\{conf}\MG\\{isResourceLimitHit}){}$%
\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"\ \ resource\ hit\ defa}\)\.{ult\\n"});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\\{abort}(\,);\6
\4${}\}{}$\2\6
\&{if} ${}(\\{funcsatPreprocessNewClause}\E\\{conf}\MG%
\\{preprocessNewClause}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"\ \ UNUSED\ preprocess}\)\.{\ new\ clause\
default\\}\)\.{n"});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\\{abort}(\,);\6
\4${}\}{}$\2\6
\&{if} ${}(\\{funcsatPreprocessBeforeSolve}\E\\{conf}\MG%
\\{preprocessBeforeSolve}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"\ \ UNUSED\ preprocess}\)\.{\ before\ solve\
defaul}\)\.{t\\n"});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\\{abort}(\,);\6
\4${}\}{}$\2\6
\&{if} ${}(\\{funcsatDefaultStaticActivity}\E\\{conf}\MG%
\\{getInitialActivity}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"\ \ initial\ activity\ }\)\.{static\ (default)%
\\n"});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\\{abort}(\,);\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
\4${}\}{}$\2\7
\&{void} \\{funcsatPrintCnf}(\&{FILE} ${}{*}\\{stream},\39{}$\&{funcsat} ${}{*}%
\|f,\39{}$\&{bool} \\{learned})\1\1\2\2\6
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"c\ clauses:\ \%ju\ orig}\)\.{inal"},\39%
\\{funcsatNumClauses}(\|f));{}$\6
\&{if} (\\{learned})\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{",\ \%ju\ learned"},\39\|f\MG\\{learned%
\_clauses}\MG\\{size});{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stream},\39\.{"\\n"});{}$\7
\&{uintmax\_t} \\{num\_assumptions}${}\K\T{0};{}$\7
\&{for} (\&{uintmax\_t} \|i${}\K\T{0};{}$ ${}\|i<\|f\MG\\{assumptions}.%
\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\|f\MG\\{assumptions}.\\{data}[\|i]\I\T{0}){}$\1\5
${}\\{num\_assumptions}\PP;{}$\2\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stream},\39\.{"c\ \%ju\ assumptions\\n}\)\.{"},\39\\{num%
\_assumptions});{}$\7
\&{uintmax\_t} \\{numClauses}${}\K\\{funcsatNumClauses}(\|f)+(\\{learned}\?\|f%
\MG\\{learned\_clauses}\MG\\{size}:\T{0})+\\{num\_assumptions};{}$\7
${}\\{fprintf}(\\{stream},\39\.{"p\ cnf\ \%ju\ \%ju\\n"},\39\\{funcsatNumVars}(%
\|f),\39\\{numClauses});{}$\6
\&{for} (\&{uintmax\_t} \|i${}\K\T{0};{}$ ${}\|i<\|f\MG\\{assumptions}.%
\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\|f\MG\\{assumptions}.\\{data}[\|i]\I\T{0}){}$\1\5
${}\\{fprintf}(\\{stream},\39\.{"\%ji\ 0\\n"},\39\|f\MG\\{assumptions}.%
\\{data}[\|i]);{}$\2\6
\4${}\}{}$\2\6
${}\\{vec\_clause\_head\_print\_dimacs}(\|f,\39\\{stream},\39\|f\MG\\{orig%
\_clauses});{}$\6
\&{if} (\\{learned})\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"c\ learned\\n"});{}$\6
${}\\{vec\_clause\_head\_print\_dimacs}(\|f,\39\\{stream},\39\|f\MG\\{learned%
\_clauses});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{void} \\{funcsatClearStats}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
${}\|f\MG\\{numSweeps}\K\T{0};{}$\6
${}\|f\MG\\{numLearnedDeleted}\K\T{0};{}$\6
${}\|f\MG\\{numLiteralsDeleted}\K\T{0};{}$\6
${}\|f\MG\\{numProps}\K\T{0};{}$\6
${}\|f\MG\\{numUnitFactProps}\K\T{0};{}$\6
${}\|f\MG\\{numConflicts}\K\T{0};{}$\6
${}\|f\MG\\{numRestarts}\K\T{0};{}$\6
${}\|f\MG\\{numDecisions}\K\T{0};{}$\6
${}\|f\MG\\{numSubsumptions}\K\T{0};{}$\6
${}\|f\MG\\{numSubsumedOrigClauses}\K\T{0};{}$\6
${}\|f\MG\\{numSubsumptionUips}\K\T{0};{}$\6
\4${}\}{}$\2\7
\&{char} ${}{*}{}$\\{funcsatResultAsString}(\&{funcsat\_result} \\{result})\1\1%
\2\2\6
${}\{{}$\1\6
\&{switch} (\\{result})\5
${}\{{}$\1\6
\4\&{case} \.{FS\_UNKNOWN}:\5
\&{return} \.{"UNKNOWN"};\6
\4\&{case} \.{FS\_SAT}:\5
\&{return} \.{"SATISFIABLE"};\6
\4\&{case} \.{FS\_UNSAT}:\5
\&{return} \.{"UNSATISFIABLE"};\6
\4\&{default}:\5
\\{abort}(\,);\C{ impossible }\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{bool} \\{isUnitClause}(\&{funcsat} ${}{*}\|f,\39{}$\&{clause} ${}{*}\|c){}$%
\1\1\2\2\6
${}\{{}$\1\6
\&{variable} \|i${},{}$ \\{numUnknowns}${}\K\T{0},{}$ \\{numFalse}${}\K%
\T{0};{}$\7
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\|c\MG\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{funcsatValue}(\|f,\39\|c\MG\\{data}[\|i])\E\\{unknown}){}$\5
${}\{{}$\1\6
${}\\{numUnknowns}\PP;{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{funcsatValue}(\|f,\39\|c\MG\\{data}[\|i])\E\\{false}){}$%
\5
${}\{{}$\1\6
${}\\{numFalse}\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{return} \\{numUnknowns}${}\E\T{1}\W\\{numFalse}\E\|c\MG\\{size}-{}$(%
\&{uintmax\_t}) \T{1};\6
\4${}\}{}$\2\7
\&{int} ${}\\{varOrderCompare}(\\{fibkey}*\|a,\39\\{fibkey}*\|b){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{fibkey}\|k\K{*}\|a,\39\|l\K{*}\|b;{}$\6
\&{if} ${}(\|k>\|l){}$\5
${}\{{}$\1\6
\&{return} ${}{-}\T{1};{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\|k<\|l){}$\5
${}\{{}$\1\6
\&{return} \T{1};\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{return} \T{0};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{clause} ${}{*}{}$\\{funcsatRemoveClause}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{clause} ${}{*}\|c){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}\NULL;{}$\6
\4${}\}{}$\2\6
\8\#\&{if} \T{0}\7
${}\{{}$\1\6
${}\\{assert}(\|c\MG\\{isLearnt});{}$\6
\&{if} ${}(\|c\MG\\{isReason}){}$\1\5
\&{return} ${}\NULL;{}$\2\6
\&{if} ${}(\|c\MG\\{is\_watched}){}$\5
${}\{{}$\C{ remove \& release from the two watchers we had }\1\6
\&{clause} ${}{*}{*}\\{w0}\K{}$(\&{clause} ${}{*}{*}){}$ ${}{\AND}\|f\MG%
\\{watches}.\\{data}[\\{fs\_lit2idx}({-}\|c\MG\\{data}[\T{0}])];{}$\6
\&{clause} ${}{*}{*}\\{w1}\K{}$(\&{clause} ${}{*}{*}){}$ ${}{\AND}\|f\MG%
\\{watches}.\\{data}[\\{fs\_lit2idx}({-}\|c\MG\\{data}[\T{1}])];{}$\7
${}\\{clauseUnSpliceWatch}(\\{w0},\39\|c,\39\T{0});{}$\6
${}\\{clauseUnSpliceWatch}(\\{w1},\39\|c,\39\T{1});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\C{ clause is in unit facts or jailed }\1\6
\&{clause} ${}{*}\\{copy}\K\|c;{}$\7
${}\\{clauseUnSplice}({\AND}\\{copy},\39\T{0});{}$\6
\4${}\}{}$\2\6
${}\\{vector}*\\{clauses};{}$\6
\&{if} ${}(\|c\MG\\{isLearnt}){}$\5
${}\{{}$\1\6
${}\\{clauses}\K{\AND}\|f\MG\\{learnedClauses};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{clauses}\K{\AND}\|f\MG\\{origClauses};{}$\6
\4${}\}{}$\2\6
${}\\{clauses}\MG\\{size}\MM;{}$\6
\&{return} \|c;\6
\4${}\}{}$\2\6
\8\#\&{endif}\7
\&{extern} \&{int} \\{DebugSolverLoop};\7
\&{static} \&{char} ${}{*}{}$\\{dups}(\&{const} \&{char} ${}{*}\\{str}){}$\1\1%
\2\2\6
${}\{{}$\1\6
\&{char} ${}{*}\\{res};{}$\7
${}\.{FS\_CALLOC}(\\{res},\39\\{strlen}(\\{str})+\T{1},\39{}$\&{sizeof} ${}({*}%
\\{str}));{}$\6
${}\\{strcpy}(\\{res},\39\\{str});{}$\6
\&{return} \\{res};\6
\4${}\}{}$\2\7
\&{bool} \\{funcsatDebug}(\&{funcsat} ${}{*}\|f,\39{}$\&{char} ${}{*}\\{label},%
\39{}$\&{int} \\{level})\1\1\2\2\6
${}\{{}$\6
\8\#\&{ifdef} \.{FUNCSAT\_LOG}\1\6
\&{int} ${}{*}\\{levelp};{}$\7
${}\.{FS\_MALLOC}(\\{levelp},\39\T{1},\39{}$\&{sizeof} ${}({*}\\{levelp}));{}$\6
${}{*}\\{levelp}\K\\{level};{}$\6
${}\\{hashtable\_insert}(\|f\MG\\{conf}\MG\\{logSyms},\39\\{dups}(\\{label}),%
\39\\{levelp});{}$\6
\&{return} \\{true};\6
\8\#\&{else}\6
\&{return} \\{false};\6
\8\#\&{endif}\6
\4${}\}{}$\2\par
\fi

\M{227}
\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{extern} \&{mbool} \\{funcsatValue}(\&{funcsat} ${}{*}\|f,\39{}$\&{literal} %
\|p);\par
\fi

\M{228}

\Y\B\4\X15:External declarations\X${}\mathrel+\E{}$\6
\&{struct} \&{funcsat\_config};\6
\&{funcsat} ${}{*}{}$\\{funcsatInit}(\&{funcsat\_config} ${}{*}\\{conf});{}$\6
\&{funcsat\_config} ${}{*}{}$\\{funcsatConfigInit}(\&{void} ${}{*}%
\\{userData});{}$\6
\&{void} \\{funcsatConfigDestroy}(\&{funcsat\_config} ${}{*});{}$\6
\&{void} \\{funcsatResize}(\&{funcsat} ${}{*}\|f,\39{}$\&{variable} %
\\{numVars});\6
\&{void} \\{funcsatDestroy}(\&{funcsat} ${}{*});{}$\6
\&{funcsat\_result} \\{funcsatPushAssumption}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{literal} \|p);\6
\&{funcsat\_result} \\{funcsatPushAssumptions}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{clause} ${}{*}\|c);{}$\6
\&{void} \\{funcsatPopAssumptions}(\&{funcsat} ${}{*}\|f,\39{}$\&{uintmax\_t} %
\\{num});\6
\&{funcsat\_result} \\{funcsatSolve}(\&{funcsat} ${}{*}\\{func});{}$\6
\&{uintmax\_t} \\{funcsatNumClauses}(\&{funcsat} ${}{*}\\{func});{}$\6
\&{uintmax\_t} \\{funcsatNumVars}(\&{funcsat} ${}{*}\\{func});{}$\6
\&{void} \\{funcsatPrintStats}(\&{FILE} ${}{*}\\{stream},\39{}$\&{funcsat}
${}{*}\|f);{}$\6
\&{void} \\{funcsatPrintColumnStats}(\&{FILE} ${}{*}\\{stream},\39{}$%
\&{funcsat} ${}{*}\|f);{}$\6
\&{void} \\{funcsatClearStats}(\&{funcsat} ${}{*}\|f);{}$\6
\&{void} \\{funcsatBumpLitPriority}(\&{funcsat} ${}{*}\|f,\39{}$\&{literal} %
\|p);\6
\&{void} \\{funcsatPrintCnf}(\&{FILE} ${}{*}\\{stream},\39{}$\&{funcsat} ${}{*}%
\|f,\39{}$\&{bool} \\{learned});\6
\&{funcsat\_result} \\{funcsatResult}(\&{funcsat} ${}{*}\|f);{}$\6
\&{clause} ${}{*}{}$\\{funcsatSolToClause}(\&{funcsat} ${}{*}\|f);{}$\6
\&{intmax\_t} \\{funcsatSolCount}(\&{funcsat} ${}{*}\|f,\39{}$\&{clause} %
\\{subset}${},\39{}$\&{clause} ${}{*}\\{lastSolution});{}$\6
\&{void} \\{funcsatReset}(\&{funcsat} ${}{*}\|f);{}$\6
\&{void} \\{funcsatSetupActivityGc}(\&{funcsat\_config} ${}{*});{}$\6
\&{bool} \\{funcsatDebug}(\&{funcsat} ${}{*}\|f,\39{}$\&{char} ${}{*}\\{label},%
\39{}$\&{int} \\{level});\6
\&{clause} ${}{*}{}$\\{funcsatRemoveClause}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{clause} ${}{*}\|c){}$;\par
\fi

\N{1}{229}Parsing CNF.

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\8\#\&{include} \.{"funcsat/vec\_char.h"}\6
\&{int64\_t} ${}\\{readHeader}(\&{int}({*}\\{getChar}){}$(\&{void} ${}{*}),%
\39{}$\&{void} ${}{*},\39{}$\&{funcsat} ${}{*}\\{func});{}$\6
\&{funcsat\_result} ${}\\{readClauses}(\&{int}({*}\\{getChar}){}$(\&{void}
${}{*}),\39{}$\&{void} ${}{*},\39{}$\&{funcsat} ${}{*}\\{func},\39{}$\&{uint64%
\_t} \\{numClauses});\7
\&{int} \\{fgetcWrapper}(\&{void} ${}{*}\\{stream}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{fgetc}((\&{FILE} ${}{*}){}$ \\{stream});\6
\4${}\}{}$\2\7
\&{funcsat\_result} \\{parseDimacsCnf}(\&{const} \&{char} ${}{*}\\{path},\39{}$%
\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{struct} \\{stat} \\{buf};\7
\&{if} ${}({-}\T{1}\E\\{stat}(\\{path},\39{\AND}\\{buf})){}$\1\5
${}\\{perror}(\.{"stat"}),\39\\{exit}(\T{1});{}$\2\6
\&{if} ${}(\R\.{S\_ISREG}(\\{buf}.\\{st\_mode})){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Error:\ '\%s'\ not\ a\ r}\)\.{egular\ file%
\\n"},\39\\{path});{}$\6
\\{exit}(\T{1});\6
\4${}\}{}$\2\6
${}\&{int}({*}\\{getChar}){}$(\&{void} ${}{*});{}$\7
\&{void} ${}{*}\\{stream};{}$\6
\&{const} \&{char} ${}{*}\\{opener};{}$\6
\&{funcsat\_result} \\{result};\6
\&{bool} \\{isGz}${}\K\T{0}\E\\{strcmp}(\.{".gz"},\39\\{path}+(\\{strlen}(%
\\{path})-\\{strlen}(\.{".gz"})));{}$\7
\&{if} (\\{isGz})\5
${}\{{}$\6
\8\#\&{ifdef} \.{HAVE\_LIBZ}\6
\8\#\&{if} \T{0}\1\6
${}\\{fprintf}(\\{stderr},\39\.{"c\ found\ .gz\ file\\n"});{}$\6
\8\#\&{endif}\6
${}\\{getChar}\K(\&{int}(*){}$(\&{void} ${}{*}))\\{gzgetc};{}$\6
${}\\{stream}\K\\{gzopen}(\\{path},\39\.{"r"});{}$\6
${}\\{opener}\K\.{"gzopen"};{}$\6
\8\#\&{else}\6
${}\\{fprintf}(\\{stderr},\39\.{"cannot\ read\ gzip'd\ }\)\.{file\\n"});{}$\6
\\{exit}(\T{1});\6
\8\#\&{endif}\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{getChar}\K\\{fgetcWrapper};{}$\6
${}\\{stream}\K\\{fopen}(\\{path},\39\.{"r"});{}$\6
${}\\{opener}\K\.{"fopen"};{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{stream}){}$\5
${}\{{}$\1\6
\\{perror}(\\{opener});\6
\\{exit}(\T{1});\6
\4${}\}{}$\2\7
\&{uint64\_t} \\{num\_clauses}${}\K{}$(\&{uint64\_t}) \\{readHeader}${}(%
\\{getChar},\39\\{stream},\39\|f);{}$\7
${}\\{fslog}(\|f,\39\.{"solve"},\39\T{2},\39\.{"read\ \%"}\\{PRIu64}\.{"\
clauses\ from\ heade}\)\.{r\\n"},\39\\{num\_clauses});{}$\6
${}\\{result}\K\\{readClauses}(\\{getChar},\39\\{stream},\39\|f,\39\\{num%
\_clauses});{}$\6
\&{if} (\\{isGz})\5
${}\{{}$\6
\8\#\&{ifdef} \.{HAVE\_LIBZ}\1\6
\&{if} ${}(\.{Z\_OK}\I\\{gzclose}(\\{stream})){}$\1\5
${}\\{perror}(\.{"gzclose"}),\39\\{exit}(\T{1});{}$\2\6
\8\#\&{else}\6
${}\\{assert}(\T{0}\W\.{"no\ libz\ and\ this\ sh}\)\.{ouldn't\ happen"});{}$\6
\8\#\&{endif}\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\T{0}\I\\{fclose}(\\{stream})){}$\1\5
${}\\{perror}(\.{"fclose"}),\39\\{exit}(\T{1});{}$\2\6
\4${}\}{}$\2\6
\&{return} \\{result};\6
\4${}\}{}$\2\7
\&{static} \&{literal} ${}\\{readLiteral}(\&{int}({*}\\{getChar}){}$(\&{void}
${}{*}\\{stream}),\39{}$\&{void} ${}{*}\\{stream},\39{}$\&{struct} \\{vec%
\_char} ${}{*}\\{tmp},\39{}$\&{uint64\_t} \\{numClauses});\7
\&{int64\_t} ${}\\{readHeader}(\&{int}({*}\\{getChar}){}$(\&{void} ${}{*}%
\\{stream}),\39{}$\&{void} ${}{*}\\{stream},\39{}$\&{funcsat} ${}{*}%
\\{func}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{char} \|c;\7
\4\\{Comments}:\6
\&{while} ${}(\\{isspace}(\|c\K\\{getChar}(\\{stream}))){}$\1\5
;\C{ skip leading spaces }\2\6
\&{if} ${}(\.{'c'}\E\|c){}$\5
${}\{{}$\1\6
\&{while} ${}(\.{'\\n'}\I(\|c\K\\{getChar}(\\{stream}))){}$\1\5
;\2\6
\4${}\}{}$\2\6
\&{if} ${}(\.{'p'}\I\|c){}$\5
${}\{{}$\1\6
\&{goto} \\{Comments};\6
\4${}\}{}$\2\6
\&{while} ${}(\.{'c'}\I(\|c\K\\{getChar}(\\{stream}))){}$\1\5
;\2\6
${}\\{assert}(\|c\E\.{'c'});{}$\6
${}\|c\K\\{getChar}(\\{stream});{}$\6
${}\\{assert}(\|c\E\.{'n'});{}$\6
${}\|c\K\\{getChar}(\\{stream});{}$\6
${}\\{assert}(\|c\E\.{'f'});{}$\7
\&{struct} \\{vec\_char} ${}{*}\\{tmp}\K\\{vec\_char\_init}(\T{4});{}$\7
${}\\{readLiteral}(\\{getChar},\39\\{stream},\39\\{tmp},\39\T{0});{}$\7
\&{uintmax\_t} \\{numClauses}${}\K{}$(\&{uintmax\_t}) \\{readLiteral}${}(%
\\{getChar},\39\\{stream},\39\\{tmp},\39\T{0});{}$\7
\\{vec\_char\_destroy}(\\{tmp});\6
\8\#\&{if} \T{0}\6
${}\\{fprintf}(\\{stderr},\39\.{"c\ read\ header\ 'p\ cn}\)\.{f\ \%ju\ \%ju'%
\\n"},\39\\{numVariables},\39\\{numClauses});{}$\6
\8\#\&{endif}\6
\&{return} (\&{intmax\_t}) \\{numClauses};\6
\4${}\}{}$\2\6
\&{funcsat\_result} ${}\\{readClauses}(\&{int}({*}\\{getChar}){}$(\&{void}
${}{*}\\{stream}),\39{}$\&{void} ${}{*}\\{stream},\39{}$\&{funcsat} ${}{*}%
\\{func},\39{}$\&{uint64\_t} \\{numClauses})\1\1 $\{$ \&{clause} ${}{*}{}$\1\1\6
\&{clause};\6
\&{funcsat\_result} \\{result}${}\K\.{FS\_UNKNOWN};{}$\6
\&{struct} \\{vec\_char} ${}{*}\\{tmp}\K\\{vec\_char\_init}(\T{4});$ \&{if}
${}(\\{numClauses}>\T{0})$ $\{$ \&{do} $\{$ $\&{clause}\K\\{clauseAlloc}(%
\T{5});{}$\6
\&{literal} \&{literal}${}\K\\{readLiteral}(\\{getChar},\39\\{stream},\39%
\\{tmp},\39\\{numClauses});$ \&{while} $(\&{literal}\I\T{0})$ \6
${}\{{}$\1\6
${}\\{clausePush}(\&{clause},\39\&{literal});{}$\7
${}\&{literal}\K\\{readLiteral}(\\{getChar},\39\\{stream},\39\\{tmp},\39%
\\{numClauses});{}$\6
\4${}\}{}$\2\6
\8\#\&{if} \T{0}\6
${}\\{clause\_head\_print\_dimacs}(\\{stderr},\39\&{clause});{}$\6
${}\\{fprintf}(\\{stderr},\39\.{"\\n"});{}$\6
\8\#\&{endif}\6
\&{if} ${}(\.{FS\_UNSAT}\E\\{funcsatAddClause}(\\{func},\39\&{clause})){}$\5
${}\{{}$\1\6
${}\\{result}\K\.{FS\_UNSAT};{}$\6
\\{clauseFree}(\&{clause});\6
\&{break};\6
\4${}\}{}$\2\6
\&{else}\1\5
\\{clauseFree}(\&{clause});\2\6
$\}$ \6
\&{while} ${}(\MM\\{numClauses}>\T{0}){}$\1\5
;\2\6
$\}$ \\{vec\_char\_destroy}(\\{tmp});\6
\&{return} \\{result}; $\}$ \&{static} \&{literal} ${}\\{readLiteral}(%
\&{int}({*}\\{getChar}){}$(\&{void} ${}{*}\\{stream}),\39{}$\&{void} ${}{*}%
\\{stream},\39{}$\&{struct} \\{vec\_char} ${}{*}\\{tmp},\39{}$\&{uint64\_t} %
\\{numClauses})\1\1 $\{$ \&{char} \|c;\6
\&{bool} \\{begun};\7
\\{vec\_char\_clear}(\\{tmp});\7
\&{literal} \&{literal};\7
${}\\{begun}\K\\{false};{}$\6
\&{while} (\T{1})\5
${}\{{}$\1\6
${}\|c\K\\{getChar}(\\{stream});{}$\6
\&{if} ${}(\\{isspace}(\|c)\V\.{EOF}\E\|c){}$\5
${}\{{}$\1\6
\&{if} (\\{begun})\5
${}\{{}$\1\6
\&{break};\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\.{EOF}\E\|c){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"readLiteral\ error:\ }\)\.{too\ few\ clauses\
(aft}\)\.{er\ \%"}\\{PRIu64}\.{"\ clauses)\\n"},\39\\{numClauses});{}$\6
\\{exit}(\T{1});\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{continue};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{begun}\K\\{true};{}$\6
${}\\{vec\_char\_push}(\\{tmp},\39\|c);{}$\6
\4${}\}{}$\2\6
${}\\{vec\_char\_push}(\\{tmp},\39\.{'\\0'});{}$\7
${}\&{literal}\K{}$\\{strtol}((\&{char} ${}{*}){}$ \\{tmp}${}\MG\\{data},\39%
\NULL,\39\T{10});$ \&{return} \&{literal}; $\}{}$\par
\fi

\M{230}
\Y\B\4\X15:External declarations\X${}\mathrel+\E{}$\6
\&{funcsat\_result} \\{parseDimacsCnf}(\&{const} \&{char} ${}{*}\\{path},\39{}$%
\&{funcsat} ${}{*}\|f){}$;\par
\fi

\N{1}{231}Debugging support.

\Y\B\4\X15:External declarations\X${}\mathrel+\E{}$\6
\&{char} ${}{*}{}$\\{funcsatResultAsString}(\&{funcsat\_result} \\{result});\par
\fi

\M{232}We want to print the variable interaction graph. I think that's what
it's
called.

\Y\B\4\X15:External declarations\X${}\mathrel+\E{}$\6
\&{void} \\{fs\_vig\_print}(\&{funcsat} ${}{*}\|f,\39{}$\&{const} \&{char}
${}{*}\\{path}){}$;\par
\fi

\M{233}

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{void} \\{fs\_vig\_print}(\&{funcsat} ${}{*}\|f,\39{}$\&{const} \&{char}
${}{*}\\{path}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{FILE} ${}{*}\\{dot};{}$\6
\&{char} \\{buf}[\T{256}];\7
\&{if} ${}(\NULL\E(\\{dot}\K\\{fopen}(\\{path},\39\.{"w"}))){}$\1\5
${}\\{perror}(\.{"fopen"}),\39\\{exit}(\T{1});{}$\2\6
${}\\{fprintf}(\\{dot},\39\.{"graph\ G\ \{\\n"});{}$\6
${}\\{fprintf}(\\{dot},\39\.{"//\ variables\\n"});{}$\6
\&{for} (\&{variable} \|i${}\K\T{1};{}$ ${}\|i\Z\|f\MG\\{numVars};{}$ ${}\|i%
\PP){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{dot},\39\.{"\%ju;\\n"},\39\|i);{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{dot},\39\.{"//\ clauses\\n"});{}$\7
\&{uintmax\_t} \\{cnt}${}\K\T{0};{}$\7
\&{for\_vec\_uintptr} ${}(\\{ix\_cl},\39\|f\MG\\{orig\_clauses}){}$\5
${}\{{}$\1\6
\&{struct} \&{clause\_iter} \\{it};\6
\&{char} ${}{*}\\{bufptr}\K\\{buf};{}$\7
${}\\{clause\_iter\_init}(\|f,\39{*}\\{ix\_cl},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
${}\\{bufptr}\MRL{+{\K}}\\{sprintf}(\\{bufptr},\39\.{"\%ji\ "},\39{*}\|p);{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{dot},\39\.{"clause\%ju\ [shape=bo}\)\.{x,label=\\"\%s%
\\",fillc}\)\.{olor=black,shape=box}\)\.{];\\n"},\39\\{cnt},\39\\{buf});{}$\6
${}\\{clause\_iter\_init}(\|f,\39{*}\\{ix\_cl},\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{dot},\39\.{"clause\%ju\ --\ \%ju\ [\%}\)\.{s];\\n"},\39%
\\{cnt},\39\\{fs\_lit2var}({*}\|p),\39({*}\|p<\T{0}\?\.{"color=red"}:%
\.{"color=green"}));{}$\6
\4${}\}{}$\2\6
${}\\{cnt}\PP;{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{dot},\39\.{"\}\\n"});{}$\6
\&{if} ${}(\T{0}\I\\{fclose}(\\{dot})){}$\1\5
\\{perror}(\.{"fclose"});\2\6
\4${}\}{}$\2\par
\fi

\M{234}The \funcsat\ configuration.
\Y\B\4\X13:External types\X${}\mathrel+\E{}$\6
\&{typedef} \&{struct} \&{funcsat} \&{funcsat};\6
\&{typedef} \&{struct} \&{funcsat\_config} ${}\{{}$\1\6
\&{void} ${}{*}\\{user}{}$;\C{ clients can use this }\6
\&{char} ${}{*}\\{name}{}$;\C{ Name of the currently running sat problem.  (May
be null) }\6
\&{struct} \&{hashtable} ${}{*}\\{logSyms}{}$;\C{  for logging }\6
\&{struct} \&{vec\_uintmax} \\{logStack};\6
\&{bool} \\{printLogLabel};\6
\&{FILE} ${}{*}\\{debugStream};{}$\6
\&{bool} \\{usePhaseSaving};\C{ whether to save variable phases }\6
\&{bool} \\{useSelfSubsumingResolution};\6
\&{bool} \\{minimizeLearnedClauses};\6
\&{uint32\_t} \\{numUipsToLearn};\6
\&{bool} \\{gc};\C{ If false, all learned clauses are kept for all time. }\6
\&{uintmax\_t} \\{maxJailDecisionLevel};\C{    Only jail clauses that occur at
or below this decision level.    }\7
${}\&{bool}({*}\\{isTimeToRestart}){}$(\&{funcsat} ${}{*},\39{}$\&{void}
${}{*}){}$;\C{    This function is called after a conflict is discovered and
analyzed.  If it    function returns \PB{\\{true}}, \funcsat\ backtracks to
decision level 0 and    recommences.    }\6
${}\&{bool}({*}\\{isResourceLimitHit}){}$(\&{funcsat} ${}{*},\39{}$\&{void}
${}{*}){}$;\C{    This function is called after any learned clause is added but
before    beginning the next step of unit propagation.  If it returns \PB{%
\\{true}}, \funcsat\    solver terminates whether the problem has been solved
or not.    }\6
${}\&{funcsat\_result}({*}\\{preprocessNewClause}){}$(\&{funcsat} ${}{*},\39{}$%
\&{void} ${}{*},\39{}$\&{clause} ${}{*}){}$;\C{    UNUSED    }\6
${}\&{funcsat\_result}({*}\\{preprocessBeforeSolve}){}$(\&{funcsat} ${}{*},%
\39{}$\&{void} ${}{*}){}$;\C{    UNUSED    }\6
${}\&{double}({*}\\{getInitialActivity}){}$(\&{variable} ${}{*}){}$;\C{    Gets
the initial activity for the given variable.    }\6
${}\&{void}({*}\\{bumpOriginal}){}$(\&{funcsat} ${}{*},\39{}$\&{uintptr\_t} %
\\{ix\_cl});\C{    Called on original clauses.    }\6
${}\&{void}({*}\\{bumpReason}){}$(\&{funcsat} ${}{*},\39\&{uintptr\_t}){}$;\C{
  Called on clauses that are resolved on during learning.    }\6
${}\&{void}({*}\\{bumpLearned}){}$(\&{funcsat} ${}{*},\39\&{uintptr\_t}){}$;\C{
   Called on the new UIP clause after the conflict is analyzed.    }\6
${}\&{void}({*}\\{bumpUnitClause}){}$(\&{funcsat} ${}{*},\39\&{uintptr\_t}){}$;%
\C{    Called when a clause implies a unit literal.    }\6
${}\&{void}({*}\\{decayAfterConflict}){}$(\&{funcsat} ${}{*}\|f){}$;\C{
Called after a conflict is analyzed.    }\6
${}\&{void}({*}\\{sweepClauses}){}$(\&{funcsat} ${}{*},\39{}$\&{void}
${}{*}){}$;\C{    Implements a policy for deleting learned clauses immediately
after a    restart.    }\2\6
${}\}{}$ \&{funcsat\_config};\C{ \PB{\&{uint64\_t} \\{funcsatDebugSet};} in
main.c}\C{ Descriptions for these options can be found in \PB{%
\\{debugDescriptions}[\\{Option}]} }\par
\fi

\M{235}When debugging \funcsat, it is convenient to be able to minimize a test
case. Armin Biere has been kind enough to write {\sc cnfdd}, which is a
delta-debugging algorithm for CNF files. The macro \PB{\\{assertExit}} lets one
quickly
change a failing \PB{\\{assert}} into one with exits with a particular code. So
when
\funcsat\ fails a particular \PB{\\{assert}(\|x)}, change it to \PB{$%
\\{assertExit}(\T{2},\|x)$} and
run {\sc cnfdd} to produce a minimal test case.

\Y\B\4\X235:Conditional macros\X${}\E{}$\6
\8\#\&{ifndef} \.{NDEBUG}\6
\8\#\&{define} ${}\\{assertExit}(\\{code},\39\\{cond}) \5((\\{cond})\?{}$(%
\&{void}) \T{0}${}:\\{exit}(\\{code})){}$\6
\8\#\&{else}\6
\8\#\&{define} \\{assertExit} \5${}(\\{code},\39\\{cond}){}$\6
\8\#\&{endif}\par
\A236.
\U12.\fi

\M{236}The following are functions used for logging messages to the console (if
\PB{\.{FUNCSAT\_LOG}} is enabled).

\Y\B\4\D$\\{fs\_dbgout}(\|f)$ \5
$(\|f)\MG\\{conf}\MG{}$\\{debugStream}\par
\Y\B\4\X235:Conditional macros\X${}\mathrel+\E{}$\6
\8\#\&{ifdef} \.{FUNCSAT\_LOG}\6
\8\#\&{ifndef} \.{SWIG}\6
$\.{DECLARE\_HASHTABLE}(\\{fsLogMapInsert},\39\\{fsLogMapSearch},\39%
\\{fsLogMapRemove},\39\&{char},\39\&{int}){}$\6
\8\#\&{endif}\C{#define fs_ifdbg(f, label, level) if (true)}\6
\8\#\&{define}\&{fs\_ifdbg} $(\|f,\39\\{label},\39\\{level})$ \&{if} ${}((\|f)%
\MG\\{conf}\MG\\{logSyms}\W\\{fsLogMapSearch}(\|f\MG\\{conf}\MG\\{logSyms},%
\39{}$(\&{void} ${}{*})(\\{label}))\W(\\{level})\Z{*}\\{fsLogMapSearch}((\|f)%
\MG\\{conf}\MG\\{logSyms},\39{}$(\&{void} ${}{*})(\\{label})))$ \6
\8\#\&{else}\C{#define fs_ifdbg(f, label, level) if (true)}\6
\8\#\&{define}\&{fs\_ifdbg} $(\|f,\39\\{label},\39\\{level})$ \&{if} (%
\\{false}) \6
\8\#\&{endif}\6
\&{static} \&{inline} \&{int} \\{fslog}(\&{const} \&{struct} \&{funcsat}
${}{*},\39{}$\&{const} \&{char} ${}{*}\\{label},\39{}$\&{int} \\{level}${},%
\39{}$\&{const} \&{char} ${}{*}\\{format},\39\,\ldots\,);{}$\6
\&{static} \&{inline} \&{int} \\{dopen}(\&{const} \&{struct} \&{funcsat}
${}{*},\39{}$\&{const} \&{char} ${}{*}\\{label});{}$\6
\&{static} \&{inline} \&{int} \\{dclose}(\&{const} \&{struct} \&{funcsat}
${}{*},\39{}$\&{const} \&{char} ${}{*}\\{label}){}$;\par
\fi

\M{237}

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
$\.{DEFINE\_HASHTABLE}(\\{fsLogMapInsert},\39\\{fsLogMapSearch},\39%
\\{fsLogMapRemove},\39\&{char},\39\&{int}){}$\1\1 \&{int} \\{fslog}(\&{const} %
\&{funcsat} ${}{*}\|f,\39{}$\&{const} \&{char} ${}{*}\\{label},\39{}$\&{int} %
\\{msgLevel}${},\39{}$\&{const} \&{char} ${}{*}\\{format},\39\,\ldots\,){}$\1\1%
\2\2\6
${}\{{}$\1\6
\&{int} \\{pr}${}\K\T{0};{}$\6
\&{int} ${}{*}\\{logLevel};{}$\6
\&{va\_list} \\{ap};\7
\&{if} ${}(\|f\MG\\{conf}\MG\\{logSyms}\W(\\{logLevel}\K\\{hashtable\_search}(%
\|f\MG\\{conf}\MG\\{logSyms},\39{}$(\&{void} ${}{*}){}$ \\{label})))\5
${}\{{}$\1\6
\&{if} ${}(\\{msgLevel}\Z{*}\\{logLevel}){}$\5
${}\{{}$\1\6
\&{uintmax\_t} \\{indent}${}\K\\{vec\_uintmax\_peek}({\AND}\|f\MG\\{conf}\MG%
\\{logStack}),{}$ \|i;\7
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\\{indent};{}$ ${}\|i\PP){}$\1\5
${}\\{fprintf}(\|f\MG\\{conf}\MG\\{debugStream},\39\.{"\ "});{}$\2\6
\&{if} ${}(\|f\MG\\{conf}\MG\\{printLogLabel}){}$\1\5
${}\\{pr}\MRL{+{\K}}\\{fprintf}(\|f\MG\\{conf}\MG\\{debugStream},\39\.{"\%s\ %
\%d:\ "},\39\\{label},\39\\{msgLevel});{}$\2\6
${}\\{va\_start}(\\{ap},\39\\{format});{}$\6
${}\\{pr}\MRL{+{\K}}\\{vfprintf}(\|f\MG\\{conf}\MG\\{debugStream},\39%
\\{format},\39\\{ap});{}$\6
\\{va\_end}(\\{ap});\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{return} \\{pr};\6
\4${}\}{}$\2\7
\&{int} \\{dopen}(\&{const} \&{funcsat} ${}{*}\|f,\39{}$\&{const} \&{char}
${}{*}\\{label}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\|f\MG\\{conf}\MG\\{logSyms}\W\\{hashtable\_search}(\|f\MG\\{conf}%
\MG\\{logSyms},\39{}$(\&{void} ${}{*}){}$ \\{label}))\5
${}\{{}$\1\6
\&{uintmax\_t} \\{indent}${}\K\\{vec\_uintmax\_peek}({\AND}\|f\MG\\{conf}\MG%
\\{logStack})+\T{2};{}$\7
${}\\{vec\_uintmax\_push}({\AND}\|f\MG\\{conf}\MG\\{logStack},\39%
\\{indent});{}$\6
\4${}\}{}$\2\6
\&{return} \T{0};\6
\4${}\}{}$\2\7
\&{int} \\{dclose}(\&{const} \&{funcsat} ${}{*}\|f,\39{}$\&{const} \&{char}
${}{*}\\{label}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\|f\MG\\{conf}\MG\\{logSyms}\W\\{hashtable\_search}(\|f\MG\\{conf}%
\MG\\{logSyms},\39{}$(\&{void} ${}{*}){}$ \\{label}))\5
${}\{{}$\1\6
${}\\{vec\_uintmax\_pop}({\AND}\|f\MG\\{conf}\MG\\{logStack});{}$\6
\4${}\}{}$\2\6
\&{return} \T{0};\6
\4${}\}{}$\2\par
\fi

\M{238}
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\C{*  * Searches in the clause
for the literal with the maximum decision level,  * beginning at startIdx. If
found, that literal is swapped with  * reason[swapIdx]. This preserves the
necessary invariant for the unit facts  * list.  }\6
\&{static} \&{void} \\{swapInMaxLevelLit}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{clause} ${}{*}\\{reason},\39{}$\&{uintmax\_t} \\{swapIdx}${},\39{}$%
\&{uintmax\_t} \\{startIdx})\1\1\2\2\6
${}\{{}$\1\6
\&{literal} \\{secondWatch}${}\K\T{0},{}$ \\{swLevel}${}\K{-}\T{1}{}$;\C{ find
max level lit, swap with lit[1] }\7
\&{for} (\&{variable} \|i${}\K\\{startIdx};{}$ ${}\|i<\\{reason}\MG\\{size};{}$
${}\|i\PP){}$\5
${}\{{}$\1\6
\&{literal} \\{lev}${}\K\\{levelOf}(\|f,\39\\{fs\_lit2var}(\\{reason}\MG%
\\{data}[\|i]));{}$\7
${}\\{fslog}(\|f,\39\.{"subsumption"},\39\T{9},\39\.{"level\ of\ \%ji\ =\ \%ju%
\\}\)\.{n"},\39\\{reason}\MG\\{data}[\|i],\39\\{levelOf}(\|f,\39\\{fs%
\_lit2var}(\\{reason}\MG\\{data}[\|i])));{}$\6
\&{if} ${}(\\{swLevel}<\\{lev}){}$\1\5
${}\\{swLevel}\K\\{lev},\39\\{secondWatch}\K{}$(\&{literal}) \|i;\C{ TODO Does
this speed stuff up? }\2\6
\&{if} ${}(\\{lev}\E\\{fs\_var2lit}(\|f\MG\\{decisionLevel})){}$\1\5
\&{break};\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{swLevel}\I{-}\T{1}){}$\5
${}\{{}$\1\6
\&{literal} \\{tmp}${}\K\\{reason}\MG\\{data}[\\{swapIdx}];{}$\7
${}\\{reason}\MG\\{data}[\\{swapIdx}]\K\\{reason}\MG\\{data}[\\{secondWatch}],%
\39\\{reason}\MG\\{data}[\\{secondWatch}]\K\\{tmp};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\C{ this function must be called after the resolution operation }\2\7
\&{static} \&{void} \\{checkSubsumption}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{literal} \|p${},\39{}$\&{clause} ${}{*}\\{learn},\39{}$\&{clause} ${}{*}%
\\{reason},\39{}$\&{bool} \\{learnIsUip})\1\1\2\2\6
${}\{{}$\6
\8\#\&{if} \T{0}\C{ This is the test suggested in the paper "On-the-fly clause
improvement" in    * SAT09. }\1\6
\&{if} ${}(\\{learn}\MG\\{size}\E\\{reason}\MG\\{size}-\T{1}\W\\{reason}\MG%
\\{size}>\T{1}\W{}$\C{ learn subsumes reason }\6
\\{learn}${}\MG\\{size}>\T{2}){}$\5
${}\{{}$\1\6
${}\PP\|f\MG\\{numSubsumptions};{}$\6
\&{fs\_ifdbg} ${}(\|f,\39\.{"subsumption"},\39\T{1}){}$\5
${}\{{}$\1\6
\&{FILE} ${}{*}\\{out}\K\|f\MG\\{conf}\MG\\{debugStream};{}$\7
${}\\{clause\_head\_print\_dimacs}(\|f,\39\\{out},\39\\{learn});{}$\6
${}\\{fprintf}(\\{out},\39\.{"\ subsumes\ "});{}$\6
${}\\{clause\_head\_print\_dimacs}(\|f,\39\\{out},\39\\{reason});{}$\6
${}\\{fprintf}(\\{out},\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
${}\\{assert}(\R\\{reason}\MG\\{isReason});{}$\6
\&{if} (\\{learnIsUip})\1\5
${}\\{vectorPush}({\AND}\|f\MG\\{subsumed},\39{}$(\&{void} ${}{*}){}$ \T{1});\2%
\6
\&{else}\1\5
${}\\{vectorPush}({\AND}\|f\MG\\{subsumed},\39{}$(\&{void} ${}{*}){}$ \T{0});\2%
\6
${}\\{vectorPush}({\AND}\|f\MG\\{subsumed},\39\\{reason});{}$\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
\4${}\}{}$\2\7
\&{static} \&{void} \\{minimizeClauseMinisat1}(\&{funcsat} ${}{*}\|f,\39{}$%
\&{clause} ${}{*}\\{learned}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{uintmax\_t} \|i${},{}$ \|j;\7
\&{for} ${}(\|i\K\|j\K\T{1};{}$ ${}\|i<\\{learned}\MG\\{size};{}$ ${}\|i\PP){}$%
\5
${}\{{}$\1\6
\&{variable} \|x${}\K\\{fs\_lit2var}(\\{learned}\MG\\{data}[\|i]);{}$\7
\&{if} ${}(\\{getReason}(\|f,\39{}$(\&{literal}) \|x)${}\E\.{NO\_CLS}){}$\1\5
${}\\{learned}\MG\\{data}[\|j\PP]\K\\{learned}\MG\\{data}[\|i];{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{uintptr\_t} \|r${}\K\\{getReason}(\|f,\39\\{learned}\MG\\{data}[\|i]);{}$\6
\&{struct} \&{clause\_iter} \\{it};\7
${}\\{clause\_iter\_init}(\|f,\39\|r,\39{\AND}\\{it});{}$\6
${}\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$\6
\&{for} (\&{literal} ${}{*}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it});{}$
\|p; ${}\|p\K\\{clause\_iter\_next}(\|f,\39{\AND}\\{it})){}$\5
${}\{{}$\6
\8\#\&{if} \T{0}\1\6
\&{if} ${}(\R\\{seen}[\\{var}(\|c[\|k])]\W\\{level}(\\{var}(\|c[\|k]))>%
\T{0}){}$\5
${}\{{}$\1\6
${}\\{learned}[\|j\PP]\K\\{learned}[\|i];{}$\6
\&{break};\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\C{ utilities }%
\C{**********************************************************************}\2\7
\&{static} \&{int} \\{compareByActivityRev}(\&{const} \&{void} ${}{*}\\{cl1},%
\39{}$\&{const} \&{void} ${}{*}\\{cl2}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{clause} ${}{*}\\{c1}\K{*}{}$(\&{clause} ${}{*}{*}){}$ \\{cl1};\6
\&{clause} ${}{*}\\{c2}\K{*}{}$(\&{clause} ${}{*}{*}){}$ \\{cl2};\6
\&{double} \\{s1}${}\K\\{c1}\MG\\{activity},{}$ \\{s2}${}\K\\{c2}\MG%
\\{activity};{}$\7
\&{if} ${}(\\{s1}\E\\{s2}){}$\1\5
\&{return} \T{0};\2\6
\&{else} \&{if} ${}(\\{s1}>\\{s2}){}$\1\5
\&{return} ${}{-}\T{1};{}$\2\6
\&{else}\1\5
\&{return} \T{1};\2\6
\4${}\}{}$\2\par
\fi

\M{239}


\Y\B\4\D$\\{otherWatchIdx}(\\{watchIdx})$ \5
$((\\{watchIdx})\E\T{0}\?\T{1}:\T{0}{}$)\C{Gets the index of the other watch
given the index of the current watch.}\par
\B\4\D$\\{forEachWatchedClause}(\|c,\|p,\\{wi},\\{nx},\\{end},\\{foundEnd})$ \5
\&{if} (\|c) \&{for} ${}(\\{wi}\K(\|c\MG\\{data}[\T{0}]\E\|p\?\T{0}:\T{1}),\39%
\\{end}\K\|c\MG\\{prev}[\\{wi}],\39\\{nx}\K\|c\MG\\{next}[\\{wi}],\39%
\\{foundEnd}\K\\{false};{}$ ${}\R\\{foundEnd};{}$ ${}\\{foundEnd}\K(\|c\E%
\\{end}),\39\|c\K\\{nx},\39\\{wi}\K(\|c\MG\\{data}[\T{0}]\E\|p\?\T{0}:\T{1}),%
\39\\{nx}\K\|c\MG\\{next}[\\{wi}]{}$)\par
\B\4\D$\\{forEachClause}(\|c,\\{nx},\\{end},\\{foundEnd})$ \5
\&{if} (\|c) \&{for} ${}(\\{end}\K\|c\MG\\{prev}[\T{0}],\39\\{nx}\K\|c\MG%
\\{next}[\T{0}],\39\\{foundEnd}\K\\{false};{}$ ${}\R\\{foundEnd};{}$ ${}%
\\{foundEnd}\K(\|c\E\\{end}),\39\|c\K\\{nx},\39\\{nx}\K\|c\MG\\{next}[%
\T{0}]{}$)\par
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{unsigned} \&{int} \\{fsLitHash}(\&{void} ${}{*}\\{lIn}){}$\1\1\2\2\6
${}\{{}$\C{ TODO get better hash function }\1\6
\&{literal} \|l${}\K{*}{}$(\&{literal} ${}{*}){}$ \\{lIn};\7
\&{return} (\&{unsigned} \&{int}) \|l;\6
\4${}\}{}$\2\7
\&{int} \\{fsLitEq}(\&{void} ${}{*}\|a,\39{}$\&{void} ${}{*}\|b){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} \|p${}\K{*}{}$(\&{literal} ${}{*}){}$ \|a${},{}$ \|q${}\K{*}{}$(%
\&{literal} ${}{*}){}$ \|b;\7
\&{return} \|p${}\E\|q;{}$\6
\4${}\}{}$\2\7
\&{unsigned} \&{int} \\{fsVarHash}(\&{void} ${}{*}\\{lIn}){}$\1\1\2\2\6
${}\{{}$\C{ TODO get better hash function }\1\6
\&{literal} \|l${}\K{*}{}$(\&{literal} ${}{*}){}$ \\{lIn};\7
\&{return} (\&{unsigned} \&{int}) \\{fs\_lit2var}(\|l);\6
\4${}\}{}$\2\7
\&{int} \\{fsVarEq}(\&{void} ${}{*}\|a,\39{}$\&{void} ${}{*}\|b){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} \|p${}\K{*}{}$(\&{literal} ${}{*}){}$ \|a${},{}$ \|q${}\K{*}{}$(%
\&{literal} ${}{*}){}$ \|b;\7
\&{return} \\{fs\_lit2var}(\|p)${}\E\\{fs\_lit2var}(\|q);{}$\6
\4${}\}{}$\2\7
\&{int} \\{litCompare}(\&{const} \&{void} ${}{*}\\{l1},\39{}$\&{const} \&{void}
${}{*}\\{l2}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{literal} \|x${}\K{*}{}$(\&{literal} ${}{*}){}$ \\{l1}${},{}$ \|y${}\K{*}{}$(%
\&{literal} ${}{*}){}$ \\{l2};\7
\&{if} ${}(\\{fs\_lit2var}(\|x)\I\\{fs\_lit2var}(\|y)){}$\5
${}\{{}$\1\6
\&{return} \\{fs\_lit2var}(\|x)${}<\\{fs\_lit2var}(\|y)\?{-}\T{1}:\T{1};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\|x\E\|y){}$\5
${}\{{}$\1\6
\&{return} \T{0};\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{return} \|x${}<\|y\?{-}\T{1}:\T{1};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\8\#\&{if} \T{0}\7
\&{int} \\{clauseCompare}(\&{const} \&{void} ${}{*}\\{cp1},\39{}$\&{const} %
\&{void} ${}{*}\\{cp2}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{const} \&{clause} ${}{*}\|c\K{*}{}$(\&{clause} ${}{*}{*}){}$ \\{cp1}${},{}$
${}{*}\|d\K{*}{}$(\&{clause} ${}{*}{*}){}$ \\{cp2};\7
\&{if} ${}(\|c\MG\\{size}\I\|d\MG\\{size}){}$\5
${}\{{}$\1\6
\&{return} \|c${}\MG\\{size}<\|d\MG\\{size}\?{-}\T{1}:\T{1};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\C{ lexicographically compare }\1\6
\&{uint32\_t} \|i;\7
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\|c\MG\\{size};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{int} \\{ret};\7
\&{if} ${}(\T{0}\I(\\{ret}\K\\{litCompare}({\AND}\|c\MG\\{data}[\|i],\39{\AND}%
\|d\MG\\{data}[\|i]))){}$\5
${}\{{}$\1\6
\&{return} \\{ret};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{return} \T{0};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\8\#\&{endif}\6
\&{void}  \\{sortClause} ( \&{clause} ${}{*}{}$\1\1 \&{clause} ) \6
${}\{{}$\1\6
${}\\{qsort}(\&{clause}\MG\\{data},\39\&{clause}\MG\\{size},\39\&{sizeof}({*}%
\&{clause}\MG\\{data}),\39\\{litCompare});{}$\6
\4${}\}{}$\2\6
\&{literal}  \\{findLiteral} (\&{literal} \|p${},\39$ \&{clause} ${}{*}{}$\1\1 %
\&{clause} ) $\{$ \&{literal} \\{min}${}\K\T{0},{}$ \\{max} $\K$ $\&{clause}\MG%
\\{size}-\T{1},{}$ \\{mid}${}\K{-}\T{1};{}$\6
\&{int} \\{res}${}\K{-}\T{1}{}$;\C{ comparison }\7
\&{while} ${}(\R(\\{res}\E\T{0}\V\\{min}>\\{max})){}$\5
${}\{{}$\1\6
${}\\{mid}\K\\{min}+((\\{max}-\\{min})/\T{2});{}$\6
${}\\{res}\K\\{litCompare}({\AND}\|p,\39{\AND}\&{clause}\MG\\{data}[%
\\{mid}]);{}$\6
\&{if} ${}(\\{res}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{min}\K\\{mid}+\T{1};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{max}\K\\{mid}-\T{1};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{return} \\{res}${}\E\T{0}\?\\{mid}:{-}\T{1};$ $\}$ \&{literal}  %
\\{findVariable} (\&{variable} \|v${},\39$ \&{clause} ${}{*}{}$\1\1 \&{clause}
) $\{$ \&{literal} \\{min}${}\K\T{0},{}$ \\{max} $\K$ $\&{clause}\MG\\{size}-%
\T{1},{}$ \\{mid}${}\K{-}\T{1};{}$\6
\&{int} \\{res}${}\K{-}\T{1}{}$;\C{ comparison }\7
\&{while} ${}(\R(\\{res}\E\T{0}\V\\{min}>\\{max})){}$\5
${}\{{}$\1\6
${}\\{mid}\K\\{min}+((\\{max}-\\{min})/\T{2});{}$\6
\&{if} ${}(\|v\E\\{fs\_lit2var}(\&{clause}\MG\\{data}[\\{mid}])){}$\5
${}\{{}$\1\6
${}\\{res}\K\T{0};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{literal} \|p${}\K\\{fs\_var2lit}(\|v);{}$\7
${}\\{res}\K\\{litCompare}({\AND}\|p,\39{\AND}\&{clause}\MG\\{data}[%
\\{mid}]);{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{res}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{min}\K\\{mid}+\T{1};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{max}\K\\{mid}-\T{1};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{return} \\{res}${}\E\T{0}\?\\{mid}:{-}\T{1};$ $\}{}$\C{ Low level clause
manipulations. }\6
\&{clause} ${}{*}{}$\\{clauseAlloc}(\&{uint32\_t} \\{capacity})\1\1\2\2\6
${}\{{}$\1\6
\&{clause} ${}{*}\|c;{}$\7
${}\.{FS\_MALLOC}(\|c,\39\T{1},\39{}$\&{sizeof} ${}({*}\|c));{}$\6
${}\\{clauseInit}(\|c,\39\\{capacity});{}$\6
\&{return} \|c;\6
\4${}\}{}$\2\par
\fi

\M{240}

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\C{*  * Generates a clause that
is  *   1) satisfied if a given literal violates the current assignment and  *
 2) falsified only under the current assignment.  }\6
\&{clause} ${}{*}{}$\\{funcsatSolToClause}(\&{funcsat} ${}{*}\|f){}$\1\1\2\2\6
${}\{{}$\1\6
\&{clause} ${}{*}\|c\K\\{clauseAlloc}(\|f\MG\\{trail}.\\{size});{}$\7
\&{for} (\&{uintmax\_t} \|i${}\K\T{0};{}$ ${}\|i<\|f\MG\\{trail}.\\{size};{}$
${}\|i\PP){}$\1\5
${}\\{clausePush}(\|c,\39{-}\|f\MG\\{trail}.\\{data}[\|i]);{}$\2\6
\&{return} \|c;\6
\4${}\}{}$\2\7
\&{funcsat\_result} \\{funcsatFindAnotherSolution}(\&{funcsat} ${}{*}\|f){}$\1%
\1\2\2\6
${}\{{}$\1\6
\&{clause} ${}{*}\\{cur\_sol}\K\\{funcsatSolToClause}(\|f);{}$\6
\&{funcsat\_result} \\{res}${}\K\\{funcsatAddClause}(\|f,\39\\{cur\_sol});{}$\7
\&{if} ${}(\\{res}\E\.{FS\_UNSAT}){}$\1\5
\&{return} \.{FS\_UNSAT};\2\6
${}\\{res}\K\\{funcsatSolve}(\|f);{}$\6
\&{return} \\{res};\6
\4${}\}{}$\2\7
\&{intmax\_t} \\{funcsatSolCount}(\&{funcsat} ${}{*}\|f,\39{}$\&{clause} %
\\{subset}${},\39{}$\&{clause} ${}{*}\\{lastSolution}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{assert}(\|f\MG\\{assumptions}.\\{size}\E\T{0});{}$\7
\&{intmax\_t} \\{count}${}\K\T{0};{}$\7
\&{for} (\&{uintmax\_t} \|i${}\K\T{0};{}$ ${}\|i<\\{subset}.\\{size};{}$ ${}\|i%
\PP){}$\5
${}\{{}$\1\6
${}\\{funcsatResize}(\|f,\39\\{fs\_lit2var}(\\{subset}.\\{data}[\|i]));{}$\6
\4${}\}{}$\2\7
\&{clause} \\{assumptions};\7
${}\\{clauseInit}({\AND}\\{assumptions},\39\\{subset}.\\{size});{}$\7
\&{uintmax\_t} \\{twopn}${}\K{}$(\&{uintmax\_t}) \\{round}${}(\\{pow}(\T{2.},%
\39{}$(\&{double}) \\{subset}${}.\\{size}));{}$\7
${}\\{fslog}(\|f,\39\.{"countsol"},\39\T{1},\39\.{"\%ju\ incremental\ pro}\)%
\.{blems\ to\ solve\\n"},\39\\{twopn});{}$\6
\&{for} (\&{uintmax\_t} \|i${}\K\T{0};{}$ ${}\|i<\\{twopn};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"countsol"},\39\T{2},\39\.{"\%ju:\ "},\39\|i);{}$\6
${}\\{clauseClear}({\AND}\\{assumptions});{}$\6
${}\\{clauseCopy}({\AND}\\{assumptions},\39{\AND}\\{subset}){}$;\C{ negate
literals that are 0 in n. }\7
\&{uintmax\_t} \|n${}\K\|i;{}$\7
\&{for} (\&{uintmax\_t} \|j${}\K\T{0};{}$ ${}\|j<\\{subset}.\\{size};{}$ ${}\|j%
\PP){}$\5
${}\{{}$\C{ 0 bit }\1\6
\&{if} ${}((\|n\MOD\T{2})\E\T{0}){}$\1\5
${}\\{assumptions}.\\{data}[\|j]\MRL{*{\K}}{-}\T{1};{}$\2\6
${}\|n\MRL{{\GG}{\K}}\T{1};{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{funcsatPushAssumptions}(\|f,\39{\AND}\\{assumptions})\E\.{FS%
\_UNSAT}){}$\5
${}\{{}$\1\6
\&{continue};\6
\4${}\}{}$\2\6
\&{if} ${}(\.{FS\_SAT}\E\\{funcsatSolve}(\|f)){}$\5
${}\{{}$\1\6
${}\\{count}\PP;{}$\6
\&{if} (\\{lastSolution})\5
${}\{{}$\1\6
\\{clauseClear}(\\{lastSolution});\6
${}\\{clauseCopy}(\\{lastSolution},\39{\AND}\|f\MG\\{trail});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{funcsatPopAssumptions}(\|f,\39\|f\MG\\{assumptions}.\\{size});{}$\6
\4${}\}{}$\2\6
${}\\{clauseDestroy}({\AND}\\{assumptions});{}$\6
\&{return} \\{count};\6
\4${}\}{}$\2\par
\fi

\N{2}{241}Rest.

\Y\B\4\X25:Internal declarations\X${}\mathrel+\E{}$\6
\&{static} \&{void} \\{finishSolving}(\&{funcsat} ${}{*}\\{func});{}$\6
\&{static} \&{bool} \\{bcpAndJail}(\&{funcsat} ${}{*}\|f);{}$\6
\&{bool} \\{funcsatLubyRestart}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}%
\|p);{}$\6
\&{bool} \\{funcsatNoRestart}(\&{funcsat} ${}{*},\39{}$\&{void} ${}{*});{}$\6
\&{bool} \\{funcsatInnerOuter}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}%
\|p);{}$\6
\&{bool} \\{funcsatMinisatRestart}(\&{funcsat} ${}{*}\|f,\39{}$\&{void} ${}{*}%
\|p){}$;\C{*  * Undoes the given set of unit assumptions.  Assumes the decision
level is 0.  }\6
\&{void} \\{undoAssumptions}(\&{funcsat} ${}{*}\\{func},\39{}$\&{clause} ${}{*}%
\\{assumptions});{}$\6
\&{funcsat\_result} \\{startSolving}(\&{funcsat} ${}{*}\|f){}$;\C{*  * Analyses
conflict, produces learned clauses, backtracks, and asserts the  * learned
clauses.  If returns false, this means the SAT problem is unsat; if  * it
returns true, it means the SAT problem is not known to be unsat.  }\6
\&{bool} \\{analyze\_conflict}(\&{funcsat} ${}{*}\\{func}){}$;\C{*  * Undoes
the trail and assignments so that the new decision level is  *
::newDecisionLevel.  The lowest decision level is 0.  *  * @param func  *
@param newDecisionLevel  * @param isRestart  * @param facts same as in
::trailPop  }\6
\&{void} \\{backtrack}(\&{funcsat} ${}{*}\\{func},\39{}$\&{variable} %
\\{newDecisionLevel}${},\39{}$\&{head\_tail} ${}{*}\\{facts},\39{}$\&{bool} %
\\{isRestart});\C{ Mutators }\6
\&{void} \\{fs\_print\_state}(\&{funcsat} ${}{*},\39{}$\&{FILE} ${}{*});{}$\6
\&{void} \\{funcsatPrintConfig}(\&{FILE} ${}{*}\|f,\39{}$\&{funcsat}
${}{*});{}$\6
\&{bool} \\{funcsatIsResourceLimitHit}(\&{funcsat} ${}{*},\39{}$\&{void}
${}{*});{}$\6
\&{funcsat\_result} \\{funcsatPreprocessNewClause}(\&{funcsat} ${}{*},\39{}$%
\&{void} ${}{*},\39{}$\&{clause} ${}{*});{}$\6
\&{funcsat\_result} \\{funcsatPreprocessBeforeSolve}(\&{funcsat} ${}{*},\39{}$%
\&{void} ${}{*});{}$\6
\&{variable} \\{funcsatLearnClauses}(\&{funcsat} ${}{*},\39{}$\&{void}
${}{*});$ \&{int}  \\{varOrderCompare} ( \\{fibkey} $*$ $,$ \\{fibkey} $*$ )  ;%
\7
\&{double} \\{funcsatDefaultStaticActivity}(\&{variable} ${}{*}\|v);{}$\6
\&{void} \\{singlesPrint}(\&{FILE} ${}{*}\\{stream},\39{}$\&{clause} ${}{*}%
\\{begin});{}$\6
\&{bool} \\{watcherFind}(\&{clause} ${}{*}\|c,\39{}$\&{clause} ${}{*}{*}%
\\{watches},\39{}$\&{uint8\_t} \|w);\6
\&{void} \\{watcherPrint}(\&{FILE} ${}{*}\\{stream},\39{}$\&{clause} ${}{*}\|c,%
\39{}$\&{uint8\_t} \|w);\6
\&{void} \\{singlesPrint}(\&{FILE} ${}{*}\\{stream},\39{}$\&{clause} ${}{*}%
\\{begin});{}$\6
\&{void} \\{binWatcherPrint}(\&{FILE} ${}{*}\\{stream},\39{}$\&{funcsat} ${}{*}%
\|f){}$;\C{*  * FOR DEBUGGING  }\6
\&{bool} \\{isUnitClause}(\&{funcsat} ${}{*}\|f,\39{}$\&{clause} ${}{*}\|c){}$;%
\C{*  * Returns the decision level of the given variable.  }\6
\&{literal} \\{levelOf}(\&{funcsat} ${}{*}\|f,\39{}$\&{variable} \|v);\6
\&{extern} \&{variable} \\{fs\_lit2var}(\&{literal} \|l);\C{*  * Returns the
positive literal of the given variable.  }\6
\&{literal} \\{fs\_var2lit}(\&{variable} \|v);\C{*  * Converts lit to int
suitable for array indexing }\6
\&{uintmax\_t} \\{fs\_lit2idx}(\&{literal} \|l);\6
\&{extern} \&{bool} \\{isDecision}(\&{funcsat} ${}{*},\39\&{variable}){}$;\C{
sorted clause manipulation }\C{*  * Sorts the literals in a clause.  Useful for
performing clause operations  * (::findLiteral, ::findVariable, ::clauseRemove,
and  * resolution) in logarithmic time in the size of the clause.  }\6
\&{void} \\{sortClause}(\&{clause} ${}{*}\|c){}$;\C{*  * Finds a literal using
binary search on the given clause.  Returns the  * literal's index (0 ..
clause->size-1) if found, -1 otherwise.  }\6
\&{literal} \\{findLiteral}(\&{literal} \|l${},\39{}$\&{clause} ${}{*}){}$;\C{*
 * Same as ::findLiteral but works on variables.  }\6
\&{literal} \\{findVariable}(\&{variable} \|l${},\39{}$\&{clause} ${}{*});{}$\6
\&{unsigned} \&{int} \\{fsLitHash}(\&{void} ${}{*});{}$\6
\&{int} \\{fsLitEq}(\&{void} ${}{*},\39{}$\&{void} ${}{*});{}$\6
\&{int} \\{litCompare}(\&{const} \&{void} ${}{*}\\{l1},\39{}$\&{const} \&{void}
${}{*}\\{l2}){}$;\par
\fi

\M{242}

\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{extern} \&{mbool} \\{funcsatValue}(\&{funcsat} ${}{*}\|f,\39{}$\&{literal} %
\|p)\1\1\2\2\6
${}\{{}$\1\6
\&{variable} \|v${}\K\\{fs\_lit2var}(\|p);{}$\7
\&{if} ${}(\|f\MG\\{level}.\\{data}[\|v]\E\\{Unassigned}){}$\1\5
\&{return} \\{unknown};\2\7
\&{literal} \\{value}${}\K\|f\MG\\{trail}.\\{data}[\|f\MG\\{model}.\\{data}[%
\|v]];{}$\7
\&{return} \|p${}\E\\{value};{}$\6
\4${}\}{}$\2\par
\fi

\M{243}Prototype.
\Y\B\4\X15:External declarations\X${}\mathrel+\E{}$\6
\&{funcsat\_result} \\{fs\_parse\_dimacs\_solution}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{FILE} ${}{*}\\{solutionFile}){}$;\par
\fi

\M{244}Parse solution.
\Y\B\4\X16:Global definitions\X${}\mathrel+\E{}$\6
\&{static} \&{char} \\{parse\_read\_char}(\&{funcsat} ${}{*}\|f,\39{}$\&{FILE}
${}{*}\\{solutionFile}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{char} \|c;\7
${}\|c\K\\{fgetc}(\\{solutionFile});{}$\6
\8\#\&{if} \T{0}\6
${}\\{bf\_log}(\|b,\39\.{"bf"},\39\T{8},\39\.{"Read\ character\ '\%c'}\)\.{%
\\n"},\39\|c);{}$\6
\8\#\&{endif}\6
\&{return} \|c;\6
\4${}\}{}$\2\7
\&{static} \&{const} \&{char} ${}{*}\\{s\_SATISFIABLE}\K\.{"SATISFIABLE%
\\n"};{}$\6
\&{static} \&{const} \&{char} ${}{*}\\{s\_UNSATISFIABLE}\K\.{"UNSATISFIABLE%
\\n"};{}$\7
\&{funcsat\_result} \\{fs\_parse\_dimacs\_solution}(\&{funcsat} ${}{*}\|f,%
\39{}$\&{FILE} ${}{*}\\{solutionFile}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{char} \|c;\6
\&{literal} \\{var};\6
\&{bool} \\{truth};\6
\&{funcsat\_result} \\{result}${}\K\.{FS\_UNKNOWN};{}$\6
\&{bool} \\{have\_var}${}\K\\{false};{}$\6
\&{const} \&{char} ${}{*}\\{cur};{}$\7
\4\\{state\_new\_line}:\6
\&{while} (\\{true})\5
${}\{{}$\1\6
${}\|c\K\\{parse\_read\_char}(\|f,\39\\{solutionFile});{}$\6
\&{switch} (\|c)\5
${}\{{}$\1\6
\4\&{case} \.{EOF}:\5
\&{goto} \\{state\_eof};\6
\4\&{case} \.{'c'}:\5
\&{goto} \\{state\_comment};\6
\4\&{case} \.{'s'}:\5
\&{goto} \\{state\_satisfiablility};\6
\4\&{case} \.{'v'}:\5
\&{goto} \\{state\_variables};\6
\4\&{default}:\5
${}\\{fslog}(\|f,\39\.{"fs"},\39\T{1},\39\.{"unknown\ line\ type\ '}\)\.{\%c'\
in\ solution\ file}\)\.{\\n"},\39\|c);{}$\6
\&{goto} \\{state\_error};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4\\{state\_comment}:\6
\&{while} (\\{true})\5
${}\{{}$\1\6
${}\|c\K\\{parse\_read\_char}(\|f,\39\\{solutionFile});{}$\6
\&{switch} (\|c)\5
${}\{{}$\1\6
\4\&{case} \.{EOF}:\5
\&{goto} \\{state\_eof};\6
\4\&{case} \.{'\\n'}:\5
\&{goto} \\{state\_new\_line};\6
\4\&{default}:\5
\&{break};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4\\{state\_satisfiablility}:\5
${}\\{cur}\K\NULL;{}$\7
\&{funcsat\_result} \\{pending}${}\K\.{FS\_UNKNOWN};{}$\7
\&{while} (\\{true})\5
${}\{{}$\1\6
${}\|c\K\\{parse\_read\_char}(\|f,\39\\{solutionFile});{}$\6
\&{switch} (\|c)\5
${}\{{}$\1\6
\4\&{case} \.{'\ '}:\5
\&{case} \.{'\\t'}:\5
\&{continue};\6
\4\&{case} \.{EOF}:\5
\&{goto} \\{state\_eof};\6
\4\&{default}:\5
${}\\{ungetc}(\|c,\39\\{solutionFile});{}$\6
\&{break};\6
\4${}\}{}$\2\6
\&{break};\6
\4${}\}{}$\2\6
\&{while} (\\{true})\5
${}\{{}$\1\6
${}\|c\K\\{parse\_read\_char}(\|f,\39\\{solutionFile});{}$\6
\&{if} ${}(\\{cur}\E\NULL){}$\5
${}\{{}$\1\6
\&{switch} (\|c)\5
${}\{{}$\1\6
\4\&{case} \.{'S'}:\5
${}\\{cur}\K{\AND}\\{s\_SATISFIABLE}[\T{1}];{}$\6
${}\\{pending}\K\.{FS\_SAT};{}$\6
\&{break};\6
\4\&{case} \.{'U'}:\5
${}\\{cur}\K{\AND}\\{s\_UNSATISFIABLE}[\T{1}];{}$\6
${}\\{pending}\K\.{FS\_UNSAT};{}$\6
\&{break};\6
\4\&{case} \.{EOF}:\5
\&{goto} \\{state\_eof};\6
\4\&{default}:\5
${}\\{fslog}(\|f,\39\.{"fs"},\39\T{1},\39\.{"unknown\ satisfiabil}\)\.{ity%
\\n"});{}$\6
\&{goto} \\{state\_error};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\|c\E\.{EOF}){}$\5
${}\{{}$\1\6
\&{goto} \\{state\_eof};\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\|c\I{*}\\{cur}){}$\5
${}\{{}$\1\6
${}\\{fslog}(\|f,\39\.{"fs"},\39\T{1},\39\.{"reading\ satisfiabil}\)\.{ity,\
got\ '\%c',\ expec}\)\.{ted\ '\%c'\\n"},\39\|c,\39{*}\\{cur});{}$\6
\&{goto} \\{state\_error};\6
\4${}\}{}$\2\6
\&{if} ${}(\|c\E\.{'\\n'}){}$\5
${}\{{}$\1\6
${}\\{result}\K\\{pending};{}$\6
\&{goto} \\{state\_new\_line};\6
\4${}\}{}$\2\6
${}\PP\\{cur};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4\\{state\_variables}:\6
\&{while} (\\{true})\5
${}\{{}$\1\6
${}\|c\K\\{parse\_read\_char}(\|f,\39\\{solutionFile});{}$\6
\&{switch} (\|c)\5
${}\{{}$\1\6
\4\&{case} \.{'\\n'}:\5
\&{goto} \\{state\_new\_line};\6
\4\&{case} \.{'\ '}:\5
\&{case} \.{'\\t'}:\5
\&{break};\6
\4\&{case} \.{EOF}:\5
\&{goto} \\{state\_eof};\6
\4\&{default}:\5
${}\\{ungetc}(\|c,\39\\{solutionFile});{}$\6
\&{goto} \\{state\_sign};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4\\{state\_sign}:\5
${}\\{have\_var}\K\\{false};{}$\6
${}\\{truth}\K\\{true};{}$\6
${}\|c\K\\{parse\_read\_char}(\|f,\39\\{solutionFile});{}$\6
\&{if} ${}(\|c\E\.{'-'}){}$\5
${}\{{}$\1\6
${}\\{truth}\K\\{false};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{ungetc}(\|c,\39\\{solutionFile});{}$\6
\4${}\}{}$\2\6
${}\\{var}\K\T{0};{}$\6
\&{goto} \\{state\_variable};\6
\4\\{state\_variable}:\6
\&{while} (\\{true})\5
${}\{{}$\1\6
${}\|c\K\\{parse\_read\_char}(\|f,\39\\{solutionFile});{}$\6
\&{switch} (\|c)\5
${}\{{}$\1\6
\4\&{case} \.{'0'}:\5
\&{case} \.{'1'}:\5
\&{case} \.{'2'}:\5
\&{case} \.{'3'}:\5
\&{case} \.{'4'}:\5
\&{case} \.{'5'}:\5
\&{case} \.{'6'}:\5
\&{case} \.{'7'}:\5
\&{case} \.{'8'}:\5
\&{case} \.{'9'}:\5
${}\\{have\_var}\K\\{true};{}$\6
${}\\{var}\K\\{var}*\T{10}+(\|c-\.{'0'});{}$\6
\&{break};\6
\4\&{default}:\5
${}\\{ungetc}(\|c,\39\\{solutionFile});{}$\6
\&{goto} \\{state\_record\_variable};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4\\{state\_record\_variable}:\6
\&{if} (\\{have\_var})\5
${}\{{}$\1\6
\&{if} ${}(\\{var}\E\T{0}){}$\5
${}\{{}$\C{ sometimes the SAT solver will be told ``there are 47000 variables
but        * I'm only going to use 100 of them in the instance.'' {\bf some
solvers}        * (lingeling) will say ``ah well i can get rid of 46000
variables! i have        * been so helpful today!'' which is all well and good
except that then it        * outputs the solution on only the 100 of them that
are used. in this        * case, we log what happened and hope that giving an
arbitrary assignment        * (false) to the rest of the inputs is the right
thing. }\C{ we assume this doesn't happen }\1\6
\&{goto} \\{state\_exit};\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{variable} \|v${}\K\\{fs\_lit2var}(\\{var});{}$\7
${}\\{funcsatPushAssumption}(\|f,\39(\\{truth}\?{}$(\&{literal}) \|v${}:{-}{}$(%
\&{literal}) \|v));\6
\4${}\}{}$\2\6
\&{goto} \\{state\_variables};\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\\{abort}(\,);\6
${}\\{fslog}(\|f,\39\.{"fs"},\39\T{1},\39\.{"expected\ variable,\ }\)\.{but\
didn't\ get\ one\\n}\)\.{"});{}$\6
\&{goto} \\{state\_error};\6
\4${}\}{}$\2\6
\4\\{state\_eof}:\6
\&{if} (\\{ferror}(\\{solutionFile}))\5
${}\{{}$\1\6
\\{abort}(\,);\6
${}\\{fslog}(\|f,\39\.{"fs"},\39\T{1},\39\.{"IO\ error\ reading\ so}\)\.{lution%
\ file:\ \%s"},\39\\{strerror}(\\{errno}));{}$\6
\&{goto} \\{state\_error};\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{goto} \\{state\_exit};\6
\4${}\}{}$\2\6
\4\\{state\_error}:\5
${}\\{result}\K\.{FS\_UNKNOWN};{}$\6
\&{goto} \\{state\_exit};\6
\4\\{state\_exit}:\5
\&{return} \\{result};\6
\4${}\}{}$\2\par
\fi

\M{245}
\Y\B\4\X245:\.{funcsat\_test.c }\X${}\E{}$\6
\8\#\&{include} \.{"funcsat.h"}\par
\fi

\inx
\fin
\con
